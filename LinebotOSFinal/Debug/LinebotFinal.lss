
LinebotFinal.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004cc6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ee  00802000  00004cc6  00004d5a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000013e  008020ee  008020ee  00004e48  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004e48  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004ea4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000710  00000000  00000000  00004ee4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e2cb  00000000  00000000  000055f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004c6a  00000000  00000000  000138bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005aa4  00000000  00000000  00018529  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000017cc  00000000  00000000  0001dfd0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004434  00000000  00000000  0001f79c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009690  00000000  00000000  00023bd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009a8  00000000  00000000  0002d260  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 89 01 	jmp	0x312	; 0x312 <__ctors_end>
       4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
       8:	0c 94 03 04 	jmp	0x806	; 0x806 <__vector_2>
       c:	0c 94 8a 04 	jmp	0x914	; 0x914 <__vector_3>
      10:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      14:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      18:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      1c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      20:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      24:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      28:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      2c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      30:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      34:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      38:	0c 94 63 0b 	jmp	0x16c6	; 0x16c6 <__vector_14>
      3c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      40:	0c 94 d7 0b 	jmp	0x17ae	; 0x17ae <__vector_16>
      44:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      48:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      4c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      50:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      54:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      58:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      5c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      60:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      64:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      68:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      6c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      70:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      74:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      78:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      7c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      80:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      84:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      88:	0c 94 34 02 	jmp	0x468	; 0x468 <__vector_34>
      8c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      90:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      94:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      98:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      9c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      a0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      a4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      a8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      ac:	0c 94 11 05 	jmp	0xa22	; 0xa22 <__vector_43>
      b0:	0c 94 98 05 	jmp	0xb30	; 0xb30 <__vector_44>
      b4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      b8:	0c 94 f1 07 	jmp	0xfe2	; 0xfe2 <__vector_46>
      bc:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      c0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      c4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      c8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      cc:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      d0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      d4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      d8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      dc:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      e0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      e4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      e8:	0c 94 a2 08 	jmp	0x1144	; 0x1144 <__vector_58>
      ec:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      f0:	0c 94 5b 08 	jmp	0x10b6	; 0x10b6 <__vector_60>
      f4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      f8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
      fc:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     100:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     104:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     108:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     10c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     110:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     114:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     118:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     11c:	0c 94 ac 01 	jmp	0x358	; 0x358 <__vector_71>
     120:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     124:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     128:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     12c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     130:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     134:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     138:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     13c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     140:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     144:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     148:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     14c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     150:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     154:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     158:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     15c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     160:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     164:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     168:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     16c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     170:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     174:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     178:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     17c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     180:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     184:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     188:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     18c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     190:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     194:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     198:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     19c:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1a0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1a4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1a8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1ac:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1b0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1b4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1b8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1bc:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1c0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1c4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1c8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1cc:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1d0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1d4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1d8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1dc:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1e0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1e4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1e8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1ec:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1f0:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1f4:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>
     1f8:	0c 94 aa 01 	jmp	0x354	; 0x354 <__bad_interrupt>

000001fc <__trampolines_start>:
     1fc:	0c 94 00 1c 	jmp	0x3800	; 0x3800 <WorkerMotorSpeed>
     200:	0c 94 c8 11 	jmp	0x2390	; 0x2390 <prvIdleTask>
     204:	0c 94 76 1c 	jmp	0x38ec	; 0x38ec <WorkerRGB>
     208:	0c 94 42 1a 	jmp	0x3484	; 0x3484 <WorkerMotorPos>
     20c:	0c 94 7c 1d 	jmp	0x3af8	; 0x3af8 <WorkerStartup>

00000210 <__trampolines_end>:
     210:	6e 61       	ori	r22, 0x1E	; 30
     212:	6e 00       	.word	0x006e	; ????

00000214 <__c.2332>:
     214:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     224:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     234:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     244:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     254:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     264:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     274:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     284:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     294:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     2a4:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     2b4:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     2c4:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     2d4:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     2e4:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     2f4:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     304:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000312 <__ctors_end>:
     312:	11 24       	eor	r1, r1
     314:	1f be       	out	0x3f, r1	; 63
     316:	cf ef       	ldi	r28, 0xFF	; 255
     318:	cd bf       	out	0x3d, r28	; 61
     31a:	df e9       	ldi	r29, 0x9F	; 159
     31c:	de bf       	out	0x3e, r29	; 62
     31e:	00 e0       	ldi	r16, 0x00	; 0
     320:	0c bf       	out	0x3c, r16	; 60

00000322 <__do_copy_data>:
     322:	10 e2       	ldi	r17, 0x20	; 32
     324:	a0 e0       	ldi	r26, 0x00	; 0
     326:	b0 e2       	ldi	r27, 0x20	; 32
     328:	e6 ec       	ldi	r30, 0xC6	; 198
     32a:	fc e4       	ldi	r31, 0x4C	; 76
     32c:	00 e0       	ldi	r16, 0x00	; 0
     32e:	0b bf       	out	0x3b, r16	; 59
     330:	02 c0       	rjmp	.+4      	; 0x336 <__do_copy_data+0x14>
     332:	07 90       	elpm	r0, Z+
     334:	0d 92       	st	X+, r0
     336:	ae 3e       	cpi	r26, 0xEE	; 238
     338:	b1 07       	cpc	r27, r17
     33a:	d9 f7       	brne	.-10     	; 0x332 <__do_copy_data+0x10>

0000033c <__do_clear_bss>:
     33c:	22 e2       	ldi	r18, 0x22	; 34
     33e:	ae ee       	ldi	r26, 0xEE	; 238
     340:	b0 e2       	ldi	r27, 0x20	; 32
     342:	01 c0       	rjmp	.+2      	; 0x346 <.do_clear_bss_start>

00000344 <.do_clear_bss_loop>:
     344:	1d 92       	st	X+, r1

00000346 <.do_clear_bss_start>:
     346:	ac 32       	cpi	r26, 0x2C	; 44
     348:	b2 07       	cpc	r27, r18
     34a:	e1 f7       	brne	.-8      	; 0x344 <.do_clear_bss_loop>
     34c:	0e 94 20 1a 	call	0x3440	; 0x3440 <main>
     350:	0c 94 61 26 	jmp	0x4cc2	; 0x4cc2 <_exit>

00000354 <__bad_interrupt>:
     354:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000358 <__vector_71>:
	xSemaphoreGive(AdcBusySema);
	return Res;
}

ISR(ADCA_CH0_vect)
{
     358:	1f 92       	push	r1
     35a:	0f 92       	push	r0
     35c:	0f b6       	in	r0, 0x3f	; 63
     35e:	0f 92       	push	r0
     360:	11 24       	eor	r1, r1
     362:	0b b6       	in	r0, 0x3b	; 59
     364:	0f 92       	push	r0
     366:	2f 93       	push	r18
     368:	3f 93       	push	r19
     36a:	4f 93       	push	r20
     36c:	5f 93       	push	r21
     36e:	6f 93       	push	r22
     370:	7f 93       	push	r23
     372:	8f 93       	push	r24
     374:	9f 93       	push	r25
     376:	af 93       	push	r26
     378:	bf 93       	push	r27
     37a:	ef 93       	push	r30
     37c:	ff 93       	push	r31
     37e:	cf 93       	push	r28
     380:	df 93       	push	r29
     382:	1f 92       	push	r1
     384:	cd b7       	in	r28, 0x3d	; 61
     386:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     388:	19 82       	std	Y+1, r1	; 0x01
	xSemaphoreGiveFromISR(ConversionCompleteSema,&xHigherPriorityTaskWoken);
     38a:	be 01       	movw	r22, r28
     38c:	6f 5f       	subi	r22, 0xFF	; 255
     38e:	7f 4f       	sbci	r23, 0xFF	; 255
     390:	80 91 12 22 	lds	r24, 0x2212	; 0x802212 <ConversionCompleteSema>
     394:	90 91 13 22 	lds	r25, 0x2213	; 0x802213 <ConversionCompleteSema+0x1>
     398:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <xQueueGiveFromISR>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     39c:	89 81       	ldd	r24, Y+1	; 0x01
     39e:	81 11       	cpse	r24, r1
     3a0:	0e 94 3f 0b 	call	0x167e	; 0x167e <vPortYieldISR>
     3a4:	0f 90       	pop	r0
     3a6:	df 91       	pop	r29
     3a8:	cf 91       	pop	r28
     3aa:	ff 91       	pop	r31
     3ac:	ef 91       	pop	r30
     3ae:	bf 91       	pop	r27
     3b0:	af 91       	pop	r26
     3b2:	9f 91       	pop	r25
     3b4:	8f 91       	pop	r24
     3b6:	7f 91       	pop	r23
     3b8:	6f 91       	pop	r22
     3ba:	5f 91       	pop	r21
     3bc:	4f 91       	pop	r20
     3be:	3f 91       	pop	r19
     3c0:	2f 91       	pop	r18
     3c2:	0f 90       	pop	r0
     3c4:	0b be       	out	0x3b, r0	; 59
     3c6:	0f 90       	pop	r0
     3c8:	0f be       	out	0x3f, r0	; 63
     3ca:	0f 90       	pop	r0
     3cc:	1f 90       	pop	r1
     3ce:	18 95       	reti

000003d0 <DriverCursorstickInit>:

static QueueHandle_t CursorstickQueue;

void DriverCursorstickInit(void)
{
	PORTB.DIRCLR=0b11111000;
     3d0:	e0 e2       	ldi	r30, 0x20	; 32
     3d2:	f6 e0       	ldi	r31, 0x06	; 6
     3d4:	98 ef       	ldi	r25, 0xF8	; 248
     3d6:	92 83       	std	Z+2, r25	; 0x02
	PORTB.PIN3CTRL=0b01011001; //Pull up, inverted
     3d8:	89 e5       	ldi	r24, 0x59	; 89
     3da:	83 8b       	std	Z+19, r24	; 0x13
	PORTB.PIN4CTRL=0b01011001; //Pull up, inverted	
     3dc:	84 8b       	std	Z+20, r24	; 0x14
	PORTB.PIN5CTRL=0b01011001; //Pull up, inverted
     3de:	85 8b       	std	Z+21, r24	; 0x15
	PORTB.PIN6CTRL=0b01011001; //Pull up, inverted
     3e0:	86 8b       	std	Z+22, r24	; 0x16
	PORTB.PIN7CTRL=0b01011001; //Pull up, inverted
     3e2:	87 8b       	std	Z+23, r24	; 0x17
	PORTB.INT0MASK=0b11111000; //Interrupt on all cursor stick lines
     3e4:	92 87       	std	Z+10, r25	; 0x0a
	PORTB.INTCTRL=0b01;		   //Enable interrupt0
     3e6:	81 e0       	ldi	r24, 0x01	; 1
     3e8:	81 87       	std	Z+9, r24	; 0x09
	
	CursorstickQueue=xQueueCreate(CURSOR_FIFO_LENGTH,1);
     3ea:	40 e0       	ldi	r20, 0x00	; 0
     3ec:	61 e0       	ldi	r22, 0x01	; 1
     3ee:	8a e0       	ldi	r24, 0x0A	; 10
     3f0:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericCreate>
     3f4:	80 93 f2 20 	sts	0x20F2, r24	; 0x8020f2 <CursorstickQueue>
     3f8:	90 93 f3 20 	sts	0x20F3, r25	; 0x8020f3 <CursorstickQueue+0x1>
     3fc:	08 95       	ret

000003fe <DriverCursorstickGet>:
}

uint8_t DriverCursorstickGet(void)
{
	uint8_t ret=0;
	if (PORTB.IN & (1<<3)) ret|=(1<<4);
     3fe:	80 91 28 06 	lds	r24, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     402:	83 ff       	sbrs	r24, 3
     404:	12 c0       	rjmp	.+36     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     406:	80 e1       	ldi	r24, 0x10	; 16
	if (PORTB.IN & (1<<4)) ret|=(1<<3);
     408:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     40c:	94 fd       	sbrc	r25, 4
     40e:	88 60       	ori	r24, 0x08	; 8
	if (PORTB.IN & (1<<5)) ret|=(1<<2);
     410:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     414:	95 fd       	sbrc	r25, 5
     416:	84 60       	ori	r24, 0x04	; 4
	if (PORTB.IN & (1<<6)) ret|=(1<<1);
     418:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     41c:	96 fd       	sbrc	r25, 6
     41e:	82 60       	ori	r24, 0x02	; 2
	if (PORTB.IN & (1<<7)) ret|=(1<<0);
     420:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     424:	97 fd       	sbrc	r25, 7
     426:	03 c0       	rjmp	.+6      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>

	return ret;
}
     428:	08 95       	ret
	CursorstickQueue=xQueueCreate(CURSOR_FIFO_LENGTH,1);
}

uint8_t DriverCursorstickGet(void)
{
	uint8_t ret=0;
     42a:	80 e0       	ldi	r24, 0x00	; 0
     42c:	ed cf       	rjmp	.-38     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
	if (PORTB.IN & (1<<3)) ret|=(1<<4);
	if (PORTB.IN & (1<<4)) ret|=(1<<3);
	if (PORTB.IN & (1<<5)) ret|=(1<<2);
	if (PORTB.IN & (1<<6)) ret|=(1<<1);
	if (PORTB.IN & (1<<7)) ret|=(1<<0);
     42e:	81 60       	ori	r24, 0x01	; 1

	return ret;
}
     430:	08 95       	ret

00000432 <DriverCursorStickGetFifo>:

uint8_t DriverCursorStickGetFifo(TickType_t BlockTime)
{
     432:	cf 93       	push	r28
     434:	df 93       	push	r29
     436:	1f 92       	push	r1
     438:	cd b7       	in	r28, 0x3d	; 61
     43a:	de b7       	in	r29, 0x3e	; 62
	uint8_t ButtonState;
	BaseType_t res;
	res=xQueueReceive(CursorstickQueue,&ButtonState,BlockTime);
     43c:	ac 01       	movw	r20, r24
     43e:	be 01       	movw	r22, r28
     440:	6f 5f       	subi	r22, 0xFF	; 255
     442:	7f 4f       	sbci	r23, 0xFF	; 255
     444:	80 91 f2 20 	lds	r24, 0x20F2	; 0x8020f2 <CursorstickQueue>
     448:	90 91 f3 20 	lds	r25, 0x20F3	; 0x8020f3 <CursorstickQueue+0x1>
     44c:	0e 94 09 0f 	call	0x1e12	; 0x1e12 <xQueueReceive>
	if (res==pdTRUE) return ButtonState;
     450:	81 30       	cpi	r24, 0x01	; 1
     452:	29 f0       	breq	.+10     	; 0x45e <DriverCursorStickGetFifo+0x2c>
	else return 0;
     454:	80 e0       	ldi	r24, 0x00	; 0

}
     456:	0f 90       	pop	r0
     458:	df 91       	pop	r29
     45a:	cf 91       	pop	r28
     45c:	08 95       	ret
uint8_t DriverCursorStickGetFifo(TickType_t BlockTime)
{
	uint8_t ButtonState;
	BaseType_t res;
	res=xQueueReceive(CursorstickQueue,&ButtonState,BlockTime);
	if (res==pdTRUE) return ButtonState;
     45e:	89 81       	ldd	r24, Y+1	; 0x01
	else return 0;

}
     460:	0f 90       	pop	r0
     462:	df 91       	pop	r29
     464:	cf 91       	pop	r28
     466:	08 95       	ret

00000468 <__vector_34>:

ISR (PORTB_INT0_vect)
{
     468:	1f 92       	push	r1
     46a:	0f 92       	push	r0
     46c:	0f b6       	in	r0, 0x3f	; 63
     46e:	0f 92       	push	r0
     470:	11 24       	eor	r1, r1
     472:	0b b6       	in	r0, 0x3b	; 59
     474:	0f 92       	push	r0
     476:	cf 92       	push	r12
     478:	df 92       	push	r13
     47a:	ef 92       	push	r14
     47c:	ff 92       	push	r15
     47e:	0f 93       	push	r16
     480:	1f 93       	push	r17
     482:	2f 93       	push	r18
     484:	3f 93       	push	r19
     486:	4f 93       	push	r20
     488:	5f 93       	push	r21
     48a:	6f 93       	push	r22
     48c:	7f 93       	push	r23
     48e:	8f 93       	push	r24
     490:	9f 93       	push	r25
     492:	af 93       	push	r26
     494:	bf 93       	push	r27
     496:	ef 93       	push	r30
     498:	ff 93       	push	r31
     49a:	cf 93       	push	r28
     49c:	df 93       	push	r29
     49e:	1f 92       	push	r1
     4a0:	1f 92       	push	r1
     4a2:	cd b7       	in	r28, 0x3d	; 61
     4a4:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastIntTime=0;
	uint32_t CurTime;
	uint8_t ButtonState;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     4a6:	19 82       	std	Y+1, r1	; 0x01
	
	CurTime=portGET_RUN_TIME_COUNTER_VALUE();
     4a8:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     4ac:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     4b0:	c0 90 20 22 	lds	r12, 0x2220	; 0x802220 <StatsTimer>
     4b4:	d0 90 21 22 	lds	r13, 0x2221	; 0x802221 <StatsTimer+0x1>
     4b8:	e0 90 22 22 	lds	r14, 0x2222	; 0x802222 <StatsTimer+0x2>
     4bc:	f0 90 23 22 	lds	r15, 0x2223	; 0x802223 <StatsTimer+0x3>
     4c0:	c8 0e       	add	r12, r24
     4c2:	d9 1e       	adc	r13, r25
     4c4:	e1 1c       	adc	r14, r1
     4c6:	f1 1c       	adc	r15, r1
	ButtonState=DriverCursorstickGet();
     4c8:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DriverCursorstickGet>
     4cc:	8a 83       	std	Y+2, r24	; 0x02
	
	if ((CurTime-LastIntTime)>CURSOR_MIN_INTERVAL) //debounce
     4ce:	40 91 ee 20 	lds	r20, 0x20EE	; 0x8020ee <__data_end>
     4d2:	50 91 ef 20 	lds	r21, 0x20EF	; 0x8020ef <__data_end+0x1>
     4d6:	60 91 f0 20 	lds	r22, 0x20F0	; 0x8020f0 <__data_end+0x2>
     4da:	70 91 f1 20 	lds	r23, 0x20F1	; 0x8020f1 <__data_end+0x3>
     4de:	97 01       	movw	r18, r14
     4e0:	86 01       	movw	r16, r12
     4e2:	04 1b       	sub	r16, r20
     4e4:	15 0b       	sbc	r17, r21
     4e6:	26 0b       	sbc	r18, r22
     4e8:	37 0b       	sbc	r19, r23
     4ea:	b9 01       	movw	r22, r18
     4ec:	a8 01       	movw	r20, r16
     4ee:	41 30       	cpi	r20, 0x01	; 1
     4f0:	58 4a       	sbci	r21, 0xA8	; 168
     4f2:	61 46       	sbci	r22, 0x61	; 97
     4f4:	71 05       	cpc	r23, r1
     4f6:	10 f0       	brcs	.+4      	; 0x4fc <__vector_34+0x94>
		if (ButtonState>0) 
     4f8:	81 11       	cpse	r24, r1
     4fa:	21 c0       	rjmp	.+66     	; 0x53e <__vector_34+0xd6>
		{
			xQueueSendToBackFromISR(CursorstickQueue,&ButtonState,&xHigherPriorityTaskWoken);
			LastIntTime=CurTime;
		}
		
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     4fc:	89 81       	ldd	r24, Y+1	; 0x01
     4fe:	81 11       	cpse	r24, r1
     500:	0e 94 3f 0b 	call	0x167e	; 0x167e <vPortYieldISR>
     504:	0f 90       	pop	r0
     506:	0f 90       	pop	r0
     508:	df 91       	pop	r29
     50a:	cf 91       	pop	r28
     50c:	ff 91       	pop	r31
     50e:	ef 91       	pop	r30
     510:	bf 91       	pop	r27
     512:	af 91       	pop	r26
     514:	9f 91       	pop	r25
     516:	8f 91       	pop	r24
     518:	7f 91       	pop	r23
     51a:	6f 91       	pop	r22
     51c:	5f 91       	pop	r21
     51e:	4f 91       	pop	r20
     520:	3f 91       	pop	r19
     522:	2f 91       	pop	r18
     524:	1f 91       	pop	r17
     526:	0f 91       	pop	r16
     528:	ff 90       	pop	r15
     52a:	ef 90       	pop	r14
     52c:	df 90       	pop	r13
     52e:	cf 90       	pop	r12
     530:	0f 90       	pop	r0
     532:	0b be       	out	0x3b, r0	; 59
     534:	0f 90       	pop	r0
     536:	0f be       	out	0x3f, r0	; 63
     538:	0f 90       	pop	r0
     53a:	1f 90       	pop	r1
     53c:	18 95       	reti
	ButtonState=DriverCursorstickGet();
	
	if ((CurTime-LastIntTime)>CURSOR_MIN_INTERVAL) //debounce
		if (ButtonState>0) 
		{
			xQueueSendToBackFromISR(CursorstickQueue,&ButtonState,&xHigherPriorityTaskWoken);
     53e:	20 e0       	ldi	r18, 0x00	; 0
     540:	ae 01       	movw	r20, r28
     542:	4f 5f       	subi	r20, 0xFF	; 255
     544:	5f 4f       	sbci	r21, 0xFF	; 255
     546:	be 01       	movw	r22, r28
     548:	6e 5f       	subi	r22, 0xFE	; 254
     54a:	7f 4f       	sbci	r23, 0xFF	; 255
     54c:	80 91 f2 20 	lds	r24, 0x20F2	; 0x8020f2 <CursorstickQueue>
     550:	90 91 f3 20 	lds	r25, 0x20F3	; 0x8020f3 <CursorstickQueue+0x1>
     554:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
			LastIntTime=CurTime;
     558:	c0 92 ee 20 	sts	0x20EE, r12	; 0x8020ee <__data_end>
     55c:	d0 92 ef 20 	sts	0x20EF, r13	; 0x8020ef <__data_end+0x1>
     560:	e0 92 f0 20 	sts	0x20F0, r14	; 0x8020f0 <__data_end+0x2>
     564:	f0 92 f1 20 	sts	0x20F1, r15	; 0x8020f1 <__data_end+0x3>
     568:	c9 cf       	rjmp	.-110    	; 0x4fc <__vector_34+0x94>

0000056a <DbgPrint>:
#include "DriverDbgUSART.h"


void DbgPrint(char *Text)
{
     56a:	dc 01       	movw	r26, r24
}

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
     56c:	10 92 f7 20 	sts	0x20F7, r1	; 0x8020f7 <i.3624>
     570:	10 92 f8 20 	sts	0x20F8, r1	; 0x8020f8 <i.3624+0x1>
	while (*Text!=0 && (i<n || n==0))
     574:	9c 91       	ld	r25, X
     576:	99 23       	and	r25, r25
     578:	b1 f0       	breq	.+44     	; 0x5a6 <DbgPrint+0x3c>
     57a:	fd 01       	movw	r30, r26
     57c:	31 96       	adiw	r30, 0x01	; 1
	{
		USART.DATA = *Text;
		while (!(USART.STATUS & 0b01000000));
		USART.STATUS=0b01000000;
     57e:	80 e4       	ldi	r24, 0x40	; 64
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
	{
		USART.DATA = *Text;
     580:	90 93 a0 0a 	sts	0x0AA0, r25	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
		while (!(USART.STATUS & 0b01000000));
     584:	90 91 a1 0a 	lds	r25, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     588:	96 ff       	sbrs	r25, 6
     58a:	fc cf       	rjmp	.-8      	; 0x584 <DbgPrint+0x1a>
		USART.STATUS=0b01000000;
     58c:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     590:	9f 01       	movw	r18, r30
     592:	2a 1b       	sub	r18, r26
     594:	3b 0b       	sbc	r19, r27

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     596:	91 91       	ld	r25, Z+
     598:	91 11       	cpse	r25, r1
     59a:	f2 cf       	rjmp	.-28     	; 0x580 <DbgPrint+0x16>
     59c:	20 93 f7 20 	sts	0x20F7, r18	; 0x8020f7 <i.3624>
     5a0:	30 93 f8 20 	sts	0x20F8, r19	; 0x8020f8 <i.3624+0x1>
     5a4:	08 95       	ret
     5a6:	08 95       	ret

000005a8 <DbgPrintn>:
{
	DbgPrintn(Text,0);	
}

void DbgPrintn(char *Text,int n)
{
     5a8:	fc 01       	movw	r30, r24
	static int i;
	i=0;
     5aa:	10 92 f7 20 	sts	0x20F7, r1	; 0x8020f7 <i.3624>
     5ae:	10 92 f8 20 	sts	0x20F8, r1	; 0x8020f8 <i.3624+0x1>
	while (*Text!=0 && (i<n || n==0))
     5b2:	90 81       	ld	r25, Z
     5b4:	99 23       	and	r25, r25
     5b6:	e1 f0       	breq	.+56     	; 0x5f0 <DbgPrintn+0x48>
     5b8:	31 96       	adiw	r30, 0x01	; 1
     5ba:	20 e0       	ldi	r18, 0x00	; 0
     5bc:	30 e0       	ldi	r19, 0x00	; 0
	{
		USART.DATA = *Text;
		while (!(USART.STATUS & 0b01000000));
		USART.STATUS=0b01000000;
     5be:	80 e4       	ldi	r24, 0x40	; 64

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     5c0:	26 17       	cp	r18, r22
     5c2:	37 07       	cpc	r19, r23
     5c4:	1c f0       	brlt	.+6      	; 0x5cc <DbgPrintn+0x24>
     5c6:	61 15       	cp	r22, r1
     5c8:	71 05       	cpc	r23, r1
     5ca:	69 f4       	brne	.+26     	; 0x5e6 <DbgPrintn+0x3e>
	{
		USART.DATA = *Text;
     5cc:	90 93 a0 0a 	sts	0x0AA0, r25	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
		while (!(USART.STATUS & 0b01000000));
     5d0:	90 91 a1 0a 	lds	r25, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     5d4:	96 ff       	sbrs	r25, 6
     5d6:	fc cf       	rjmp	.-8      	; 0x5d0 <DbgPrintn+0x28>
		USART.STATUS=0b01000000;
     5d8:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
		Text++;
		i++;
     5dc:	2f 5f       	subi	r18, 0xFF	; 255
     5de:	3f 4f       	sbci	r19, 0xFF	; 255

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     5e0:	91 91       	ld	r25, Z+
     5e2:	91 11       	cpse	r25, r1
     5e4:	ed cf       	rjmp	.-38     	; 0x5c0 <DbgPrintn+0x18>
     5e6:	20 93 f7 20 	sts	0x20F7, r18	; 0x8020f7 <i.3624>
     5ea:	30 93 f8 20 	sts	0x20F8, r19	; 0x8020f8 <i.3624+0x1>
     5ee:	08 95       	ret
     5f0:	08 95       	ret

000005f2 <DbgPrintInt>:
		i++;
	}
}

void DbgPrintInt(uint16_t Data)
{
     5f2:	cf 92       	push	r12
     5f4:	df 92       	push	r13
     5f6:	ef 92       	push	r14
     5f8:	ff 92       	push	r15
     5fa:	0f 93       	push	r16
     5fc:	1f 93       	push	r17
     5fe:	cf 93       	push	r28
     600:	df 93       	push	r29
     602:	7c 01       	movw	r14, r24
	//Use statics to minimize stack usage
	static int i;
	static uint8_t pf;
	
	i=10000;
     604:	80 e1       	ldi	r24, 0x10	; 16
     606:	97 e2       	ldi	r25, 0x27	; 39
     608:	80 93 f5 20 	sts	0x20F5, r24	; 0x8020f5 <i.3634>
     60c:	90 93 f6 20 	sts	0x20F6, r25	; 0x8020f6 <i.3634+0x1>
	pf=0;
     610:	10 92 f4 20 	sts	0x20F4, r1	; 0x8020f4 <pf.3635>
     614:	c5 e0       	ldi	r28, 0x05	; 5
     616:	d0 e0       	ldi	r29, 0x00	; 0
     618:	c1 2c       	mov	r12, r1
     61a:	e0 e1       	ldi	r30, 0x10	; 16
     61c:	f7 e2       	ldi	r31, 0x27	; 39
	{
		if (((Data/i)%10)!=0 || pf) //Trim leading 0's
		{
			USART.DATA = '0'+ ((Data/i)%10);
			while (!(USART.STATUS & 0b01000000));
			USART.STATUS=0b01000000;
     61e:	a0 e4       	ldi	r26, 0x40	; 64
     620:	da 2e       	mov	r13, r26
			pf=1;		
		}
		i/=10;
     622:	0a e0       	ldi	r16, 0x0A	; 10
     624:	10 e0       	ldi	r17, 0x00	; 0
	
	i=10000;
	pf=0;
	while (i>0)
	{
		if (((Data/i)%10)!=0 || pf) //Trim leading 0's
     626:	c7 01       	movw	r24, r14
     628:	bf 01       	movw	r22, r30
     62a:	0e 94 71 23 	call	0x46e2	; 0x46e2 <__udivmodhi4>
     62e:	ab 01       	movw	r20, r22
     630:	9b 01       	movw	r18, r22
     632:	ad ec       	ldi	r26, 0xCD	; 205
     634:	bc ec       	ldi	r27, 0xCC	; 204
     636:	0e 94 99 23 	call	0x4732	; 0x4732 <__umulhisi3>
     63a:	96 95       	lsr	r25
     63c:	87 95       	ror	r24
     63e:	96 95       	lsr	r25
     640:	87 95       	ror	r24
     642:	96 95       	lsr	r25
     644:	87 95       	ror	r24
     646:	9c 01       	movw	r18, r24
     648:	22 0f       	add	r18, r18
     64a:	33 1f       	adc	r19, r19
     64c:	88 0f       	add	r24, r24
     64e:	99 1f       	adc	r25, r25
     650:	88 0f       	add	r24, r24
     652:	99 1f       	adc	r25, r25
     654:	88 0f       	add	r24, r24
     656:	99 1f       	adc	r25, r25
     658:	82 0f       	add	r24, r18
     65a:	93 1f       	adc	r25, r19
     65c:	9a 01       	movw	r18, r20
     65e:	28 1b       	sub	r18, r24
     660:	39 0b       	sbc	r19, r25
     662:	c9 01       	movw	r24, r18
     664:	00 97       	sbiw	r24, 0x00	; 0
     666:	11 f4       	brne	.+4      	; 0x66c <DbgPrintInt+0x7a>
     668:	cc 20       	and	r12, r12
     66a:	59 f0       	breq	.+22     	; 0x682 <DbgPrintInt+0x90>
		{
			USART.DATA = '0'+ ((Data/i)%10);
     66c:	80 5d       	subi	r24, 0xD0	; 208
     66e:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
			while (!(USART.STATUS & 0b01000000));
     672:	80 91 a1 0a 	lds	r24, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     676:	86 ff       	sbrs	r24, 6
     678:	fc cf       	rjmp	.-8      	; 0x672 <DbgPrintInt+0x80>
			USART.STATUS=0b01000000;
     67a:	d0 92 a1 0a 	sts	0x0AA1, r13	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
			pf=1;		
     67e:	cc 24       	eor	r12, r12
     680:	c3 94       	inc	r12
		}
		i/=10;
     682:	cf 01       	movw	r24, r30
     684:	b8 01       	movw	r22, r16
     686:	0e 94 85 23 	call	0x470a	; 0x470a <__divmodhi4>
     68a:	fb 01       	movw	r30, r22
     68c:	21 97       	sbiw	r28, 0x01	; 1
	static int i;
	static uint8_t pf;
	
	i=10000;
	pf=0;
	while (i>0)
     68e:	59 f6       	brne	.-106    	; 0x626 <DbgPrintInt+0x34>
     690:	c0 92 f4 20 	sts	0x20F4, r12	; 0x8020f4 <pf.3635>
     694:	60 93 f5 20 	sts	0x20F5, r22	; 0x8020f5 <i.3634>
     698:	70 93 f6 20 	sts	0x20F6, r23	; 0x8020f6 <i.3634+0x1>
			USART.STATUS=0b01000000;
			pf=1;		
		}
		i/=10;
	}
}
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	1f 91       	pop	r17
     6a2:	0f 91       	pop	r16
     6a4:	ff 90       	pop	r15
     6a6:	ef 90       	pop	r14
     6a8:	df 90       	pop	r13
     6aa:	cf 90       	pop	r12
     6ac:	08 95       	ret

000006ae <DriverMotorInit>:
{
	EncoderEventStruct Event={0,NONE};
	int res;
	res=xQueueReceive(EncoderEventQueue,&Event,0);
	return Event;
}
     6ae:	e0 ea       	ldi	r30, 0xA0	; 160
     6b0:	f6 e0       	ldi	r31, 0x06	; 6
     6b2:	8f e1       	ldi	r24, 0x1F	; 31
     6b4:	81 83       	std	Z+1, r24	; 0x01
     6b6:	80 e4       	ldi	r24, 0x40	; 64
     6b8:	84 8b       	std	Z+20, r24	; 0x14
     6ba:	20 e1       	ldi	r18, 0x10	; 16
     6bc:	25 83       	std	Z+5, r18	; 0x05
     6be:	e0 e0       	ldi	r30, 0x00	; 0
     6c0:	fb e0       	ldi	r31, 0x0B	; 11
     6c2:	91 e0       	ldi	r25, 0x01	; 1
     6c4:	90 83       	st	Z, r25
     6c6:	93 ef       	ldi	r25, 0xF3	; 243
     6c8:	91 83       	std	Z+1, r25	; 0x01
     6ca:	40 e0       	ldi	r20, 0x00	; 0
     6cc:	50 e1       	ldi	r21, 0x10	; 16
     6ce:	46 a3       	std	Z+38, r20	; 0x26
     6d0:	57 a3       	std	Z+39, r21	; 0x27
     6d2:	e0 e4       	ldi	r30, 0x40	; 64
     6d4:	f6 e0       	ldi	r31, 0x06	; 6
     6d6:	90 ec       	ldi	r25, 0xC0	; 192
     6d8:	92 83       	std	Z+2, r25	; 0x02
     6da:	86 8b       	std	Z+22, r24	; 0x16
     6dc:	87 8b       	std	Z+23, r24	; 0x17
     6de:	82 87       	std	Z+10, r24	; 0x0a
     6e0:	90 e8       	ldi	r25, 0x80	; 128
     6e2:	93 87       	std	Z+11, r25	; 0x0b
     6e4:	95 e0       	ldi	r25, 0x05	; 5
     6e6:	91 87       	std	Z+9, r25	; 0x09
     6e8:	e0 e8       	ldi	r30, 0x80	; 128
     6ea:	f6 e0       	ldi	r31, 0x06	; 6
     6ec:	30 e3       	ldi	r19, 0x30	; 48
     6ee:	32 83       	std	Z+2, r19	; 0x02
     6f0:	84 8b       	std	Z+20, r24	; 0x14
     6f2:	85 8b       	std	Z+21, r24	; 0x15
     6f4:	22 87       	std	Z+10, r18	; 0x0a
     6f6:	80 e2       	ldi	r24, 0x20	; 32
     6f8:	83 87       	std	Z+11, r24	; 0x0b
     6fa:	91 87       	std	Z+9, r25	; 0x09
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	65 e0       	ldi	r22, 0x05	; 5
     700:	84 e1       	ldi	r24, 0x14	; 20
     702:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericCreate>
     706:	80 93 1a 22 	sts	0x221A, r24	; 0x80221a <EncoderEventQueue>
     70a:	90 93 1b 22 	sts	0x221B, r25	; 0x80221b <EncoderEventQueue+0x1>
     70e:	08 95       	ret

00000710 <DriverMotorSet>:
     710:	20 e1       	ldi	r18, 0x10	; 16
     712:	00 97       	sbiw	r24, 0x00	; 0
     714:	69 f5       	brne	.+90     	; 0x770 <DriverMotorSet+0x60>
     716:	61 15       	cp	r22, r1
     718:	71 05       	cpc	r23, r1
     71a:	09 f4       	brne	.+2      	; 0x71e <DriverMotorSet+0xe>
     71c:	57 c0       	rjmp	.+174    	; 0x7cc <DriverMotorSet+0xbc>
     71e:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
     722:	81 30       	cpi	r24, 0x01	; 1
     724:	20 ef       	ldi	r18, 0xF0	; 240
     726:	92 07       	cpc	r25, r18
     728:	0c f4       	brge	.+2      	; 0x72c <DriverMotorSet+0x1c>
     72a:	57 c0       	rjmp	.+174    	; 0x7da <DriverMotorSet+0xca>
     72c:	91 95       	neg	r25
     72e:	81 95       	neg	r24
     730:	91 09       	sbc	r25, r1
     732:	80 93 28 0b 	sts	0x0B28, r24	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     736:	90 93 29 0b 	sts	0x0B29, r25	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
     73a:	10 92 2a 0b 	sts	0x0B2A, r1	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     73e:	10 92 2b 0b 	sts	0x0B2B, r1	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
     742:	71 95       	neg	r23
     744:	61 95       	neg	r22
     746:	71 09       	sbc	r23, r1
     748:	16 16       	cp	r1, r22
     74a:	17 06       	cpc	r1, r23
     74c:	44 f1       	brlt	.+80     	; 0x79e <DriverMotorSet+0x8e>
     74e:	61 30       	cpi	r22, 0x01	; 1
     750:	20 ef       	ldi	r18, 0xF0	; 240
     752:	72 07       	cpc	r23, r18
     754:	0c f4       	brge	.+2      	; 0x758 <DriverMotorSet+0x48>
     756:	44 c0       	rjmp	.+136    	; 0x7e0 <DriverMotorSet+0xd0>
     758:	71 95       	neg	r23
     75a:	61 95       	neg	r22
     75c:	71 09       	sbc	r23, r1
     75e:	60 93 2c 0b 	sts	0x0B2C, r22	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     762:	70 93 2d 0b 	sts	0x0B2D, r23	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
     766:	10 92 2e 0b 	sts	0x0B2E, r1	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     76a:	10 92 2f 0b 	sts	0x0B2F, r1	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     76e:	08 95       	ret
     770:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
     774:	18 16       	cp	r1, r24
     776:	19 06       	cpc	r1, r25
     778:	a4 f6       	brge	.-88     	; 0x722 <DriverMotorSet+0x12>
     77a:	10 92 28 0b 	sts	0x0B28, r1	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     77e:	10 92 29 0b 	sts	0x0B29, r1	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
     782:	81 15       	cp	r24, r1
     784:	20 e1       	ldi	r18, 0x10	; 16
     786:	92 07       	cpc	r25, r18
     788:	f4 f4       	brge	.+60     	; 0x7c6 <DriverMotorSet+0xb6>
     78a:	80 93 2a 0b 	sts	0x0B2A, r24	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     78e:	90 93 2b 0b 	sts	0x0B2B, r25	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
     792:	71 95       	neg	r23
     794:	61 95       	neg	r22
     796:	71 09       	sbc	r23, r1
     798:	16 16       	cp	r1, r22
     79a:	17 06       	cpc	r1, r23
     79c:	c4 f6       	brge	.-80     	; 0x74e <DriverMotorSet+0x3e>
     79e:	10 92 2c 0b 	sts	0x0B2C, r1	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     7a2:	10 92 2d 0b 	sts	0x0B2D, r1	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
     7a6:	61 15       	cp	r22, r1
     7a8:	80 e1       	ldi	r24, 0x10	; 16
     7aa:	78 07       	cpc	r23, r24
     7ac:	2c f4       	brge	.+10     	; 0x7b8 <DriverMotorSet+0xa8>
     7ae:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     7b2:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     7b6:	08 95       	ret
     7b8:	6f ef       	ldi	r22, 0xFF	; 255
     7ba:	7f e0       	ldi	r23, 0x0F	; 15
     7bc:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     7c0:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     7c4:	08 95       	ret
     7c6:	8f ef       	ldi	r24, 0xFF	; 255
     7c8:	9f e0       	ldi	r25, 0x0F	; 15
     7ca:	df cf       	rjmp	.-66     	; 0x78a <DriverMotorSet+0x7a>
     7cc:	20 93 a5 06 	sts	0x06A5, r18	; 0x8006a5 <__TEXT_REGION_LENGTH__+0x7006a5>
     7d0:	81 30       	cpi	r24, 0x01	; 1
     7d2:	20 ef       	ldi	r18, 0xF0	; 240
     7d4:	92 07       	cpc	r25, r18
     7d6:	0c f0       	brlt	.+2      	; 0x7da <DriverMotorSet+0xca>
     7d8:	a9 cf       	rjmp	.-174    	; 0x72c <DriverMotorSet+0x1c>
     7da:	81 e0       	ldi	r24, 0x01	; 1
     7dc:	90 ef       	ldi	r25, 0xF0	; 240
     7de:	a6 cf       	rjmp	.-180    	; 0x72c <DriverMotorSet+0x1c>
     7e0:	61 e0       	ldi	r22, 0x01	; 1
     7e2:	70 ef       	ldi	r23, 0xF0	; 240
     7e4:	b9 cf       	rjmp	.-142    	; 0x758 <DriverMotorSet+0x48>

000007e6 <DriverMotorGetEncoder>:
     7e6:	0f b6       	in	r0, 0x3f	; 63
     7e8:	f8 94       	cli
     7ea:	0f 92       	push	r0
     7ec:	40 91 16 22 	lds	r20, 0x2216	; 0x802216 <Cnt1>
     7f0:	50 91 17 22 	lds	r21, 0x2217	; 0x802217 <Cnt1+0x1>
     7f4:	20 91 18 22 	lds	r18, 0x2218	; 0x802218 <Cnt2>
     7f8:	30 91 19 22 	lds	r19, 0x2219	; 0x802219 <Cnt2+0x1>
     7fc:	0f 90       	pop	r0
     7fe:	0f be       	out	0x3f, r0	; 63
     800:	ba 01       	movw	r22, r20
     802:	c9 01       	movw	r24, r18
     804:	08 95       	ret

00000806 <__vector_2>:

//Encoder 1 ISR's
ISR (PORTC_INT0_vect)
{	
     806:	1f 92       	push	r1
     808:	0f 92       	push	r0
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	0f 92       	push	r0
     80e:	11 24       	eor	r1, r1
     810:	0b b6       	in	r0, 0x3b	; 59
     812:	0f 92       	push	r0
     814:	1f 93       	push	r17
     816:	2f 93       	push	r18
     818:	3f 93       	push	r19
     81a:	4f 93       	push	r20
     81c:	5f 93       	push	r21
     81e:	6f 93       	push	r22
     820:	7f 93       	push	r23
     822:	8f 93       	push	r24
     824:	9f 93       	push	r25
     826:	af 93       	push	r26
     828:	bf 93       	push	r27
     82a:	ef 93       	push	r30
     82c:	ff 93       	push	r31
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	00 d0       	rcall	.+0      	; 0x834 <__vector_2+0x2e>
     834:	00 d0       	rcall	.+0      	; 0x836 <__vector_2+0x30>
     836:	cd b7       	in	r28, 0x3d	; 61
     838:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     83a:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
     83c:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     840:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     844:	80 91 20 22 	lds	r24, 0x2220	; 0x802220 <StatsTimer>
     848:	90 91 21 22 	lds	r25, 0x2221	; 0x802221 <StatsTimer+0x1>
     84c:	a0 91 22 22 	lds	r26, 0x2222	; 0x802222 <StatsTimer+0x2>
     850:	b0 91 23 22 	lds	r27, 0x2223	; 0x802223 <StatsTimer+0x3>
     854:	82 0f       	add	r24, r18
     856:	93 1f       	adc	r25, r19
     858:	a1 1d       	adc	r26, r1
     85a:	b1 1d       	adc	r27, r1
     85c:	89 83       	std	Y+1, r24	; 0x01
     85e:	9a 83       	std	Y+2, r25	; 0x02
     860:	ab 83       	std	Y+3, r26	; 0x03
     862:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif

	Data=PORTC.IN;
     864:	80 91 48 06 	lds	r24, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>
	l0=Data & (1<<6);
	l1=Data & (1<<7);
     868:	18 2f       	mov	r17, r24
     86a:	10 78       	andi	r17, 0x80	; 128
		
	//Process events
	if (l0) 
     86c:	86 ff       	sbrs	r24, 6
     86e:	37 c0       	rjmp	.+110    	; 0x8de <__vector_2+0xd8>
		Event.Event=RISING_1A;
     870:	81 e0       	ldi	r24, 0x01	; 1
     872:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_1A;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     874:	20 e0       	ldi	r18, 0x00	; 0
     876:	ae 01       	movw	r20, r28
     878:	4a 5f       	subi	r20, 0xFA	; 250
     87a:	5f 4f       	sbci	r21, 0xFF	; 255
     87c:	be 01       	movw	r22, r28
     87e:	6f 5f       	subi	r22, 0xFF	; 255
     880:	7f 4f       	sbci	r23, 0xFF	; 255
     882:	80 91 1a 22 	lds	r24, 0x221A	; 0x80221a <EncoderEventQueue>
     886:	90 91 1b 22 	lds	r25, 0x221B	; 0x80221b <EncoderEventQueue+0x1>
     88a:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt1--; //Rising edge on Line0, Line1 low
     88e:	11 23       	and	r17, r17
     890:	b9 f1       	breq	.+110    	; 0x900 <__vector_2+0xfa>
	if ( l0 &&  l1) Cnt1++; //Rising edge on Line0, Line1 high	
	if (!l0 &&  l1) Cnt1--; //Falling edge on Line0, Line1 high
	if (!l0 && !l1) Cnt1++;//Falling edge on Line1, Line1 low
     892:	80 91 16 22 	lds	r24, 0x2216	; 0x802216 <Cnt1>
     896:	90 91 17 22 	lds	r25, 0x2217	; 0x802217 <Cnt1+0x1>
     89a:	01 96       	adiw	r24, 0x01	; 1
     89c:	80 93 16 22 	sts	0x2216, r24	; 0x802216 <Cnt1>
     8a0:	90 93 17 22 	sts	0x2217, r25	; 0x802217 <Cnt1+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     8a4:	8e 81       	ldd	r24, Y+6	; 0x06
     8a6:	81 11       	cpse	r24, r1
     8a8:	0e 94 3f 0b 	call	0x167e	; 0x167e <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
     8ac:	26 96       	adiw	r28, 0x06	; 6
     8ae:	cd bf       	out	0x3d, r28	; 61
     8b0:	de bf       	out	0x3e, r29	; 62
     8b2:	df 91       	pop	r29
     8b4:	cf 91       	pop	r28
     8b6:	ff 91       	pop	r31
     8b8:	ef 91       	pop	r30
     8ba:	bf 91       	pop	r27
     8bc:	af 91       	pop	r26
     8be:	9f 91       	pop	r25
     8c0:	8f 91       	pop	r24
     8c2:	7f 91       	pop	r23
     8c4:	6f 91       	pop	r22
     8c6:	5f 91       	pop	r21
     8c8:	4f 91       	pop	r20
     8ca:	3f 91       	pop	r19
     8cc:	2f 91       	pop	r18
     8ce:	1f 91       	pop	r17
     8d0:	0f 90       	pop	r0
     8d2:	0b be       	out	0x3b, r0	; 59
     8d4:	0f 90       	pop	r0
     8d6:	0f be       	out	0x3f, r0	; 63
     8d8:	0f 90       	pop	r0
     8da:	1f 90       	pop	r1
     8dc:	18 95       	reti
		
	//Process events
	if (l0) 
		Event.Event=RISING_1A;
	else
		Event.Event=FALLING_1A;
     8de:	85 e0       	ldi	r24, 0x05	; 5
     8e0:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     8e2:	20 e0       	ldi	r18, 0x00	; 0
     8e4:	ae 01       	movw	r20, r28
     8e6:	4a 5f       	subi	r20, 0xFA	; 250
     8e8:	5f 4f       	sbci	r21, 0xFF	; 255
     8ea:	be 01       	movw	r22, r28
     8ec:	6f 5f       	subi	r22, 0xFF	; 255
     8ee:	7f 4f       	sbci	r23, 0xFF	; 255
     8f0:	80 91 1a 22 	lds	r24, 0x221A	; 0x80221a <EncoderEventQueue>
     8f4:	90 91 1b 22 	lds	r25, 0x221B	; 0x80221b <EncoderEventQueue+0x1>
     8f8:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt1--; //Rising edge on Line0, Line1 low
	if ( l0 &&  l1) Cnt1++; //Rising edge on Line0, Line1 high	
	if (!l0 &&  l1) Cnt1--; //Falling edge on Line0, Line1 high
     8fc:	11 23       	and	r17, r17
     8fe:	49 f2       	breq	.-110    	; 0x892 <__vector_2+0x8c>
     900:	80 91 16 22 	lds	r24, 0x2216	; 0x802216 <Cnt1>
     904:	90 91 17 22 	lds	r25, 0x2217	; 0x802217 <Cnt1+0x1>
     908:	01 97       	sbiw	r24, 0x01	; 1
     90a:	80 93 16 22 	sts	0x2216, r24	; 0x802216 <Cnt1>
     90e:	90 93 17 22 	sts	0x2217, r25	; 0x802217 <Cnt1+0x1>
     912:	c8 cf       	rjmp	.-112    	; 0x8a4 <__vector_2+0x9e>

00000914 <__vector_3>:
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	LastTriggerTime=Event.Time;
}

ISR (PORTC_INT1_vect)
{
     914:	1f 92       	push	r1
     916:	0f 92       	push	r0
     918:	0f b6       	in	r0, 0x3f	; 63
     91a:	0f 92       	push	r0
     91c:	11 24       	eor	r1, r1
     91e:	0b b6       	in	r0, 0x3b	; 59
     920:	0f 92       	push	r0
     922:	1f 93       	push	r17
     924:	2f 93       	push	r18
     926:	3f 93       	push	r19
     928:	4f 93       	push	r20
     92a:	5f 93       	push	r21
     92c:	6f 93       	push	r22
     92e:	7f 93       	push	r23
     930:	8f 93       	push	r24
     932:	9f 93       	push	r25
     934:	af 93       	push	r26
     936:	bf 93       	push	r27
     938:	ef 93       	push	r30
     93a:	ff 93       	push	r31
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	00 d0       	rcall	.+0      	; 0x942 <__vector_3+0x2e>
     942:	00 d0       	rcall	.+0      	; 0x944 <__vector_3+0x30>
     944:	cd b7       	in	r28, 0x3d	; 61
     946:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     948:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
     94a:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     94e:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     952:	80 91 20 22 	lds	r24, 0x2220	; 0x802220 <StatsTimer>
     956:	90 91 21 22 	lds	r25, 0x2221	; 0x802221 <StatsTimer+0x1>
     95a:	a0 91 22 22 	lds	r26, 0x2222	; 0x802222 <StatsTimer+0x2>
     95e:	b0 91 23 22 	lds	r27, 0x2223	; 0x802223 <StatsTimer+0x3>
     962:	82 0f       	add	r24, r18
     964:	93 1f       	adc	r25, r19
     966:	a1 1d       	adc	r26, r1
     968:	b1 1d       	adc	r27, r1
     96a:	89 83       	std	Y+1, r24	; 0x01
     96c:	9a 83       	std	Y+2, r25	; 0x02
     96e:	ab 83       	std	Y+3, r26	; 0x03
     970:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTC.IN;
     972:	80 91 48 06 	lds	r24, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>
	l0=Data & (1<<6);
     976:	18 2f       	mov	r17, r24
     978:	10 74       	andi	r17, 0x40	; 64
	l1=Data & (1<<7);
	
	//Process events
	if (l1)
     97a:	87 ff       	sbrs	r24, 7
     97c:	37 c0       	rjmp	.+110    	; 0x9ec <__vector_3+0xd8>
		Event.Event=RISING_1B;
     97e:	82 e0       	ldi	r24, 0x02	; 2
     980:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_1B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     982:	20 e0       	ldi	r18, 0x00	; 0
     984:	ae 01       	movw	r20, r28
     986:	4a 5f       	subi	r20, 0xFA	; 250
     988:	5f 4f       	sbci	r21, 0xFF	; 255
     98a:	be 01       	movw	r22, r28
     98c:	6f 5f       	subi	r22, 0xFF	; 255
     98e:	7f 4f       	sbci	r23, 0xFF	; 255
     990:	80 91 1a 22 	lds	r24, 0x221A	; 0x80221a <EncoderEventQueue>
     994:	90 91 1b 22 	lds	r25, 0x221B	; 0x80221b <EncoderEventQueue+0x1>
     998:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt1++;//Rising edge on Line1, Line0 low
     99c:	11 23       	and	r17, r17
     99e:	b9 f1       	breq	.+110    	; 0xa0e <__vector_3+0xfa>
	if ( l1 &&  l0) Cnt1--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt1++;//Falling edge on Line1, Line0 high
	if (!l1 && !l0) Cnt1--;//Falling edge on Line1, Line0 low
     9a0:	80 91 16 22 	lds	r24, 0x2216	; 0x802216 <Cnt1>
     9a4:	90 91 17 22 	lds	r25, 0x2217	; 0x802217 <Cnt1+0x1>
     9a8:	01 97       	sbiw	r24, 0x01	; 1
     9aa:	80 93 16 22 	sts	0x2216, r24	; 0x802216 <Cnt1>
     9ae:	90 93 17 22 	sts	0x2217, r25	; 0x802217 <Cnt1+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     9b2:	8e 81       	ldd	r24, Y+6	; 0x06
     9b4:	81 11       	cpse	r24, r1
     9b6:	0e 94 3f 0b 	call	0x167e	; 0x167e <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
     9ba:	26 96       	adiw	r28, 0x06	; 6
     9bc:	cd bf       	out	0x3d, r28	; 61
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	df 91       	pop	r29
     9c2:	cf 91       	pop	r28
     9c4:	ff 91       	pop	r31
     9c6:	ef 91       	pop	r30
     9c8:	bf 91       	pop	r27
     9ca:	af 91       	pop	r26
     9cc:	9f 91       	pop	r25
     9ce:	8f 91       	pop	r24
     9d0:	7f 91       	pop	r23
     9d2:	6f 91       	pop	r22
     9d4:	5f 91       	pop	r21
     9d6:	4f 91       	pop	r20
     9d8:	3f 91       	pop	r19
     9da:	2f 91       	pop	r18
     9dc:	1f 91       	pop	r17
     9de:	0f 90       	pop	r0
     9e0:	0b be       	out	0x3b, r0	; 59
     9e2:	0f 90       	pop	r0
     9e4:	0f be       	out	0x3f, r0	; 63
     9e6:	0f 90       	pop	r0
     9e8:	1f 90       	pop	r1
     9ea:	18 95       	reti
	
	//Process events
	if (l1)
		Event.Event=RISING_1B;
	else
		Event.Event=FALLING_1B;
     9ec:	86 e0       	ldi	r24, 0x06	; 6
     9ee:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     9f0:	20 e0       	ldi	r18, 0x00	; 0
     9f2:	ae 01       	movw	r20, r28
     9f4:	4a 5f       	subi	r20, 0xFA	; 250
     9f6:	5f 4f       	sbci	r21, 0xFF	; 255
     9f8:	be 01       	movw	r22, r28
     9fa:	6f 5f       	subi	r22, 0xFF	; 255
     9fc:	7f 4f       	sbci	r23, 0xFF	; 255
     9fe:	80 91 1a 22 	lds	r24, 0x221A	; 0x80221a <EncoderEventQueue>
     a02:	90 91 1b 22 	lds	r25, 0x221B	; 0x80221b <EncoderEventQueue+0x1>
     a06:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt1++;//Rising edge on Line1, Line0 low
	if ( l1 &&  l0) Cnt1--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt1++;//Falling edge on Line1, Line0 high
     a0a:	11 23       	and	r17, r17
     a0c:	49 f2       	breq	.-110    	; 0x9a0 <__vector_3+0x8c>
     a0e:	80 91 16 22 	lds	r24, 0x2216	; 0x802216 <Cnt1>
     a12:	90 91 17 22 	lds	r25, 0x2217	; 0x802217 <Cnt1+0x1>
     a16:	01 96       	adiw	r24, 0x01	; 1
     a18:	80 93 16 22 	sts	0x2216, r24	; 0x802216 <Cnt1>
     a1c:	90 93 17 22 	sts	0x2217, r25	; 0x802217 <Cnt1+0x1>
     a20:	c8 cf       	rjmp	.-112    	; 0x9b2 <__vector_3+0x9e>

00000a22 <__vector_43>:
	LastTriggerTime=Event.Time;
}

//Encoder 2 ISR's
ISR (PORTE_INT0_vect)
{
     a22:	1f 92       	push	r1
     a24:	0f 92       	push	r0
     a26:	0f b6       	in	r0, 0x3f	; 63
     a28:	0f 92       	push	r0
     a2a:	11 24       	eor	r1, r1
     a2c:	0b b6       	in	r0, 0x3b	; 59
     a2e:	0f 92       	push	r0
     a30:	1f 93       	push	r17
     a32:	2f 93       	push	r18
     a34:	3f 93       	push	r19
     a36:	4f 93       	push	r20
     a38:	5f 93       	push	r21
     a3a:	6f 93       	push	r22
     a3c:	7f 93       	push	r23
     a3e:	8f 93       	push	r24
     a40:	9f 93       	push	r25
     a42:	af 93       	push	r26
     a44:	bf 93       	push	r27
     a46:	ef 93       	push	r30
     a48:	ff 93       	push	r31
     a4a:	cf 93       	push	r28
     a4c:	df 93       	push	r29
     a4e:	00 d0       	rcall	.+0      	; 0xa50 <__vector_43+0x2e>
     a50:	00 d0       	rcall	.+0      	; 0xa52 <__vector_43+0x30>
     a52:	cd b7       	in	r28, 0x3d	; 61
     a54:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     a56:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
     a58:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     a5c:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     a60:	80 91 20 22 	lds	r24, 0x2220	; 0x802220 <StatsTimer>
     a64:	90 91 21 22 	lds	r25, 0x2221	; 0x802221 <StatsTimer+0x1>
     a68:	a0 91 22 22 	lds	r26, 0x2222	; 0x802222 <StatsTimer+0x2>
     a6c:	b0 91 23 22 	lds	r27, 0x2223	; 0x802223 <StatsTimer+0x3>
     a70:	82 0f       	add	r24, r18
     a72:	93 1f       	adc	r25, r19
     a74:	a1 1d       	adc	r26, r1
     a76:	b1 1d       	adc	r27, r1
     a78:	89 83       	std	Y+1, r24	; 0x01
     a7a:	9a 83       	std	Y+2, r25	; 0x02
     a7c:	ab 83       	std	Y+3, r26	; 0x03
     a7e:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTE.IN;
     a80:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x700688>
	l0=Data & (1<<4);
	l1=Data & (1<<5);
     a84:	18 2f       	mov	r17, r24
     a86:	10 72       	andi	r17, 0x20	; 32
	
	//Process events
	if (l0)
     a88:	84 ff       	sbrs	r24, 4
     a8a:	37 c0       	rjmp	.+110    	; 0xafa <__vector_43+0xd8>
		Event.Event=RISING_2A;
     a8c:	83 e0       	ldi	r24, 0x03	; 3
     a8e:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_2A;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     a90:	20 e0       	ldi	r18, 0x00	; 0
     a92:	ae 01       	movw	r20, r28
     a94:	4a 5f       	subi	r20, 0xFA	; 250
     a96:	5f 4f       	sbci	r21, 0xFF	; 255
     a98:	be 01       	movw	r22, r28
     a9a:	6f 5f       	subi	r22, 0xFF	; 255
     a9c:	7f 4f       	sbci	r23, 0xFF	; 255
     a9e:	80 91 1a 22 	lds	r24, 0x221A	; 0x80221a <EncoderEventQueue>
     aa2:	90 91 1b 22 	lds	r25, 0x221B	; 0x80221b <EncoderEventQueue+0x1>
     aa6:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt2--; //Rising edge on Line0, Line1 low
     aaa:	11 23       	and	r17, r17
     aac:	b9 f1       	breq	.+110    	; 0xb1c <__vector_43+0xfa>
	if ( l0 &&  l1) Cnt2++; //Rising edge on Line0, Line1 high
	if (!l0 &&  l1) Cnt2--; //Falling edge on Line0, Line1 high
	if (!l0 && !l1) Cnt2++;//Falling edge on Line1, Line1 low
     aae:	80 91 18 22 	lds	r24, 0x2218	; 0x802218 <Cnt2>
     ab2:	90 91 19 22 	lds	r25, 0x2219	; 0x802219 <Cnt2+0x1>
     ab6:	01 96       	adiw	r24, 0x01	; 1
     ab8:	80 93 18 22 	sts	0x2218, r24	; 0x802218 <Cnt2>
     abc:	90 93 19 22 	sts	0x2219, r25	; 0x802219 <Cnt2+0x1>
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     ac0:	8e 81       	ldd	r24, Y+6	; 0x06
     ac2:	81 11       	cpse	r24, r1
     ac4:	0e 94 3f 0b 	call	0x167e	; 0x167e <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
     ac8:	26 96       	adiw	r28, 0x06	; 6
     aca:	cd bf       	out	0x3d, r28	; 61
     acc:	de bf       	out	0x3e, r29	; 62
     ace:	df 91       	pop	r29
     ad0:	cf 91       	pop	r28
     ad2:	ff 91       	pop	r31
     ad4:	ef 91       	pop	r30
     ad6:	bf 91       	pop	r27
     ad8:	af 91       	pop	r26
     ada:	9f 91       	pop	r25
     adc:	8f 91       	pop	r24
     ade:	7f 91       	pop	r23
     ae0:	6f 91       	pop	r22
     ae2:	5f 91       	pop	r21
     ae4:	4f 91       	pop	r20
     ae6:	3f 91       	pop	r19
     ae8:	2f 91       	pop	r18
     aea:	1f 91       	pop	r17
     aec:	0f 90       	pop	r0
     aee:	0b be       	out	0x3b, r0	; 59
     af0:	0f 90       	pop	r0
     af2:	0f be       	out	0x3f, r0	; 63
     af4:	0f 90       	pop	r0
     af6:	1f 90       	pop	r1
     af8:	18 95       	reti
	
	//Process events
	if (l0)
		Event.Event=RISING_2A;
	else
		Event.Event=FALLING_2A;
     afa:	87 e0       	ldi	r24, 0x07	; 7
     afc:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     afe:	20 e0       	ldi	r18, 0x00	; 0
     b00:	ae 01       	movw	r20, r28
     b02:	4a 5f       	subi	r20, 0xFA	; 250
     b04:	5f 4f       	sbci	r21, 0xFF	; 255
     b06:	be 01       	movw	r22, r28
     b08:	6f 5f       	subi	r22, 0xFF	; 255
     b0a:	7f 4f       	sbci	r23, 0xFF	; 255
     b0c:	80 91 1a 22 	lds	r24, 0x221A	; 0x80221a <EncoderEventQueue>
     b10:	90 91 1b 22 	lds	r25, 0x221B	; 0x80221b <EncoderEventQueue+0x1>
     b14:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt2--; //Rising edge on Line0, Line1 low
	if ( l0 &&  l1) Cnt2++; //Rising edge on Line0, Line1 high
	if (!l0 &&  l1) Cnt2--; //Falling edge on Line0, Line1 high
     b18:	11 23       	and	r17, r17
     b1a:	49 f2       	breq	.-110    	; 0xaae <__vector_43+0x8c>
     b1c:	80 91 18 22 	lds	r24, 0x2218	; 0x802218 <Cnt2>
     b20:	90 91 19 22 	lds	r25, 0x2219	; 0x802219 <Cnt2+0x1>
     b24:	01 97       	sbiw	r24, 0x01	; 1
     b26:	80 93 18 22 	sts	0x2218, r24	; 0x802218 <Cnt2>
     b2a:	90 93 19 22 	sts	0x2219, r25	; 0x802219 <Cnt2+0x1>
     b2e:	c8 cf       	rjmp	.-112    	; 0xac0 <__vector_43+0x9e>

00000b30 <__vector_44>:
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	LastTriggerTime=Event.Time;
}

ISR (PORTE_INT1_vect)
{
     b30:	1f 92       	push	r1
     b32:	0f 92       	push	r0
     b34:	0f b6       	in	r0, 0x3f	; 63
     b36:	0f 92       	push	r0
     b38:	11 24       	eor	r1, r1
     b3a:	0b b6       	in	r0, 0x3b	; 59
     b3c:	0f 92       	push	r0
     b3e:	1f 93       	push	r17
     b40:	2f 93       	push	r18
     b42:	3f 93       	push	r19
     b44:	4f 93       	push	r20
     b46:	5f 93       	push	r21
     b48:	6f 93       	push	r22
     b4a:	7f 93       	push	r23
     b4c:	8f 93       	push	r24
     b4e:	9f 93       	push	r25
     b50:	af 93       	push	r26
     b52:	bf 93       	push	r27
     b54:	ef 93       	push	r30
     b56:	ff 93       	push	r31
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	00 d0       	rcall	.+0      	; 0xb5e <__vector_44+0x2e>
     b5e:	00 d0       	rcall	.+0      	; 0xb60 <__vector_44+0x30>
     b60:	cd b7       	in	r28, 0x3d	; 61
     b62:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     b64:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
     b66:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     b6a:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     b6e:	80 91 20 22 	lds	r24, 0x2220	; 0x802220 <StatsTimer>
     b72:	90 91 21 22 	lds	r25, 0x2221	; 0x802221 <StatsTimer+0x1>
     b76:	a0 91 22 22 	lds	r26, 0x2222	; 0x802222 <StatsTimer+0x2>
     b7a:	b0 91 23 22 	lds	r27, 0x2223	; 0x802223 <StatsTimer+0x3>
     b7e:	82 0f       	add	r24, r18
     b80:	93 1f       	adc	r25, r19
     b82:	a1 1d       	adc	r26, r1
     b84:	b1 1d       	adc	r27, r1
     b86:	89 83       	std	Y+1, r24	; 0x01
     b88:	9a 83       	std	Y+2, r25	; 0x02
     b8a:	ab 83       	std	Y+3, r26	; 0x03
     b8c:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTE.IN;
     b8e:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x700688>
	l0=Data & (1<<4);
	l1=Data & (1<<5);
     b92:	18 2f       	mov	r17, r24
     b94:	10 72       	andi	r17, 0x20	; 32
	
	//Process events
	if (l0)
     b96:	84 ff       	sbrs	r24, 4
     b98:	1c c0       	rjmp	.+56     	; 0xbd2 <__vector_44+0xa2>
	Event.Event=RISING_2B;
     b9a:	84 e0       	ldi	r24, 0x04	; 4
     b9c:	8d 83       	std	Y+5, r24	; 0x05
	else
	Event.Event=FALLING_2B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     b9e:	20 e0       	ldi	r18, 0x00	; 0
     ba0:	ae 01       	movw	r20, r28
     ba2:	4a 5f       	subi	r20, 0xFA	; 250
     ba4:	5f 4f       	sbci	r21, 0xFF	; 255
     ba6:	be 01       	movw	r22, r28
     ba8:	6f 5f       	subi	r22, 0xFF	; 255
     baa:	7f 4f       	sbci	r23, 0xFF	; 255
     bac:	80 91 1a 22 	lds	r24, 0x221A	; 0x80221a <EncoderEventQueue>
     bb0:	90 91 1b 22 	lds	r25, 0x221B	; 0x80221b <EncoderEventQueue+0x1>
     bb4:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
     bb8:	11 23       	and	r17, r17
     bba:	09 f4       	brne	.+2      	; 0xbbe <__vector_44+0x8e>
     bbc:	47 c0       	rjmp	.+142    	; 0xc4c <__vector_44+0x11c>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
     bbe:	80 91 18 22 	lds	r24, 0x2218	; 0x802218 <Cnt2>
     bc2:	90 91 19 22 	lds	r25, 0x2219	; 0x802219 <Cnt2+0x1>
     bc6:	01 97       	sbiw	r24, 0x01	; 1
     bc8:	80 93 18 22 	sts	0x2218, r24	; 0x802218 <Cnt2>
     bcc:	90 93 19 22 	sts	0x2219, r25	; 0x802219 <Cnt2+0x1>
     bd0:	1a c0       	rjmp	.+52     	; 0xc06 <__vector_44+0xd6>
	
	//Process events
	if (l0)
	Event.Event=RISING_2B;
	else
	Event.Event=FALLING_2B;
     bd2:	88 e0       	ldi	r24, 0x08	; 8
     bd4:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     bd6:	20 e0       	ldi	r18, 0x00	; 0
     bd8:	ae 01       	movw	r20, r28
     bda:	4a 5f       	subi	r20, 0xFA	; 250
     bdc:	5f 4f       	sbci	r21, 0xFF	; 255
     bde:	be 01       	movw	r22, r28
     be0:	6f 5f       	subi	r22, 0xFF	; 255
     be2:	7f 4f       	sbci	r23, 0xFF	; 255
     be4:	80 91 1a 22 	lds	r24, 0x221A	; 0x80221a <EncoderEventQueue>
     be8:	90 91 1b 22 	lds	r25, 0x221B	; 0x80221b <EncoderEventQueue+0x1>
     bec:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
     bf0:	80 91 18 22 	lds	r24, 0x2218	; 0x802218 <Cnt2>
     bf4:	90 91 19 22 	lds	r25, 0x2219	; 0x802219 <Cnt2+0x1>
     bf8:	11 11       	cpse	r17, r1
     bfa:	22 c0       	rjmp	.+68     	; 0xc40 <__vector_44+0x110>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt2++;//Falling edge on Line1, Line0 high
	if (!l1 && !l0) Cnt2--;//Falling edge on Line1, Line0 low
     bfc:	01 97       	sbiw	r24, 0x01	; 1
     bfe:	80 93 18 22 	sts	0x2218, r24	; 0x802218 <Cnt2>
     c02:	90 93 19 22 	sts	0x2219, r25	; 0x802219 <Cnt2+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     c06:	8e 81       	ldd	r24, Y+6	; 0x06
     c08:	81 11       	cpse	r24, r1
     c0a:	0e 94 3f 0b 	call	0x167e	; 0x167e <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
     c0e:	26 96       	adiw	r28, 0x06	; 6
     c10:	cd bf       	out	0x3d, r28	; 61
     c12:	de bf       	out	0x3e, r29	; 62
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	ff 91       	pop	r31
     c1a:	ef 91       	pop	r30
     c1c:	bf 91       	pop	r27
     c1e:	af 91       	pop	r26
     c20:	9f 91       	pop	r25
     c22:	8f 91       	pop	r24
     c24:	7f 91       	pop	r23
     c26:	6f 91       	pop	r22
     c28:	5f 91       	pop	r21
     c2a:	4f 91       	pop	r20
     c2c:	3f 91       	pop	r19
     c2e:	2f 91       	pop	r18
     c30:	1f 91       	pop	r17
     c32:	0f 90       	pop	r0
     c34:	0b be       	out	0x3b, r0	; 59
     c36:	0f 90       	pop	r0
     c38:	0f be       	out	0x3f, r0	; 63
     c3a:	0f 90       	pop	r0
     c3c:	1f 90       	pop	r1
     c3e:	18 95       	reti
	else
	Event.Event=FALLING_2B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
     c40:	01 96       	adiw	r24, 0x01	; 1
     c42:	80 93 18 22 	sts	0x2218, r24	; 0x802218 <Cnt2>
     c46:	90 93 19 22 	sts	0x2219, r25	; 0x802219 <Cnt2+0x1>
     c4a:	dd cf       	rjmp	.-70     	; 0xc06 <__vector_44+0xd6>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt2++;//Falling edge on Line1, Line0 high
     c4c:	80 91 18 22 	lds	r24, 0x2218	; 0x802218 <Cnt2>
     c50:	90 91 19 22 	lds	r25, 0x2219	; 0x802219 <Cnt2+0x1>
     c54:	01 96       	adiw	r24, 0x01	; 1
     c56:	80 93 18 22 	sts	0x2218, r24	; 0x802218 <Cnt2>
     c5a:	90 93 19 22 	sts	0x2219, r25	; 0x802219 <Cnt2+0x1>
     c5e:	d3 cf       	rjmp	.-90     	; 0xc06 <__vector_44+0xd6>

00000c60 <DriverMotorResetEncoder>:
}


void DriverMotorResetEncoder(void)
{
	portENTER_CRITICAL();	
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	f8 94       	cli
     c64:	0f 92       	push	r0
	Cnt1=0;
     c66:	10 92 16 22 	sts	0x2216, r1	; 0x802216 <Cnt1>
     c6a:	10 92 17 22 	sts	0x2217, r1	; 0x802217 <Cnt1+0x1>
	Cnt2=0;
     c6e:	10 92 18 22 	sts	0x2218, r1	; 0x802218 <Cnt2>
     c72:	10 92 19 22 	sts	0x2219, r1	; 0x802219 <Cnt2+0x1>
	portEXIT_CRITICAL();
     c76:	0f 90       	pop	r0
     c78:	0f be       	out	0x3f, r0	; 63
     c7a:	08 95       	ret

00000c7c <ShiftInBit>:
	PORTD.DIRSET=1<<3;
	PORTD.PIN3CTRL=0b01000000;
	USARTD0.CTRLA=0b00000000;
	USARTD0.CTRLB=0b1000;
	USARTD0.CTRLC=0b11000000;
	USARTD0.BAUDCTRLA=5; //0.375s per bit, 
     c7c:	cf 93       	push	r28
     c7e:	c8 2f       	mov	r28, r24
     c80:	80 91 48 21 	lds	r24, 0x2148	; 0x802148 <ByteIdx>
     c84:	8e 34       	cpi	r24, 0x4E	; 78
     c86:	50 f5       	brcc	.+84     	; 0xcdc <ShiftInBit+0x60>
     c88:	90 91 49 21 	lds	r25, 0x2149	; 0x802149 <BitIdx>
     c8c:	91 11       	cpse	r25, r1
     c8e:	06 c0       	rjmp	.+12     	; 0xc9c <ShiftInBit+0x20>
     c90:	e8 2f       	mov	r30, r24
     c92:	f0 e0       	ldi	r31, 0x00	; 0
     c94:	e6 50       	subi	r30, 0x06	; 6
     c96:	ff 4d       	sbci	r31, 0xDF	; 223
     c98:	2f ef       	ldi	r18, 0xFF	; 255
     c9a:	20 83       	st	Z, r18
     c9c:	c1 11       	cpse	r28, r1
     c9e:	10 c0       	rjmp	.+32     	; 0xcc0 <ShiftInBit+0x44>
     ca0:	e8 2f       	mov	r30, r24
     ca2:	f0 e0       	ldi	r31, 0x00	; 0
     ca4:	e6 50       	subi	r30, 0x06	; 6
     ca6:	ff 4d       	sbci	r31, 0xDF	; 223
     ca8:	20 e8       	ldi	r18, 0x80	; 128
     caa:	30 e0       	ldi	r19, 0x00	; 0
     cac:	09 2e       	mov	r0, r25
     cae:	02 c0       	rjmp	.+4      	; 0xcb4 <ShiftInBit+0x38>
     cb0:	35 95       	asr	r19
     cb2:	27 95       	ror	r18
     cb4:	0a 94       	dec	r0
     cb6:	e2 f7       	brpl	.-8      	; 0xcb0 <ShiftInBit+0x34>
     cb8:	20 95       	com	r18
     cba:	30 81       	ld	r19, Z
     cbc:	23 23       	and	r18, r19
     cbe:	20 83       	st	Z, r18
     cc0:	9f 5f       	subi	r25, 0xFF	; 255
     cc2:	98 30       	cpi	r25, 0x08	; 8
     cc4:	39 f4       	brne	.+14     	; 0xcd4 <ShiftInBit+0x58>
     cc6:	10 92 49 21 	sts	0x2149, r1	; 0x802149 <BitIdx>
     cca:	8f 5f       	subi	r24, 0xFF	; 255
     ccc:	80 93 48 21 	sts	0x2148, r24	; 0x802148 <ByteIdx>
     cd0:	cf 91       	pop	r28
     cd2:	08 95       	ret
     cd4:	90 93 49 21 	sts	0x2149, r25	; 0x802149 <BitIdx>
     cd8:	cf 91       	pop	r28
     cda:	08 95       	ret
     cdc:	67 e2       	ldi	r22, 0x27	; 39
     cde:	70 e0       	ldi	r23, 0x00	; 0
     ce0:	88 e0       	ldi	r24, 0x08	; 8
     ce2:	90 e2       	ldi	r25, 0x20	; 32
     ce4:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
     ce8:	90 91 49 21 	lds	r25, 0x2149	; 0x802149 <BitIdx>
     cec:	80 91 48 21 	lds	r24, 0x2148	; 0x802148 <ByteIdx>
     cf0:	91 11       	cpse	r25, r1
     cf2:	0d c0       	rjmp	.+26     	; 0xd0e <ShiftInBit+0x92>
     cf4:	e8 2f       	mov	r30, r24
     cf6:	f0 e0       	ldi	r31, 0x00	; 0
     cf8:	e6 50       	subi	r30, 0x06	; 6
     cfa:	ff 4d       	sbci	r31, 0xDF	; 223
     cfc:	2f ef       	ldi	r18, 0xFF	; 255
     cfe:	20 83       	st	Z, r18
     d00:	8e 34       	cpi	r24, 0x4E	; 78
     d02:	60 f2       	brcs	.-104    	; 0xc9c <ShiftInBit+0x20>
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	80 93 49 21 	sts	0x2149, r24	; 0x802149 <BitIdx>
     d0a:	cf 91       	pop	r28
     d0c:	08 95       	ret
     d0e:	8e 34       	cpi	r24, 0x4E	; 78
     d10:	28 f2       	brcs	.-118    	; 0xc9c <ShiftInBit+0x20>
     d12:	9f 5f       	subi	r25, 0xFF	; 255
     d14:	98 30       	cpi	r25, 0x08	; 8
     d16:	b9 f2       	breq	.-82     	; 0xcc6 <ShiftInBit+0x4a>
     d18:	dd cf       	rjmp	.-70     	; 0xcd4 <ShiftInBit+0x58>

00000d1a <ShiftIn0>:
     d1a:	80 e0       	ldi	r24, 0x00	; 0
     d1c:	0e 94 3e 06 	call	0xc7c	; 0xc7c <ShiftInBit>
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	0e 94 3e 06 	call	0xc7c	; 0xc7c <ShiftInBit>
     d26:	81 e0       	ldi	r24, 0x01	; 1
     d28:	0e 94 3e 06 	call	0xc7c	; 0xc7c <ShiftInBit>
     d2c:	81 e0       	ldi	r24, 0x01	; 1
     d2e:	0e 94 3e 06 	call	0xc7c	; 0xc7c <ShiftInBit>
     d32:	81 e0       	ldi	r24, 0x01	; 1
     d34:	0c 94 3e 06 	jmp	0xc7c	; 0xc7c <ShiftInBit>

00000d38 <ShiftIn1>:
     d38:	80 e0       	ldi	r24, 0x00	; 0
     d3a:	0e 94 3e 06 	call	0xc7c	; 0xc7c <ShiftInBit>
     d3e:	80 e0       	ldi	r24, 0x00	; 0
     d40:	0e 94 3e 06 	call	0xc7c	; 0xc7c <ShiftInBit>
     d44:	80 e0       	ldi	r24, 0x00	; 0
     d46:	0e 94 3e 06 	call	0xc7c	; 0xc7c <ShiftInBit>
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	0e 94 3e 06 	call	0xc7c	; 0xc7c <ShiftInBit>
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	0c 94 3e 06 	jmp	0xc7c	; 0xc7c <ShiftInBit>

00000d56 <ShiftInByte>:
     d56:	cf 93       	push	r28
     d58:	df 93       	push	r29
     d5a:	d8 2f       	mov	r29, r24
     d5c:	c8 e0       	ldi	r28, 0x08	; 8
     d5e:	05 c0       	rjmp	.+10     	; 0xd6a <ShiftInByte+0x14>
     d60:	0e 94 8d 06 	call	0xd1a	; 0xd1a <ShiftIn0>
     d64:	dd 0f       	add	r29, r29
     d66:	c1 50       	subi	r28, 0x01	; 1
     d68:	39 f0       	breq	.+14     	; 0xd78 <ShiftInByte+0x22>
     d6a:	d7 ff       	sbrs	r29, 7
     d6c:	f9 cf       	rjmp	.-14     	; 0xd60 <ShiftInByte+0xa>
     d6e:	0e 94 9c 06 	call	0xd38	; 0xd38 <ShiftIn1>
     d72:	dd 0f       	add	r29, r29
     d74:	c1 50       	subi	r28, 0x01	; 1
     d76:	c9 f7       	brne	.-14     	; 0xd6a <ShiftInByte+0x14>
     d78:	df 91       	pop	r29
     d7a:	cf 91       	pop	r28
     d7c:	08 95       	ret

00000d7e <DriverPL9823Init>:
}

void DriverPL9823Init()
{
	//CS init
	PORTA.DIRSET=1<<6;
     d7e:	e0 e0       	ldi	r30, 0x00	; 0
     d80:	f6 e0       	ldi	r31, 0x06	; 6
     d82:	80 e4       	ldi	r24, 0x40	; 64
     d84:	81 83       	std	Z+1, r24	; 0x01
	PORTA.OUTCLR=1<<6;
     d86:	86 83       	std	Z+6, r24	; 0x06
     d88:	08 95       	ret

00000d8a <DriverPL9823Set>:
}

void DriverPL9823Set(uint32_t FrontLeft,uint32_t FrontRight,uint32_t RearRight,uint32_t RearLeft)
{
     d8a:	3f 92       	push	r3
     d8c:	4f 92       	push	r4
     d8e:	5f 92       	push	r5
     d90:	6f 92       	push	r6
     d92:	7f 92       	push	r7
     d94:	8f 92       	push	r8
     d96:	9f 92       	push	r9
     d98:	af 92       	push	r10
     d9a:	bf 92       	push	r11
     d9c:	cf 92       	push	r12
     d9e:	df 92       	push	r13
     da0:	ef 92       	push	r14
     da2:	ff 92       	push	r15
     da4:	0f 93       	push	r16
     da6:	1f 93       	push	r17
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	36 2e       	mov	r3, r22
     dae:	47 2e       	mov	r4, r23
     db0:	58 2e       	mov	r5, r24
     db2:	d2 2e       	mov	r13, r18
     db4:	13 2f       	mov	r17, r19
     db6:	d4 2f       	mov	r29, r20
}

void PortSetup(void)
{
	//Data init
	PORTD.DIRSET=1<<3;
     db8:	88 e0       	ldi	r24, 0x08	; 8
     dba:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
	PORTD.PIN3CTRL=0b01000000;
     dbe:	90 e4       	ldi	r25, 0x40	; 64
     dc0:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <__TEXT_REGION_LENGTH__+0x700673>
	USARTD0.CTRLA=0b00000000;
     dc4:	10 92 a3 09 	sts	0x09A3, r1	; 0x8009a3 <__TEXT_REGION_LENGTH__+0x7009a3>
	USARTD0.CTRLB=0b1000;
     dc8:	80 93 a4 09 	sts	0x09A4, r24	; 0x8009a4 <__TEXT_REGION_LENGTH__+0x7009a4>
	USARTD0.CTRLC=0b11000000;
     dcc:	80 ec       	ldi	r24, 0xC0	; 192
     dce:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <__TEXT_REGION_LENGTH__+0x7009a5>
	USARTD0.BAUDCTRLA=5; //0.375s per bit, 
     dd2:	85 e0       	ldi	r24, 0x05	; 5
     dd4:	80 93 a6 09 	sts	0x09A6, r24	; 0x8009a6 <__TEXT_REGION_LENGTH__+0x7009a6>
     dd8:	8a ef       	ldi	r24, 0xFA	; 250
     dda:	88 2e       	mov	r8, r24
     ddc:	80 e2       	ldi	r24, 0x20	; 32
     dde:	98 2e       	mov	r9, r24
     de0:	98 e4       	ldi	r25, 0x48	; 72
     de2:	69 2e       	mov	r6, r25
     de4:	91 e2       	ldi	r25, 0x21	; 33
     de6:	79 2e       	mov	r7, r25
     de8:	f4 01       	movw	r30, r8

void ShiftReset()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
		DataBuffer[a]=255;	
     dea:	8f ef       	ldi	r24, 0xFF	; 255
     dec:	81 93       	st	Z+, r24
}

void ShiftReset()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
     dee:	6e 16       	cp	r6, r30
     df0:	7f 06       	cpc	r7, r31
     df2:	e1 f7       	brne	.-8      	; 0xdec <DriverPL9823Set+0x62>
		DataBuffer[a]=255;	
	ByteIdx=0;	
     df4:	10 92 48 21 	sts	0x2148, r1	; 0x802148 <ByteIdx>
     df8:	c5 e8       	ldi	r28, 0x85	; 133
}
void ShiftInReset()
{
	uint8_t a;
	for (a=0;a<133;a++) ShiftInBit(1);
     dfa:	81 e0       	ldi	r24, 0x01	; 1
     dfc:	0e 94 3e 06 	call	0xc7c	; 0xc7c <ShiftInBit>
     e00:	c1 50       	subi	r28, 0x01	; 1
     e02:	d9 f7       	brne	.-10     	; 0xdfa <DriverPL9823Set+0x70>
	
	ShiftReset();

	ShiftInReset();
	
	ShiftInByte((uint8_t) ((FrontLeft>>0) & 0xFF));
     e04:	83 2d       	mov	r24, r3
     e06:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontLeft>>8) & 0xFF));
     e0a:	84 2d       	mov	r24, r4
     e0c:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontLeft>>16) & 0xFF));
     e10:	85 2d       	mov	r24, r5
     e12:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>

	ShiftInByte((uint8_t) ((FrontRight>>0) & 0xFF));
     e16:	8d 2d       	mov	r24, r13
     e18:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontRight>>8) & 0xFF));
     e1c:	81 2f       	mov	r24, r17
     e1e:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontRight>>16) & 0xFF));
     e22:	8d 2f       	mov	r24, r29
     e24:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	
	ShiftInByte((uint8_t) ((RearRight>>0) & 0xFF));
     e28:	8e 2d       	mov	r24, r14
     e2a:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	ShiftInByte((uint8_t) ((RearRight>>8) & 0xFF));
     e2e:	8f 2d       	mov	r24, r15
     e30:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	ShiftInByte((uint8_t) ((RearRight>>16) & 0xFF));
     e34:	80 2f       	mov	r24, r16
     e36:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	
	ShiftInByte((uint8_t) ((RearLeft>>0) & 0xFF));
     e3a:	8a 2d       	mov	r24, r10
     e3c:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	ShiftInByte((uint8_t) ((RearLeft>>8) & 0xFF));
     e40:	8b 2d       	mov	r24, r11
     e42:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	ShiftInByte((uint8_t) ((RearLeft>>16) & 0xFF));
     e46:	8c 2d       	mov	r24, r12
     e48:	0e 94 ab 06 	call	0xd56	; 0xd56 <ShiftInByte>
	
	portENTER_CRITICAL();
     e4c:	0f b6       	in	r0, 0x3f	; 63
     e4e:	f8 94       	cli
     e50:	0f 92       	push	r0


void SendBuffer()
{
	uint8_t a;
	TxIdx=0;
     e52:	10 92 f9 20 	sts	0x20F9, r1	; 0x8020f9 <TxIdx>
	
	PORTA.OUTSET=1<<6; //CS enable
     e56:	80 e4       	ldi	r24, 0x40	; 64
     e58:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>


void SendByte(uint8_t Data)
{
	while (!(USARTD0.STATUS&(1<<5)));
	USARTD0.STATUS=(1<<6); //Clear TXCIF
     e5c:	20 e4       	ldi	r18, 0x40	; 64
	uint8_t a;
	TxIdx=0;
	
	PORTA.OUTSET=1<<6; //CS enable
	for (a=0;a<BUFFER_SIZE;a++)
		SendByte(DataBuffer[a]);
     e5e:	f4 01       	movw	r30, r8
     e60:	91 91       	ld	r25, Z+
     e62:	4f 01       	movw	r8, r30
static volatile uint8_t TxIdx;


void SendByte(uint8_t Data)
{
	while (!(USARTD0.STATUS&(1<<5)));
     e64:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
     e68:	85 ff       	sbrs	r24, 5
     e6a:	fc cf       	rjmp	.-8      	; 0xe64 <DriverPL9823Set+0xda>
	USARTD0.STATUS=(1<<6); //Clear TXCIF
     e6c:	20 93 a1 09 	sts	0x09A1, r18	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
	USARTD0.DATA=Data;
     e70:	90 93 a0 09 	sts	0x09A0, r25	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
{
	uint8_t a;
	TxIdx=0;
	
	PORTA.OUTSET=1<<6; //CS enable
	for (a=0;a<BUFFER_SIZE;a++)
     e74:	68 14       	cp	r6, r8
     e76:	79 04       	cpc	r7, r9
     e78:	91 f7       	brne	.-28     	; 0xe5e <DriverPL9823Set+0xd4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     e7a:	8f ee       	ldi	r24, 0xEF	; 239
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	01 97       	sbiw	r24, 0x01	; 1
     e80:	f1 f7       	brne	.-4      	; 0xe7e <DriverPL9823Set+0xf4>
     e82:	00 c0       	rjmp	.+0      	; 0xe84 <DriverPL9823Set+0xfa>
     e84:	00 00       	nop
		SendByte(DataBuffer[a]);
	_delay_us(30);	
	PORTA.OUTCLR=1<<6; //CS disable
     e86:	80 e4       	ldi	r24, 0x40	; 64
     e88:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
	ShiftInByte((uint8_t) ((RearLeft>>8) & 0xFF));
	ShiftInByte((uint8_t) ((RearLeft>>16) & 0xFF));
	
	portENTER_CRITICAL();
	SendBuffer(); //Approx 260 s for entire buffer
	portEXIT_CRITICAL();
     e8c:	0f 90       	pop	r0
     e8e:	0f be       	out	0x3f, r0	; 63
}
     e90:	df 91       	pop	r29
     e92:	cf 91       	pop	r28
     e94:	1f 91       	pop	r17
     e96:	0f 91       	pop	r16
     e98:	ff 90       	pop	r15
     e9a:	ef 90       	pop	r14
     e9c:	df 90       	pop	r13
     e9e:	cf 90       	pop	r12
     ea0:	bf 90       	pop	r11
     ea2:	af 90       	pop	r10
     ea4:	9f 90       	pop	r9
     ea6:	8f 90       	pop	r8
     ea8:	7f 90       	pop	r7
     eaa:	6f 90       	pop	r6
     eac:	5f 90       	pop	r5
     eae:	4f 90       	pop	r4
     eb0:	3f 90       	pop	r3
     eb2:	08 95       	ret

00000eb4 <DriverPowerInit>:
#include "DriverPower.h"

void DriverPowerInit(void)
{
	//Aux Vcc GPIO setup
	PORTC.DIRSET=1<<5;
     eb4:	80 e2       	ldi	r24, 0x20	; 32
     eb6:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
     eba:	08 95       	ret

00000ebc <DriverPowerVccAuxSet>:
}


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
     ebc:	81 11       	cpse	r24, r1
     ebe:	04 c0       	rjmp	.+8      	; 0xec8 <DriverPowerVccAuxSet+0xc>
		PORTC.OUTSET=1<<5;
	else
		PORTC.OUTCLR=1<<5;
     ec0:	80 e2       	ldi	r24, 0x20	; 32
     ec2:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
     ec6:	08 95       	ret


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
		PORTC.OUTSET=1<<5;
     ec8:	80 e2       	ldi	r24, 0x20	; 32
     eca:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
     ece:	08 95       	ret

00000ed0 <DriverSysClkXtalInit>:
    // Clock setup          
    if (F_XTAL<400E3) return -1; //Invalid frequency
    if (F_XTAL<=2E6) OSC.XOSCCTRL=0b00001011; //Select <2 Mhz XTAL osc, max startup time
    else if(F_XTAL<=9E6) OSC.XOSCCTRL=0b01001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=12E6) OSC.XOSCCTRL=0b10001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=16E6) OSC.XOSCCTRL=0b11001011; //Select <2 Mhz XTAL osc, max startup time 
     ed0:	8b ec       	ldi	r24, 0xCB	; 203
     ed2:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
    else return -1; //Invalid frequency
    OSC.CTRL=0b01000; //Enable oscillator
     ed6:	88 e0       	ldi	r24, 0x08	; 8
     ed8:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    
	//Wait until XTAL osc is ready
    while (!(OSC.STATUS&0b1000)); 
     edc:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
     ee0:	83 ff       	sbrs	r24, 3
     ee2:	fc cf       	rjmp	.-8      	; 0xedc <DriverSysClkXtalInit+0xc>
	{
		//Configure PLL
		Mult=F_CPU/F_XTAL;
		if (Mult>31) return -1; //Invalid frequency; too high
		if (F_XTAL * (uint32_t) Mult !=F_CPU) return -1; //Only supports whole dividers
		OSC.PLLCTRL=0b11000000 | (Mult);
     ee4:	82 ec       	ldi	r24, 0xC2	; 194
     ee6:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
		OSC.CTRL=0b00011000; //Enable PLL
     eea:	88 e1       	ldi	r24, 0x18	; 24
     eec:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
		
		//Wait until PLL is ready
		while (!(OSC.STATUS & 0b00010000));
     ef0:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
     ef4:	84 ff       	sbrs	r24, 4
     ef6:	fc cf       	rjmp	.-8      	; 0xef0 <DriverSysClkXtalInit+0x20>
		
		//Select PLL as system CLK source
		CCP=0xd8;
     ef8:	88 ed       	ldi	r24, 0xD8	; 216
     efa:	84 bf       	out	0x34, r24	; 52
		CLK.CTRL=0b100;
     efc:	84 e0       	ldi	r24, 0x04	; 4
     efe:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
	}
	return 0;
}
     f02:	80 e0       	ldi	r24, 0x00	; 0
     f04:	08 95       	ret

00000f06 <TWIMWriteHandler>:
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
	Twim_status = TWIM_STATUS_READY;
     f06:	90 91 51 21 	lds	r25, 0x2151	; 0x802151 <Twim_bytesToWrite>
     f0a:	20 91 50 21 	lds	r18, 0x2150	; 0x802150 <Twim_bytesToRead>
     f0e:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>
     f12:	84 fd       	sbrc	r24, 4
     f14:	22 c0       	rjmp	.+68     	; 0xf5a <TWIMWriteHandler+0x54>
     f16:	80 91 4f 21 	lds	r24, 0x214F	; 0x80214f <Twim_bytesWritten>
     f1a:	89 17       	cp	r24, r25
     f1c:	68 f0       	brcs	.+26     	; 0xf38 <TWIMWriteHandler+0x32>
     f1e:	80 91 4e 21 	lds	r24, 0x214E	; 0x80214e <Twim_bytesRead>
     f22:	82 17       	cp	r24, r18
     f24:	18 f1       	brcs	.+70     	; 0xf6c <TWIMWriteHandler+0x66>
     f26:	83 e0       	ldi	r24, 0x03	; 3
     f28:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
     f2c:	81 e0       	ldi	r24, 0x01	; 1
     f2e:	80 93 4c 21 	sts	0x214C, r24	; 0x80214c <Twim_result>
     f32:	10 92 4d 21 	sts	0x214D, r1	; 0x80214d <Twim_status>
     f36:	08 95       	ret
     f38:	80 91 4f 21 	lds	r24, 0x214F	; 0x80214f <Twim_bytesWritten>
     f3c:	e0 91 54 21 	lds	r30, 0x2154	; 0x802154 <Twim_writeData>
     f40:	f0 91 55 21 	lds	r31, 0x2155	; 0x802155 <Twim_writeData+0x1>
     f44:	e8 0f       	add	r30, r24
     f46:	f1 1d       	adc	r31, r1
     f48:	80 81       	ld	r24, Z
     f4a:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
     f4e:	80 91 4f 21 	lds	r24, 0x214F	; 0x80214f <Twim_bytesWritten>
     f52:	8f 5f       	subi	r24, 0xFF	; 255
     f54:	80 93 4f 21 	sts	0x214F, r24	; 0x80214f <Twim_bytesWritten>
     f58:	08 95       	ret
     f5a:	83 e0       	ldi	r24, 0x03	; 3
     f5c:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
     f60:	85 e0       	ldi	r24, 0x05	; 5
     f62:	80 93 4c 21 	sts	0x214C, r24	; 0x80214c <Twim_result>
     f66:	10 92 4d 21 	sts	0x214D, r1	; 0x80214d <Twim_status>
     f6a:	08 95       	ret
     f6c:	80 91 56 21 	lds	r24, 0x2156	; 0x802156 <Twim_address>
     f70:	81 60       	ori	r24, 0x01	; 1
     f72:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
     f76:	08 95       	ret

00000f78 <TWIMReadHandler>:
     f78:	80 91 4e 21 	lds	r24, 0x214E	; 0x80214e <Twim_bytesRead>
     f7c:	80 32       	cpi	r24, 0x20	; 32
     f7e:	f8 f4       	brcc	.+62     	; 0xfbe <TWIMReadHandler+0x46>
     f80:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
     f84:	90 91 4e 21 	lds	r25, 0x214E	; 0x80214e <Twim_bytesRead>
     f88:	e0 91 52 21 	lds	r30, 0x2152	; 0x802152 <Twim_readData>
     f8c:	f0 91 53 21 	lds	r31, 0x2153	; 0x802153 <Twim_readData+0x1>
     f90:	e9 0f       	add	r30, r25
     f92:	f1 1d       	adc	r31, r1
     f94:	80 83       	st	Z, r24
     f96:	80 91 4e 21 	lds	r24, 0x214E	; 0x80214e <Twim_bytesRead>
     f9a:	8f 5f       	subi	r24, 0xFF	; 255
     f9c:	80 93 4e 21 	sts	0x214E, r24	; 0x80214e <Twim_bytesRead>
     fa0:	90 91 50 21 	lds	r25, 0x2150	; 0x802150 <Twim_bytesToRead>
     fa4:	80 91 4e 21 	lds	r24, 0x214E	; 0x80214e <Twim_bytesRead>
     fa8:	89 17       	cp	r24, r25
     faa:	b8 f0       	brcs	.+46     	; 0xfda <TWIMReadHandler+0x62>
     fac:	87 e0       	ldi	r24, 0x07	; 7
     fae:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
     fb2:	81 e0       	ldi	r24, 0x01	; 1
     fb4:	80 93 4c 21 	sts	0x214C, r24	; 0x80214c <Twim_result>
     fb8:	10 92 4d 21 	sts	0x214D, r1	; 0x80214d <Twim_status>
     fbc:	08 95       	ret
     fbe:	83 e0       	ldi	r24, 0x03	; 3
     fc0:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
     fc4:	82 e0       	ldi	r24, 0x02	; 2
     fc6:	80 93 4c 21 	sts	0x214C, r24	; 0x80214c <Twim_result>
     fca:	10 92 4d 21 	sts	0x214D, r1	; 0x80214d <Twim_status>
     fce:	90 91 50 21 	lds	r25, 0x2150	; 0x802150 <Twim_bytesToRead>
     fd2:	80 91 4e 21 	lds	r24, 0x214E	; 0x80214e <Twim_bytesRead>
     fd6:	89 17       	cp	r24, r25
     fd8:	48 f7       	brcc	.-46     	; 0xfac <TWIMReadHandler+0x34>
     fda:	82 e0       	ldi	r24, 0x02	; 2
     fdc:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
     fe0:	08 95       	ret

00000fe2 <__vector_46>:
}

ISR (TWIM_BUS_vect)
{
     fe2:	1f 92       	push	r1
     fe4:	0f 92       	push	r0
     fe6:	0f b6       	in	r0, 0x3f	; 63
     fe8:	0f 92       	push	r0
     fea:	11 24       	eor	r1, r1
     fec:	0b b6       	in	r0, 0x3b	; 59
     fee:	0f 92       	push	r0
     ff0:	2f 93       	push	r18
     ff2:	3f 93       	push	r19
     ff4:	4f 93       	push	r20
     ff6:	5f 93       	push	r21
     ff8:	6f 93       	push	r22
     ffa:	7f 93       	push	r23
     ffc:	8f 93       	push	r24
     ffe:	9f 93       	push	r25
    1000:	af 93       	push	r26
    1002:	bf 93       	push	r27
    1004:	ef 93       	push	r30
    1006:	ff 93       	push	r31
    1008:	cf 93       	push	r28
    100a:	df 93       	push	r29
    100c:	1f 92       	push	r1
    100e:	cd b7       	in	r28, 0x3d	; 61
    1010:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    1012:	19 82       	std	Y+1, r1	; 0x01
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    1014:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
    1018:	98 2f       	mov	r25, r24
    101a:	9c 70       	andi	r25, 0x0C	; 12
    101c:	e1 f4       	brne	.+56     	; 0x1056 <__vector_46+0x74>

		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
    101e:	86 fd       	sbrc	r24, 6
    1020:	44 c0       	rjmp	.+136    	; 0x10aa <__vector_46+0xc8>
		TWIMWriteHandler();
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
    1022:	87 fd       	sbrc	r24, 7
    1024:	45 c0       	rjmp	.+138    	; 0x10b0 <__vector_46+0xce>
	}
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
    1026:	86 e0       	ldi	r24, 0x06	; 6
    1028:	80 93 4c 21 	sts	0x214C, r24	; 0x80214c <Twim_result>
	Twim_status = TWIM_STATUS_READY;
    102c:	10 92 4d 21 	sts	0x214D, r1	; 0x80214d <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    1030:	80 91 4d 21 	lds	r24, 0x214D	; 0x80214d <Twim_status>
    1034:	81 11       	cpse	r24, r1
    1036:	1f c0       	rjmp	.+62     	; 0x1076 <__vector_46+0x94>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );
    1038:	be 01       	movw	r22, r28
    103a:	6f 5f       	subi	r22, 0xFF	; 255
    103c:	7f 4f       	sbci	r23, 0xFF	; 255
    103e:	80 91 4a 21 	lds	r24, 0x214A	; 0x80214a <SemaRx>
    1042:	90 91 4b 21 	lds	r25, 0x214B	; 0x80214b <SemaRx+0x1>
    1046:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <xQueueGiveFromISR>

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
    104a:	89 81       	ldd	r24, Y+1	; 0x01
    104c:	88 23       	and	r24, r24
    104e:	99 f0       	breq	.+38     	; 0x1076 <__vector_46+0x94>
    1050:	0e 94 3f 0b 	call	0x167e	; 0x167e <vPortYieldISR>
	}
}
    1054:	10 c0       	rjmp	.+32     	; 0x1076 <__vector_46+0x94>
	}
}

void TWIMArbitrationLostBusErrorHandler()
{
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    1056:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
    105a:	82 fd       	sbrc	r24, 2
    105c:	22 c0       	rjmp	.+68     	; 0x10a2 <__vector_46+0xc0>
		Twim_result = TWIM_RESULT_BUS_ERROR;
	}
	/* If arbitration lost. */
	else {
		Twim_result = TWIM_RESULT_ARBITRATION_LOST;
    105e:	93 e0       	ldi	r25, 0x03	; 3
    1060:	90 93 4c 21 	sts	0x214C, r25	; 0x80214c <Twim_result>
	}

	/* Clear interrupt flag. */
	TWIM_BUS.MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
    1064:	88 60       	ori	r24, 0x08	; 8
    1066:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	Twim_status = TWIM_STATUS_READY;
    106a:	10 92 4d 21 	sts	0x214D, r1	; 0x80214d <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    106e:	80 91 4d 21 	lds	r24, 0x214D	; 0x80214d <Twim_status>
    1072:	88 23       	and	r24, r24
    1074:	09 f3       	breq	.-62     	; 0x1038 <__vector_46+0x56>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
	}
}
    1076:	0f 90       	pop	r0
    1078:	df 91       	pop	r29
    107a:	cf 91       	pop	r28
    107c:	ff 91       	pop	r31
    107e:	ef 91       	pop	r30
    1080:	bf 91       	pop	r27
    1082:	af 91       	pop	r26
    1084:	9f 91       	pop	r25
    1086:	8f 91       	pop	r24
    1088:	7f 91       	pop	r23
    108a:	6f 91       	pop	r22
    108c:	5f 91       	pop	r21
    108e:	4f 91       	pop	r20
    1090:	3f 91       	pop	r19
    1092:	2f 91       	pop	r18
    1094:	0f 90       	pop	r0
    1096:	0b be       	out	0x3b, r0	; 59
    1098:	0f 90       	pop	r0
    109a:	0f be       	out	0x3f, r0	; 63
    109c:	0f 90       	pop	r0
    109e:	1f 90       	pop	r1
    10a0:	18 95       	reti
{
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
		Twim_result = TWIM_RESULT_BUS_ERROR;
    10a2:	94 e0       	ldi	r25, 0x04	; 4
    10a4:	90 93 4c 21 	sts	0x214C, r25	; 0x80214c <Twim_result>
    10a8:	dd cf       	rjmp	.-70     	; 0x1064 <__vector_46+0x82>
		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
		TWIMWriteHandler();
    10aa:	0e 94 83 07 	call	0xf06	; 0xf06 <TWIMWriteHandler>
    10ae:	df cf       	rjmp	.-66     	; 0x106e <__vector_46+0x8c>
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
		TWIMReadHandler();
    10b0:	0e 94 bc 07 	call	0xf78	; 0xf78 <TWIMReadHandler>
    10b4:	dc cf       	rjmp	.-72     	; 0x106e <__vector_46+0x8c>

000010b6 <__vector_60>:
}



ISR(USART_TXC_vect)
{
    10b6:	1f 92       	push	r1
    10b8:	0f 92       	push	r0
    10ba:	0f b6       	in	r0, 0x3f	; 63
    10bc:	0f 92       	push	r0
    10be:	11 24       	eor	r1, r1
    10c0:	0b b6       	in	r0, 0x3b	; 59
    10c2:	0f 92       	push	r0
    10c4:	2f 93       	push	r18
    10c6:	3f 93       	push	r19
    10c8:	4f 93       	push	r20
    10ca:	5f 93       	push	r21
    10cc:	6f 93       	push	r22
    10ce:	7f 93       	push	r23
    10d0:	8f 93       	push	r24
    10d2:	9f 93       	push	r25
    10d4:	af 93       	push	r26
    10d6:	bf 93       	push	r27
    10d8:	ef 93       	push	r30
    10da:	ff 93       	push	r31
    10dc:	cf 93       	push	r28
    10de:	df 93       	push	r29
    10e0:	1f 92       	push	r1
    10e2:	1f 92       	push	r1
    10e4:	cd b7       	in	r28, 0x3d	; 61
    10e6:	de b7       	in	r29, 0x3e	; 62
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    10e8:	19 82       	std	Y+1, r1	; 0x01
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
    10ea:	ae 01       	movw	r20, r28
    10ec:	4f 5f       	subi	r20, 0xFF	; 255
    10ee:	5f 4f       	sbci	r21, 0xFF	; 255
    10f0:	be 01       	movw	r22, r28
    10f2:	6e 5f       	subi	r22, 0xFE	; 254
    10f4:	7f 4f       	sbci	r23, 0xFF	; 255
    10f6:	80 91 1e 22 	lds	r24, 0x221E	; 0x80221e <UsartTxQueue>
    10fa:	90 91 1f 22 	lds	r25, 0x221F	; 0x80221f <UsartTxQueue+0x1>
    10fe:	0e 94 7d 11 	call	0x22fa	; 0x22fa <xQueueReceiveFromISR>
    1102:	81 30       	cpi	r24, 0x01	; 1
    1104:	d9 f0       	breq	.+54     	; 0x113c <__vector_60+0x86>
	{
		USART.DATA=c;	
	}
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    1106:	89 81       	ldd	r24, Y+1	; 0x01
    1108:	81 11       	cpse	r24, r1
    110a:	0e 94 3f 0b 	call	0x167e	; 0x167e <vPortYieldISR>
}
    110e:	0f 90       	pop	r0
    1110:	0f 90       	pop	r0
    1112:	df 91       	pop	r29
    1114:	cf 91       	pop	r28
    1116:	ff 91       	pop	r31
    1118:	ef 91       	pop	r30
    111a:	bf 91       	pop	r27
    111c:	af 91       	pop	r26
    111e:	9f 91       	pop	r25
    1120:	8f 91       	pop	r24
    1122:	7f 91       	pop	r23
    1124:	6f 91       	pop	r22
    1126:	5f 91       	pop	r21
    1128:	4f 91       	pop	r20
    112a:	3f 91       	pop	r19
    112c:	2f 91       	pop	r18
    112e:	0f 90       	pop	r0
    1130:	0b be       	out	0x3b, r0	; 59
    1132:	0f 90       	pop	r0
    1134:	0f be       	out	0x3f, r0	; 63
    1136:	0f 90       	pop	r0
    1138:	1f 90       	pop	r1
    113a:	18 95       	reti
{
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
	{
		USART.DATA=c;	
    113c:	8a 81       	ldd	r24, Y+2	; 0x02
    113e:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    1142:	e1 cf       	rjmp	.-62     	; 0x1106 <__vector_60+0x50>

00001144 <__vector_58>:
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

ISR(USART_RXC_vect)
{
    1144:	1f 92       	push	r1
    1146:	0f 92       	push	r0
    1148:	0f b6       	in	r0, 0x3f	; 63
    114a:	0f 92       	push	r0
    114c:	11 24       	eor	r1, r1
    114e:	0b b6       	in	r0, 0x3b	; 59
    1150:	0f 92       	push	r0
    1152:	2f 93       	push	r18
    1154:	3f 93       	push	r19
    1156:	4f 93       	push	r20
    1158:	5f 93       	push	r21
    115a:	6f 93       	push	r22
    115c:	7f 93       	push	r23
    115e:	8f 93       	push	r24
    1160:	9f 93       	push	r25
    1162:	af 93       	push	r26
    1164:	bf 93       	push	r27
    1166:	ef 93       	push	r30
    1168:	ff 93       	push	r31
    116a:	cf 93       	push	r28
    116c:	df 93       	push	r29
    116e:	1f 92       	push	r1
    1170:	1f 92       	push	r1
    1172:	cd b7       	in	r28, 0x3d	; 61
    1174:	de b7       	in	r29, 0x3e	; 62
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    1176:	19 82       	std	Y+1, r1	; 0x01
	
	c=USART.DATA;
    1178:	80 91 a0 0a 	lds	r24, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    117c:	8a 83       	std	Y+2, r24	; 0x02
	xQueueSendToBackFromISR(UsartRxQueue,&c,&xHigherPriorityTaskWoken);
    117e:	20 e0       	ldi	r18, 0x00	; 0
    1180:	ae 01       	movw	r20, r28
    1182:	4f 5f       	subi	r20, 0xFF	; 255
    1184:	5f 4f       	sbci	r21, 0xFF	; 255
    1186:	be 01       	movw	r22, r28
    1188:	6e 5f       	subi	r22, 0xFE	; 254
    118a:	7f 4f       	sbci	r23, 0xFF	; 255
    118c:	80 91 1c 22 	lds	r24, 0x221C	; 0x80221c <UsartRxQueue>
    1190:	90 91 1d 22 	lds	r25, 0x221D	; 0x80221d <UsartRxQueue+0x1>
    1194:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <xQueueGenericSendFromISR>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    1198:	89 81       	ldd	r24, Y+1	; 0x01
    119a:	81 11       	cpse	r24, r1
    119c:	0e 94 3f 0b 	call	0x167e	; 0x167e <vPortYieldISR>
	
    11a0:	0f 90       	pop	r0
    11a2:	0f 90       	pop	r0
    11a4:	df 91       	pop	r29
    11a6:	cf 91       	pop	r28
    11a8:	ff 91       	pop	r31
    11aa:	ef 91       	pop	r30
    11ac:	bf 91       	pop	r27
    11ae:	af 91       	pop	r26
    11b0:	9f 91       	pop	r25
    11b2:	8f 91       	pop	r24
    11b4:	7f 91       	pop	r23
    11b6:	6f 91       	pop	r22
    11b8:	5f 91       	pop	r21
    11ba:	4f 91       	pop	r20
    11bc:	3f 91       	pop	r19
    11be:	2f 91       	pop	r18
    11c0:	0f 90       	pop	r0
    11c2:	0b be       	out	0x3b, r0	; 59
    11c4:	0f 90       	pop	r0
    11c6:	0f be       	out	0x3f, r0	; 63
    11c8:	0f 90       	pop	r0
    11ca:	1f 90       	pop	r1
    11cc:	18 95       	reti

000011ce <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    11ce:	0f 93       	push	r16
    11d0:	1f 93       	push	r17
    11d2:	cf 93       	push	r28
    11d4:	df 93       	push	r29
    11d6:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    11d8:	0e 94 7e 15 	call	0x2afc	; 0x2afc <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    11dc:	80 91 57 21 	lds	r24, 0x2157	; 0x802157 <xHeapHasBeenInitialised.4135>
    11e0:	81 11       	cpse	r24, r1
    11e2:	21 c0       	rjmp	.+66     	; 0x1226 <pvPortMalloc+0x58>
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    11e4:	e0 91 24 22 	lds	r30, 0x2224	; 0x802224 <ucHeap>
    11e8:	f0 91 25 22 	lds	r31, 0x2225	; 0x802225 <ucHeap+0x1>

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    11ec:	cf 01       	movw	r24, r30
    11ee:	01 96       	adiw	r24, 0x01	; 1
    11f0:	80 93 5c 21 	sts	0x215C, r24	; 0x80215c <xStart>
    11f4:	90 93 5d 21 	sts	0x215D, r25	; 0x80215d <xStart+0x1>
	xStart.xBlockSize = ( size_t ) 0;
    11f8:	10 92 5e 21 	sts	0x215E, r1	; 0x80215e <xStart+0x2>
    11fc:	10 92 5f 21 	sts	0x215F, r1	; 0x80215f <xStart+0x3>

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    1200:	8f ef       	ldi	r24, 0xFF	; 255
    1202:	9f e3       	ldi	r25, 0x3F	; 63
    1204:	80 93 5a 21 	sts	0x215A, r24	; 0x80215a <xEnd+0x2>
    1208:	90 93 5b 21 	sts	0x215B, r25	; 0x80215b <xEnd+0x3>
	xEnd.pxNextFreeBlock = NULL;
    120c:	10 92 58 21 	sts	0x2158, r1	; 0x802158 <xEnd>
    1210:	10 92 59 21 	sts	0x2159, r1	; 0x802159 <xEnd+0x1>

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    1214:	83 83       	std	Z+3, r24	; 0x03
    1216:	94 83       	std	Z+4, r25	; 0x04
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    1218:	88 e5       	ldi	r24, 0x58	; 88
    121a:	91 e2       	ldi	r25, 0x21	; 33
    121c:	81 83       	std	Z+1, r24	; 0x01
    121e:	92 83       	std	Z+2, r25	; 0x02
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	80 93 57 21 	sts	0x2157, r24	; 0x802157 <xHeapHasBeenInitialised.4135>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1226:	20 97       	sbiw	r28, 0x00	; 0
    1228:	09 f4       	brne	.+2      	; 0x122c <pvPortMalloc+0x5e>
    122a:	64 c0       	rjmp	.+200    	; 0x12f4 <pvPortMalloc+0x126>
		{
			xWantedSize += heapSTRUCT_SIZE;
    122c:	ae 01       	movw	r20, r28
    122e:	4c 5f       	subi	r20, 0xFC	; 252
    1230:	5f 4f       	sbci	r21, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    1232:	23 96       	adiw	r28, 0x03	; 3
    1234:	ce 3f       	cpi	r28, 0xFE	; 254
    1236:	df 43       	sbci	r29, 0x3F	; 63
    1238:	08 f0       	brcs	.+2      	; 0x123c <pvPortMalloc+0x6e>
    123a:	5c c0       	rjmp	.+184    	; 0x12f4 <pvPortMalloc+0x126>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    123c:	e0 91 5c 21 	lds	r30, 0x215C	; 0x80215c <xStart>
    1240:	f0 91 5d 21 	lds	r31, 0x215D	; 0x80215d <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1244:	ac e5       	ldi	r26, 0x5C	; 92
    1246:	b1 e2       	ldi	r27, 0x21	; 33
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1248:	06 c0       	rjmp	.+12     	; 0x1256 <pvPortMalloc+0x88>
    124a:	80 81       	ld	r24, Z
    124c:	91 81       	ldd	r25, Z+1	; 0x01
    124e:	00 97       	sbiw	r24, 0x00	; 0
    1250:	39 f0       	breq	.+14     	; 0x1260 <pvPortMalloc+0x92>
    1252:	df 01       	movw	r26, r30
    1254:	fc 01       	movw	r30, r24
    1256:	22 81       	ldd	r18, Z+2	; 0x02
    1258:	33 81       	ldd	r19, Z+3	; 0x03
    125a:	24 17       	cp	r18, r20
    125c:	35 07       	cpc	r19, r21
    125e:	a8 f3       	brcs	.-22     	; 0x124a <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1260:	c1 e2       	ldi	r28, 0x21	; 33
    1262:	e8 35       	cpi	r30, 0x58	; 88
    1264:	fc 07       	cpc	r31, r28
    1266:	09 f4       	brne	.+2      	; 0x126a <pvPortMalloc+0x9c>
    1268:	45 c0       	rjmp	.+138    	; 0x12f4 <pvPortMalloc+0x126>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    126a:	cd 91       	ld	r28, X+
    126c:	dc 91       	ld	r29, X
    126e:	11 97       	sbiw	r26, 0x01	; 1
    1270:	8e 01       	movw	r16, r28
    1272:	0c 5f       	subi	r16, 0xFC	; 252
    1274:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1276:	80 81       	ld	r24, Z
    1278:	91 81       	ldd	r25, Z+1	; 0x01
    127a:	8d 93       	st	X+, r24
    127c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    127e:	c9 01       	movw	r24, r18
    1280:	84 1b       	sub	r24, r20
    1282:	95 0b       	sbc	r25, r21
    1284:	89 30       	cpi	r24, 0x09	; 9
    1286:	91 05       	cpc	r25, r1
    1288:	00 f1       	brcs	.+64     	; 0x12ca <pvPortMalloc+0xfc>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    128a:	bf 01       	movw	r22, r30
    128c:	64 0f       	add	r22, r20
    128e:	75 1f       	adc	r23, r21

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1290:	db 01       	movw	r26, r22
    1292:	12 96       	adiw	r26, 0x02	; 2
    1294:	8d 93       	st	X+, r24
    1296:	9c 93       	st	X, r25
    1298:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    129a:	42 83       	std	Z+2, r20	; 0x02
    129c:	53 83       	std	Z+3, r21	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    129e:	12 96       	adiw	r26, 0x02	; 2
    12a0:	2d 91       	ld	r18, X+
    12a2:	3c 91       	ld	r19, X
    12a4:	13 97       	sbiw	r26, 0x03	; 3
    12a6:	ac e5       	ldi	r26, 0x5C	; 92
    12a8:	b1 e2       	ldi	r27, 0x21	; 33
    12aa:	01 c0       	rjmp	.+2      	; 0x12ae <pvPortMalloc+0xe0>
    12ac:	df 01       	movw	r26, r30
    12ae:	ed 91       	ld	r30, X+
    12b0:	fc 91       	ld	r31, X
    12b2:	11 97       	sbiw	r26, 0x01	; 1
    12b4:	82 81       	ldd	r24, Z+2	; 0x02
    12b6:	93 81       	ldd	r25, Z+3	; 0x03
    12b8:	82 17       	cp	r24, r18
    12ba:	93 07       	cpc	r25, r19
    12bc:	b8 f3       	brcs	.-18     	; 0x12ac <pvPortMalloc+0xde>
    12be:	eb 01       	movw	r28, r22
    12c0:	e8 83       	st	Y, r30
    12c2:	f9 83       	std	Y+1, r31	; 0x01
    12c4:	6d 93       	st	X+, r22
    12c6:	7c 93       	st	X, r23

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
		{
			xWantedSize += heapSTRUCT_SIZE;
    12c8:	9a 01       	movw	r18, r20

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    12ca:	80 91 06 20 	lds	r24, 0x2006	; 0x802006 <xFreeBytesRemaining>
    12ce:	90 91 07 20 	lds	r25, 0x2007	; 0x802007 <xFreeBytesRemaining+0x1>
    12d2:	82 1b       	sub	r24, r18
    12d4:	93 0b       	sbc	r25, r19
    12d6:	80 93 06 20 	sts	0x2006, r24	; 0x802006 <xFreeBytesRemaining>
    12da:	90 93 07 20 	sts	0x2007, r25	; 0x802007 <xFreeBytesRemaining+0x1>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    12de:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    12e2:	01 15       	cp	r16, r1
    12e4:	11 05       	cpc	r17, r1
    12e6:	41 f0       	breq	.+16     	; 0x12f8 <pvPortMalloc+0x12a>
		}
	}
	#endif

	return pvReturn;
}
    12e8:	c8 01       	movw	r24, r16
    12ea:	df 91       	pop	r29
    12ec:	cf 91       	pop	r28
    12ee:	1f 91       	pop	r17
    12f0:	0f 91       	pop	r16
    12f2:	08 95       	ret
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    12f4:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    12f8:	0e 94 a5 19 	call	0x334a	; 0x334a <vApplicationMallocFailedHook>
    12fc:	00 e0       	ldi	r16, 0x00	; 0
    12fe:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    1300:	c8 01       	movw	r24, r16
    1302:	df 91       	pop	r29
    1304:	cf 91       	pop	r28
    1306:	1f 91       	pop	r17
    1308:	0f 91       	pop	r16
    130a:	08 95       	ret

0000130c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    1310:	00 97       	sbiw	r24, 0x00	; 0
    1312:	21 f1       	breq	.+72     	; 0x135c <vPortFree+0x50>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1314:	ec 01       	movw	r28, r24
    1316:	24 97       	sbiw	r28, 0x04	; 4

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1318:	0e 94 7e 15 	call	0x2afc	; 0x2afc <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    131c:	4a 81       	ldd	r20, Y+2	; 0x02
    131e:	5b 81       	ldd	r21, Y+3	; 0x03
    1320:	ac e5       	ldi	r26, 0x5C	; 92
    1322:	b1 e2       	ldi	r27, 0x21	; 33
    1324:	01 c0       	rjmp	.+2      	; 0x1328 <vPortFree+0x1c>
    1326:	df 01       	movw	r26, r30
    1328:	ed 91       	ld	r30, X+
    132a:	fc 91       	ld	r31, X
    132c:	11 97       	sbiw	r26, 0x01	; 1
    132e:	22 81       	ldd	r18, Z+2	; 0x02
    1330:	33 81       	ldd	r19, Z+3	; 0x03
    1332:	24 17       	cp	r18, r20
    1334:	35 07       	cpc	r19, r21
    1336:	b8 f3       	brcs	.-18     	; 0x1326 <vPortFree+0x1a>
    1338:	e8 83       	st	Y, r30
    133a:	f9 83       	std	Y+1, r31	; 0x01
    133c:	cd 93       	st	X+, r28
    133e:	dc 93       	st	X, r29
			xFreeBytesRemaining += pxLink->xBlockSize;
    1340:	80 91 06 20 	lds	r24, 0x2006	; 0x802006 <xFreeBytesRemaining>
    1344:	90 91 07 20 	lds	r25, 0x2007	; 0x802007 <xFreeBytesRemaining+0x1>
    1348:	48 0f       	add	r20, r24
    134a:	59 1f       	adc	r21, r25
    134c:	40 93 06 20 	sts	0x2006, r20	; 0x802006 <xFreeBytesRemaining>
    1350:	50 93 07 20 	sts	0x2007, r21	; 0x802007 <xFreeBytesRemaining+0x1>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
	}
}
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
			xFreeBytesRemaining += pxLink->xBlockSize;
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    1358:	0c 94 68 16 	jmp	0x2cd0	; 0x2cd0 <xTaskResumeAll>
	}
}
    135c:	df 91       	pop	r29
    135e:	cf 91       	pop	r28
    1360:	08 95       	ret

00001362 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1362:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1364:	03 96       	adiw	r24, 0x03	; 3
    1366:	81 83       	std	Z+1, r24	; 0x01
    1368:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    136a:	2f ef       	ldi	r18, 0xFF	; 255
    136c:	3f ef       	ldi	r19, 0xFF	; 255
    136e:	23 83       	std	Z+3, r18	; 0x03
    1370:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1372:	85 83       	std	Z+5, r24	; 0x05
    1374:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1376:	87 83       	std	Z+7, r24	; 0x07
    1378:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    137a:	10 82       	st	Z, r1
    137c:	08 95       	ret

0000137e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    137e:	fc 01       	movw	r30, r24
    1380:	10 86       	std	Z+8, r1	; 0x08
    1382:	11 86       	std	Z+9, r1	; 0x09
    1384:	08 95       	ret

00001386 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1386:	cf 93       	push	r28
    1388:	df 93       	push	r29
    138a:	9c 01       	movw	r18, r24
    138c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    138e:	dc 01       	movw	r26, r24
    1390:	11 96       	adiw	r26, 0x01	; 1
    1392:	cd 91       	ld	r28, X+
    1394:	dc 91       	ld	r29, X
    1396:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1398:	c2 83       	std	Z+2, r28	; 0x02
    139a:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    139c:	8c 81       	ldd	r24, Y+4	; 0x04
    139e:	9d 81       	ldd	r25, Y+5	; 0x05
    13a0:	84 83       	std	Z+4, r24	; 0x04
    13a2:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    13a4:	8c 81       	ldd	r24, Y+4	; 0x04
    13a6:	9d 81       	ldd	r25, Y+5	; 0x05
    13a8:	dc 01       	movw	r26, r24
    13aa:	12 96       	adiw	r26, 0x02	; 2
    13ac:	6d 93       	st	X+, r22
    13ae:	7c 93       	st	X, r23
    13b0:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    13b2:	6c 83       	std	Y+4, r22	; 0x04
    13b4:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    13b6:	20 87       	std	Z+8, r18	; 0x08
    13b8:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    13ba:	f9 01       	movw	r30, r18
    13bc:	80 81       	ld	r24, Z
    13be:	8f 5f       	subi	r24, 0xFF	; 255
    13c0:	80 83       	st	Z, r24
}
    13c2:	df 91       	pop	r29
    13c4:	cf 91       	pop	r28
    13c6:	08 95       	ret

000013c8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    13c8:	cf 93       	push	r28
    13ca:	df 93       	push	r29
    13cc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    13ce:	48 81       	ld	r20, Y
    13d0:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    13d2:	4f 3f       	cpi	r20, 0xFF	; 255
    13d4:	2f ef       	ldi	r18, 0xFF	; 255
    13d6:	52 07       	cpc	r21, r18
    13d8:	01 f1       	breq	.+64     	; 0x141a <vListInsert+0x52>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    13da:	dc 01       	movw	r26, r24
    13dc:	13 96       	adiw	r26, 0x03	; 3
    13de:	01 c0       	rjmp	.+2      	; 0x13e2 <vListInsert+0x1a>
    13e0:	df 01       	movw	r26, r30
    13e2:	12 96       	adiw	r26, 0x02	; 2
    13e4:	ed 91       	ld	r30, X+
    13e6:	fc 91       	ld	r31, X
    13e8:	13 97       	sbiw	r26, 0x03	; 3
    13ea:	20 81       	ld	r18, Z
    13ec:	31 81       	ldd	r19, Z+1	; 0x01
    13ee:	42 17       	cp	r20, r18
    13f0:	53 07       	cpc	r21, r19
    13f2:	b0 f7       	brcc	.-20     	; 0x13e0 <vListInsert+0x18>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    13f4:	ea 83       	std	Y+2, r30	; 0x02
    13f6:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    13f8:	c4 83       	std	Z+4, r28	; 0x04
    13fa:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    13fc:	ac 83       	std	Y+4, r26	; 0x04
    13fe:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1400:	12 96       	adiw	r26, 0x02	; 2
    1402:	cd 93       	st	X+, r28
    1404:	dc 93       	st	X, r29
    1406:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1408:	88 87       	std	Y+8, r24	; 0x08
    140a:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    140c:	fc 01       	movw	r30, r24
    140e:	20 81       	ld	r18, Z
    1410:	2f 5f       	subi	r18, 0xFF	; 255
    1412:	20 83       	st	Z, r18
}
    1414:	df 91       	pop	r29
    1416:	cf 91       	pop	r28
    1418:	08 95       	ret
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    141a:	fc 01       	movw	r30, r24
    141c:	a7 81       	ldd	r26, Z+7	; 0x07
    141e:	b0 85       	ldd	r27, Z+8	; 0x08
    1420:	12 96       	adiw	r26, 0x02	; 2
    1422:	ed 91       	ld	r30, X+
    1424:	fc 91       	ld	r31, X
    1426:	13 97       	sbiw	r26, 0x03	; 3
    1428:	e5 cf       	rjmp	.-54     	; 0x13f4 <vListInsert+0x2c>

0000142a <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    142a:	cf 93       	push	r28
    142c:	df 93       	push	r29
    142e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1430:	a0 85       	ldd	r26, Z+8	; 0x08
    1432:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1434:	22 81       	ldd	r18, Z+2	; 0x02
    1436:	33 81       	ldd	r19, Z+3	; 0x03
    1438:	84 81       	ldd	r24, Z+4	; 0x04
    143a:	95 81       	ldd	r25, Z+5	; 0x05
    143c:	e9 01       	movw	r28, r18
    143e:	8c 83       	std	Y+4, r24	; 0x04
    1440:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1442:	84 81       	ldd	r24, Z+4	; 0x04
    1444:	95 81       	ldd	r25, Z+5	; 0x05
    1446:	ec 01       	movw	r28, r24
    1448:	2a 83       	std	Y+2, r18	; 0x02
    144a:	3b 83       	std	Y+3, r19	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    144c:	11 96       	adiw	r26, 0x01	; 1
    144e:	2d 91       	ld	r18, X+
    1450:	3c 91       	ld	r19, X
    1452:	12 97       	sbiw	r26, 0x02	; 2
    1454:	e2 17       	cp	r30, r18
    1456:	f3 07       	cpc	r31, r19
    1458:	49 f0       	breq	.+18     	; 0x146c <uxListRemove+0x42>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    145a:	10 86       	std	Z+8, r1	; 0x08
    145c:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    145e:	8c 91       	ld	r24, X
    1460:	81 50       	subi	r24, 0x01	; 1
    1462:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1464:	8c 91       	ld	r24, X
}
    1466:	df 91       	pop	r29
    1468:	cf 91       	pop	r28
    146a:	08 95       	ret
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    146c:	11 96       	adiw	r26, 0x01	; 1
    146e:	8d 93       	st	X+, r24
    1470:	9c 93       	st	X, r25
    1472:	12 97       	sbiw	r26, 0x02	; 2
    1474:	f2 cf       	rjmp	.-28     	; 0x145a <uxListRemove+0x30>

00001476 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1476:	31 e1       	ldi	r19, 0x11	; 17
    1478:	fc 01       	movw	r30, r24
    147a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    147c:	31 97       	sbiw	r30, 0x01	; 1
    147e:	22 e2       	ldi	r18, 0x22	; 34
    1480:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1482:	31 97       	sbiw	r30, 0x01	; 1
    1484:	a3 e3       	ldi	r26, 0x33	; 51
    1486:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1488:	31 97       	sbiw	r30, 0x01	; 1
    148a:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    148c:	31 97       	sbiw	r30, 0x01	; 1
    148e:	70 83       	st	Z, r23
	pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__) && __AVR_3_BYTE_PC__   //MCU's with more than 128kB of program memory: PC is 3 bytes
	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1490:	31 97       	sbiw	r30, 0x01	; 1
    1492:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1494:	31 97       	sbiw	r30, 0x01	; 1
    1496:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1498:	31 97       	sbiw	r30, 0x01	; 1
    149a:	60 e8       	ldi	r22, 0x80	; 128
    149c:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    149e:	31 97       	sbiw	r30, 0x01	; 1
    14a0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    14a2:	31 97       	sbiw	r30, 0x01	; 1
    14a4:	62 e0       	ldi	r22, 0x02	; 2
    14a6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    14a8:	31 97       	sbiw	r30, 0x01	; 1
    14aa:	63 e0       	ldi	r22, 0x03	; 3
    14ac:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    14ae:	31 97       	sbiw	r30, 0x01	; 1
    14b0:	64 e0       	ldi	r22, 0x04	; 4
    14b2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    14b4:	31 97       	sbiw	r30, 0x01	; 1
    14b6:	65 e0       	ldi	r22, 0x05	; 5
    14b8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    14ba:	31 97       	sbiw	r30, 0x01	; 1
    14bc:	66 e0       	ldi	r22, 0x06	; 6
    14be:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    14c0:	31 97       	sbiw	r30, 0x01	; 1
    14c2:	67 e0       	ldi	r22, 0x07	; 7
    14c4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    14c6:	31 97       	sbiw	r30, 0x01	; 1
    14c8:	68 e0       	ldi	r22, 0x08	; 8
    14ca:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    14cc:	31 97       	sbiw	r30, 0x01	; 1
    14ce:	69 e0       	ldi	r22, 0x09	; 9
    14d0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    14d2:	31 97       	sbiw	r30, 0x01	; 1
    14d4:	60 e1       	ldi	r22, 0x10	; 16
    14d6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    14d8:	31 97       	sbiw	r30, 0x01	; 1
    14da:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    14dc:	31 97       	sbiw	r30, 0x01	; 1
    14de:	32 e1       	ldi	r19, 0x12	; 18
    14e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    14e2:	31 97       	sbiw	r30, 0x01	; 1
    14e4:	33 e1       	ldi	r19, 0x13	; 19
    14e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    14e8:	31 97       	sbiw	r30, 0x01	; 1
    14ea:	34 e1       	ldi	r19, 0x14	; 20
    14ec:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    14ee:	31 97       	sbiw	r30, 0x01	; 1
    14f0:	35 e1       	ldi	r19, 0x15	; 21
    14f2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    14f4:	31 97       	sbiw	r30, 0x01	; 1
    14f6:	36 e1       	ldi	r19, 0x16	; 22
    14f8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    14fa:	31 97       	sbiw	r30, 0x01	; 1
    14fc:	37 e1       	ldi	r19, 0x17	; 23
    14fe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1500:	31 97       	sbiw	r30, 0x01	; 1
    1502:	38 e1       	ldi	r19, 0x18	; 24
    1504:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1506:	31 97       	sbiw	r30, 0x01	; 1
    1508:	39 e1       	ldi	r19, 0x19	; 25
    150a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    150c:	31 97       	sbiw	r30, 0x01	; 1
    150e:	30 e2       	ldi	r19, 0x20	; 32
    1510:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1512:	31 97       	sbiw	r30, 0x01	; 1
    1514:	31 e2       	ldi	r19, 0x21	; 33
    1516:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1518:	31 97       	sbiw	r30, 0x01	; 1
    151a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    151c:	31 97       	sbiw	r30, 0x01	; 1
    151e:	23 e2       	ldi	r18, 0x23	; 35
    1520:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1522:	31 97       	sbiw	r30, 0x01	; 1
    1524:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1526:	31 97       	sbiw	r30, 0x01	; 1
    1528:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    152a:	31 97       	sbiw	r30, 0x01	; 1
    152c:	26 e2       	ldi	r18, 0x26	; 38
    152e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1530:	31 97       	sbiw	r30, 0x01	; 1
    1532:	27 e2       	ldi	r18, 0x27	; 39
    1534:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1536:	31 97       	sbiw	r30, 0x01	; 1
    1538:	28 e2       	ldi	r18, 0x28	; 40
    153a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    153c:	31 97       	sbiw	r30, 0x01	; 1
    153e:	29 e2       	ldi	r18, 0x29	; 41
    1540:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1542:	31 97       	sbiw	r30, 0x01	; 1
    1544:	20 e3       	ldi	r18, 0x30	; 48
    1546:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1548:	31 97       	sbiw	r30, 0x01	; 1
    154a:	21 e3       	ldi	r18, 0x31	; 49
    154c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    154e:	87 97       	sbiw	r24, 0x27	; 39
    1550:	08 95       	ret

00001552 <xPortStartScheduler>:
 */

static void prvSetupTimerInterrupt( void )
{
	//TCC0 is used as tick timer
	TCC0.CCA=65535;
    1552:	e0 e0       	ldi	r30, 0x00	; 0
    1554:	f8 e0       	ldi	r31, 0x08	; 8
    1556:	8f ef       	ldi	r24, 0xFF	; 255
    1558:	9f ef       	ldi	r25, 0xFF	; 255
    155a:	80 a7       	std	Z+40, r24	; 0x28
    155c:	91 a7       	std	Z+41, r25	; 0x29
	TCC0.CTRLA=0b00000001; //DIV1
    155e:	81 e0       	ldi	r24, 0x01	; 1
    1560:	80 83       	st	Z, r24
	TCC0.CTRLB=1<<6;
    1562:	90 e4       	ldi	r25, 0x40	; 64
    1564:	91 83       	std	Z+1, r25	; 0x01
	TCC0.INTCTRLA=0b00000001; //OVF priority LOW
    1566:	86 83       	std	Z+6, r24	; 0x06
	TCC0.INTCTRLB=0b00000001; //CCA priority LOW
    1568:	87 83       	std	Z+7, r24	; 0x07
	TCC0.PER=configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    156a:	80 e0       	ldi	r24, 0x00	; 0
    156c:	9d e7       	ldi	r25, 0x7D	; 125
    156e:	86 a3       	std	Z+38, r24	; 0x26
    1570:	97 a3       	std	Z+39, r25	; 0x27
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1572:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    1576:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    157a:	cd 91       	ld	r28, X+
    157c:	cd bf       	out	0x3d, r28	; 61
    157e:	dd 91       	ld	r29, X+
    1580:	de bf       	out	0x3e, r29	; 62
    1582:	ff 91       	pop	r31
    1584:	ef 91       	pop	r30
    1586:	df 91       	pop	r29
    1588:	cf 91       	pop	r28
    158a:	bf 91       	pop	r27
    158c:	af 91       	pop	r26
    158e:	9f 91       	pop	r25
    1590:	8f 91       	pop	r24
    1592:	7f 91       	pop	r23
    1594:	6f 91       	pop	r22
    1596:	5f 91       	pop	r21
    1598:	4f 91       	pop	r20
    159a:	3f 91       	pop	r19
    159c:	2f 91       	pop	r18
    159e:	1f 91       	pop	r17
    15a0:	0f 91       	pop	r16
    15a2:	ff 90       	pop	r15
    15a4:	ef 90       	pop	r14
    15a6:	df 90       	pop	r13
    15a8:	cf 90       	pop	r12
    15aa:	bf 90       	pop	r11
    15ac:	af 90       	pop	r10
    15ae:	9f 90       	pop	r9
    15b0:	8f 90       	pop	r8
    15b2:	7f 90       	pop	r7
    15b4:	6f 90       	pop	r6
    15b6:	5f 90       	pop	r5
    15b8:	4f 90       	pop	r4
    15ba:	3f 90       	pop	r3
    15bc:	2f 90       	pop	r2
    15be:	1f 90       	pop	r1
    15c0:	0f 90       	pop	r0
    15c2:	0f be       	out	0x3f, r0	; 63
    15c4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    15c6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    15c8:	81 e0       	ldi	r24, 0x01	; 1
    15ca:	08 95       	ret

000015cc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    15cc:	0f 92       	push	r0
    15ce:	0f b6       	in	r0, 0x3f	; 63
    15d0:	f8 94       	cli
    15d2:	0f 92       	push	r0
    15d4:	1f 92       	push	r1
    15d6:	11 24       	eor	r1, r1
    15d8:	2f 92       	push	r2
    15da:	3f 92       	push	r3
    15dc:	4f 92       	push	r4
    15de:	5f 92       	push	r5
    15e0:	6f 92       	push	r6
    15e2:	7f 92       	push	r7
    15e4:	8f 92       	push	r8
    15e6:	9f 92       	push	r9
    15e8:	af 92       	push	r10
    15ea:	bf 92       	push	r11
    15ec:	cf 92       	push	r12
    15ee:	df 92       	push	r13
    15f0:	ef 92       	push	r14
    15f2:	ff 92       	push	r15
    15f4:	0f 93       	push	r16
    15f6:	1f 93       	push	r17
    15f8:	2f 93       	push	r18
    15fa:	3f 93       	push	r19
    15fc:	4f 93       	push	r20
    15fe:	5f 93       	push	r21
    1600:	6f 93       	push	r22
    1602:	7f 93       	push	r23
    1604:	8f 93       	push	r24
    1606:	9f 93       	push	r25
    1608:	af 93       	push	r26
    160a:	bf 93       	push	r27
    160c:	cf 93       	push	r28
    160e:	df 93       	push	r29
    1610:	ef 93       	push	r30
    1612:	ff 93       	push	r31
    1614:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    1618:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    161c:	0d b6       	in	r0, 0x3d	; 61
    161e:	0d 92       	st	X+, r0
    1620:	0e b6       	in	r0, 0x3e	; 62
    1622:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1624:	0e 94 72 17 	call	0x2ee4	; 0x2ee4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1628:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    162c:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    1630:	cd 91       	ld	r28, X+
    1632:	cd bf       	out	0x3d, r28	; 61
    1634:	dd 91       	ld	r29, X+
    1636:	de bf       	out	0x3e, r29	; 62
    1638:	ff 91       	pop	r31
    163a:	ef 91       	pop	r30
    163c:	df 91       	pop	r29
    163e:	cf 91       	pop	r28
    1640:	bf 91       	pop	r27
    1642:	af 91       	pop	r26
    1644:	9f 91       	pop	r25
    1646:	8f 91       	pop	r24
    1648:	7f 91       	pop	r23
    164a:	6f 91       	pop	r22
    164c:	5f 91       	pop	r21
    164e:	4f 91       	pop	r20
    1650:	3f 91       	pop	r19
    1652:	2f 91       	pop	r18
    1654:	1f 91       	pop	r17
    1656:	0f 91       	pop	r16
    1658:	ff 90       	pop	r15
    165a:	ef 90       	pop	r14
    165c:	df 90       	pop	r13
    165e:	cf 90       	pop	r12
    1660:	bf 90       	pop	r11
    1662:	af 90       	pop	r10
    1664:	9f 90       	pop	r9
    1666:	8f 90       	pop	r8
    1668:	7f 90       	pop	r7
    166a:	6f 90       	pop	r6
    166c:	5f 90       	pop	r5
    166e:	4f 90       	pop	r4
    1670:	3f 90       	pop	r3
    1672:	2f 90       	pop	r2
    1674:	1f 90       	pop	r1
    1676:	0f 90       	pop	r0
    1678:	0f be       	out	0x3f, r0	; 63
    167a:	0f 90       	pop	r0
	asm volatile ( "ret" );
    167c:	08 95       	ret

0000167e <vPortYieldISR>:
}*/

//void vPortYieldISR( void ) __attribute__ ( ( naked ) );
void vPortYieldISR( void )
{
	TCC0.CCA=TCC0.CNT+100;
    167e:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    1682:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    1686:	8c 59       	subi	r24, 0x9C	; 156
    1688:	9f 4f       	sbci	r25, 0xFF	; 255
    168a:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    168e:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	if (TCC0.CCA>=TCC0.PER) TCC0.CCA-= TCC0.PER;
    1692:	20 91 28 08 	lds	r18, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1696:	30 91 29 08 	lds	r19, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    169a:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    169e:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    16a2:	28 17       	cp	r18, r24
    16a4:	39 07       	cpc	r19, r25
    16a6:	70 f0       	brcs	.+28     	; 0x16c4 <vPortYieldISR+0x46>
    16a8:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    16ac:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    16b0:	80 91 28 08 	lds	r24, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    16b4:	90 91 29 08 	lds	r25, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    16b8:	82 1b       	sub	r24, r18
    16ba:	93 0b       	sbc	r25, r19
    16bc:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    16c0:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	asm volatile ( "ret" );
    16c4:	08 95       	ret

000016c6 <__vector_14>:
	 * the context is saved at the start of the ISR.  The tick
	 * count is incremented after the context is saved.
	 */	
	ISR(TCC0_OVF_vect,ISR_NAKED)
	{
		portSAVE_CONTEXT();
    16c6:	0f 92       	push	r0
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	0f 92       	push	r0
    16ce:	1f 92       	push	r1
    16d0:	11 24       	eor	r1, r1
    16d2:	2f 92       	push	r2
    16d4:	3f 92       	push	r3
    16d6:	4f 92       	push	r4
    16d8:	5f 92       	push	r5
    16da:	6f 92       	push	r6
    16dc:	7f 92       	push	r7
    16de:	8f 92       	push	r8
    16e0:	9f 92       	push	r9
    16e2:	af 92       	push	r10
    16e4:	bf 92       	push	r11
    16e6:	cf 92       	push	r12
    16e8:	df 92       	push	r13
    16ea:	ef 92       	push	r14
    16ec:	ff 92       	push	r15
    16ee:	0f 93       	push	r16
    16f0:	1f 93       	push	r17
    16f2:	2f 93       	push	r18
    16f4:	3f 93       	push	r19
    16f6:	4f 93       	push	r20
    16f8:	5f 93       	push	r21
    16fa:	6f 93       	push	r22
    16fc:	7f 93       	push	r23
    16fe:	8f 93       	push	r24
    1700:	9f 93       	push	r25
    1702:	af 93       	push	r26
    1704:	bf 93       	push	r27
    1706:	cf 93       	push	r28
    1708:	df 93       	push	r29
    170a:	ef 93       	push	r30
    170c:	ff 93       	push	r31
    170e:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    1712:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    1716:	0d b6       	in	r0, 0x3d	; 61
    1718:	0d 92       	st	X+, r0
    171a:	0e b6       	in	r0, 0x3e	; 62
    171c:	0d 92       	st	X+, r0
		StatsTimer+=TCC0.PER;
    171e:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    1722:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    1726:	80 91 20 22 	lds	r24, 0x2220	; 0x802220 <StatsTimer>
    172a:	90 91 21 22 	lds	r25, 0x2221	; 0x802221 <StatsTimer+0x1>
    172e:	a0 91 22 22 	lds	r26, 0x2222	; 0x802222 <StatsTimer+0x2>
    1732:	b0 91 23 22 	lds	r27, 0x2223	; 0x802223 <StatsTimer+0x3>
    1736:	82 0f       	add	r24, r18
    1738:	93 1f       	adc	r25, r19
    173a:	a1 1d       	adc	r26, r1
    173c:	b1 1d       	adc	r27, r1
    173e:	80 93 20 22 	sts	0x2220, r24	; 0x802220 <StatsTimer>
    1742:	90 93 21 22 	sts	0x2221, r25	; 0x802221 <StatsTimer+0x1>
    1746:	a0 93 22 22 	sts	0x2222, r26	; 0x802222 <StatsTimer+0x2>
    174a:	b0 93 23 22 	sts	0x2223, r27	; 0x802223 <StatsTimer+0x3>
		xTaskIncrementTick();
    174e:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xTaskIncrementTick>
		vTaskSwitchContext();
    1752:	0e 94 72 17 	call	0x2ee4	; 0x2ee4 <vTaskSwitchContext>
		portRESTORE_CONTEXT();
    1756:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    175a:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    175e:	cd 91       	ld	r28, X+
    1760:	cd bf       	out	0x3d, r28	; 61
    1762:	dd 91       	ld	r29, X+
    1764:	de bf       	out	0x3e, r29	; 62
    1766:	ff 91       	pop	r31
    1768:	ef 91       	pop	r30
    176a:	df 91       	pop	r29
    176c:	cf 91       	pop	r28
    176e:	bf 91       	pop	r27
    1770:	af 91       	pop	r26
    1772:	9f 91       	pop	r25
    1774:	8f 91       	pop	r24
    1776:	7f 91       	pop	r23
    1778:	6f 91       	pop	r22
    177a:	5f 91       	pop	r21
    177c:	4f 91       	pop	r20
    177e:	3f 91       	pop	r19
    1780:	2f 91       	pop	r18
    1782:	1f 91       	pop	r17
    1784:	0f 91       	pop	r16
    1786:	ff 90       	pop	r15
    1788:	ef 90       	pop	r14
    178a:	df 90       	pop	r13
    178c:	cf 90       	pop	r12
    178e:	bf 90       	pop	r11
    1790:	af 90       	pop	r10
    1792:	9f 90       	pop	r9
    1794:	8f 90       	pop	r8
    1796:	7f 90       	pop	r7
    1798:	6f 90       	pop	r6
    179a:	5f 90       	pop	r5
    179c:	4f 90       	pop	r4
    179e:	3f 90       	pop	r3
    17a0:	2f 90       	pop	r2
    17a2:	1f 90       	pop	r1
    17a4:	0f 90       	pop	r0
    17a6:	0f be       	out	0x3f, r0	; 63
    17a8:	0f 90       	pop	r0

		asm volatile ( "reti" );
    17aa:	18 95       	reti

000017ac <vConfigureTimerForRunTimeStats>:
 */

volatile uint32_t StatsTimer;

void vConfigureTimerForRunTimeStats(void)
{
    17ac:	08 95       	ret

000017ae <__vector_16>:
	//TCC1.INTCTRLA=0b00000001; //OVF priority LOW
}

ISR(TCC0_CCA_vect,ISR_NAKED)
	{
	portSAVE_CONTEXT();
    17ae:	0f 92       	push	r0
    17b0:	0f b6       	in	r0, 0x3f	; 63
    17b2:	f8 94       	cli
    17b4:	0f 92       	push	r0
    17b6:	1f 92       	push	r1
    17b8:	11 24       	eor	r1, r1
    17ba:	2f 92       	push	r2
    17bc:	3f 92       	push	r3
    17be:	4f 92       	push	r4
    17c0:	5f 92       	push	r5
    17c2:	6f 92       	push	r6
    17c4:	7f 92       	push	r7
    17c6:	8f 92       	push	r8
    17c8:	9f 92       	push	r9
    17ca:	af 92       	push	r10
    17cc:	bf 92       	push	r11
    17ce:	cf 92       	push	r12
    17d0:	df 92       	push	r13
    17d2:	ef 92       	push	r14
    17d4:	ff 92       	push	r15
    17d6:	0f 93       	push	r16
    17d8:	1f 93       	push	r17
    17da:	2f 93       	push	r18
    17dc:	3f 93       	push	r19
    17de:	4f 93       	push	r20
    17e0:	5f 93       	push	r21
    17e2:	6f 93       	push	r22
    17e4:	7f 93       	push	r23
    17e6:	8f 93       	push	r24
    17e8:	9f 93       	push	r25
    17ea:	af 93       	push	r26
    17ec:	bf 93       	push	r27
    17ee:	cf 93       	push	r28
    17f0:	df 93       	push	r29
    17f2:	ef 93       	push	r30
    17f4:	ff 93       	push	r31
    17f6:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    17fa:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    17fe:	0d b6       	in	r0, 0x3d	; 61
    1800:	0d 92       	st	X+, r0
    1802:	0e b6       	in	r0, 0x3e	; 62
    1804:	0d 92       	st	X+, r0
	TCC0.CCA=65535;
    1806:	8f ef       	ldi	r24, 0xFF	; 255
    1808:	9f ef       	ldi	r25, 0xFF	; 255
    180a:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    180e:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	vTaskSwitchContext();
    1812:	0e 94 72 17 	call	0x2ee4	; 0x2ee4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1816:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    181a:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    181e:	cd 91       	ld	r28, X+
    1820:	cd bf       	out	0x3d, r28	; 61
    1822:	dd 91       	ld	r29, X+
    1824:	de bf       	out	0x3e, r29	; 62
    1826:	ff 91       	pop	r31
    1828:	ef 91       	pop	r30
    182a:	df 91       	pop	r29
    182c:	cf 91       	pop	r28
    182e:	bf 91       	pop	r27
    1830:	af 91       	pop	r26
    1832:	9f 91       	pop	r25
    1834:	8f 91       	pop	r24
    1836:	7f 91       	pop	r23
    1838:	6f 91       	pop	r22
    183a:	5f 91       	pop	r21
    183c:	4f 91       	pop	r20
    183e:	3f 91       	pop	r19
    1840:	2f 91       	pop	r18
    1842:	1f 91       	pop	r17
    1844:	0f 91       	pop	r16
    1846:	ff 90       	pop	r15
    1848:	ef 90       	pop	r14
    184a:	df 90       	pop	r13
    184c:	cf 90       	pop	r12
    184e:	bf 90       	pop	r11
    1850:	af 90       	pop	r10
    1852:	9f 90       	pop	r9
    1854:	8f 90       	pop	r8
    1856:	7f 90       	pop	r7
    1858:	6f 90       	pop	r6
    185a:	5f 90       	pop	r5
    185c:	4f 90       	pop	r4
    185e:	3f 90       	pop	r3
    1860:	2f 90       	pop	r2
    1862:	1f 90       	pop	r1
    1864:	0f 90       	pop	r0
    1866:	0f be       	out	0x3f, r0	; 63
    1868:	0f 90       	pop	r0
	asm volatile ( "reti" );
    186a:	18 95       	reti

0000186c <prvCopyDataToQueue>:

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );

		return xNewQueue;
	}
    186c:	0f 93       	push	r16
    186e:	1f 93       	push	r17
    1870:	cf 93       	push	r28
    1872:	df 93       	push	r29
    1874:	ec 01       	movw	r28, r24
    1876:	04 2f       	mov	r16, r20
    1878:	1a 8d       	ldd	r17, Y+26	; 0x1a
    187a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    187c:	41 11       	cpse	r20, r1
    187e:	0d c0       	rjmp	.+26     	; 0x189a <prvCopyDataToQueue+0x2e>
    1880:	88 81       	ld	r24, Y
    1882:	99 81       	ldd	r25, Y+1	; 0x01
    1884:	89 2b       	or	r24, r25
    1886:	09 f4       	brne	.+2      	; 0x188a <prvCopyDataToQueue+0x1e>
    1888:	43 c0       	rjmp	.+134    	; 0x1910 <prvCopyDataToQueue+0xa4>
    188a:	1f 5f       	subi	r17, 0xFF	; 255
    188c:	80 e0       	ldi	r24, 0x00	; 0
    188e:	1a 8f       	std	Y+26, r17	; 0x1a
    1890:	df 91       	pop	r29
    1892:	cf 91       	pop	r28
    1894:	1f 91       	pop	r17
    1896:	0f 91       	pop	r16
    1898:	08 95       	ret
    189a:	50 e0       	ldi	r21, 0x00	; 0
    189c:	01 11       	cpse	r16, r1
    189e:	15 c0       	rjmp	.+42     	; 0x18ca <prvCopyDataToQueue+0x5e>
    18a0:	8a 81       	ldd	r24, Y+2	; 0x02
    18a2:	9b 81       	ldd	r25, Y+3	; 0x03
    18a4:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <memcpy>
    18a8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    18aa:	8a 81       	ldd	r24, Y+2	; 0x02
    18ac:	9b 81       	ldd	r25, Y+3	; 0x03
    18ae:	82 0f       	add	r24, r18
    18b0:	91 1d       	adc	r25, r1
    18b2:	8a 83       	std	Y+2, r24	; 0x02
    18b4:	9b 83       	std	Y+3, r25	; 0x03
    18b6:	2c 81       	ldd	r18, Y+4	; 0x04
    18b8:	3d 81       	ldd	r19, Y+5	; 0x05
    18ba:	82 17       	cp	r24, r18
    18bc:	93 07       	cpc	r25, r19
    18be:	28 f3       	brcs	.-54     	; 0x188a <prvCopyDataToQueue+0x1e>
    18c0:	88 81       	ld	r24, Y
    18c2:	99 81       	ldd	r25, Y+1	; 0x01
    18c4:	8a 83       	std	Y+2, r24	; 0x02
    18c6:	9b 83       	std	Y+3, r25	; 0x03
    18c8:	e0 cf       	rjmp	.-64     	; 0x188a <prvCopyDataToQueue+0x1e>
    18ca:	8e 81       	ldd	r24, Y+6	; 0x06
    18cc:	9f 81       	ldd	r25, Y+7	; 0x07
    18ce:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <memcpy>
    18d2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	91 95       	neg	r25
    18d8:	81 95       	neg	r24
    18da:	91 09       	sbc	r25, r1
    18dc:	2e 81       	ldd	r18, Y+6	; 0x06
    18de:	3f 81       	ldd	r19, Y+7	; 0x07
    18e0:	28 0f       	add	r18, r24
    18e2:	39 1f       	adc	r19, r25
    18e4:	2e 83       	std	Y+6, r18	; 0x06
    18e6:	3f 83       	std	Y+7, r19	; 0x07
    18e8:	48 81       	ld	r20, Y
    18ea:	59 81       	ldd	r21, Y+1	; 0x01
    18ec:	24 17       	cp	r18, r20
    18ee:	35 07       	cpc	r19, r21
    18f0:	30 f4       	brcc	.+12     	; 0x18fe <prvCopyDataToQueue+0x92>
    18f2:	2c 81       	ldd	r18, Y+4	; 0x04
    18f4:	3d 81       	ldd	r19, Y+5	; 0x05
    18f6:	82 0f       	add	r24, r18
    18f8:	93 1f       	adc	r25, r19
    18fa:	8e 83       	std	Y+6, r24	; 0x06
    18fc:	9f 83       	std	Y+7, r25	; 0x07
    18fe:	02 30       	cpi	r16, 0x02	; 2
    1900:	21 f6       	brne	.-120    	; 0x188a <prvCopyDataToQueue+0x1e>
    1902:	11 23       	and	r17, r17
    1904:	11 f0       	breq	.+4      	; 0x190a <prvCopyDataToQueue+0x9e>
    1906:	80 e0       	ldi	r24, 0x00	; 0
    1908:	c2 cf       	rjmp	.-124    	; 0x188e <prvCopyDataToQueue+0x22>
    190a:	11 e0       	ldi	r17, 0x01	; 1
    190c:	80 e0       	ldi	r24, 0x00	; 0
    190e:	bf cf       	rjmp	.-130    	; 0x188e <prvCopyDataToQueue+0x22>
    1910:	8c 81       	ldd	r24, Y+4	; 0x04
    1912:	9d 81       	ldd	r25, Y+5	; 0x05
    1914:	0e 94 cc 18 	call	0x3198	; 0x3198 <xTaskPriorityDisinherit>
    1918:	1c 82       	std	Y+4, r1	; 0x04
    191a:	1d 82       	std	Y+5, r1	; 0x05
    191c:	1f 5f       	subi	r17, 0xFF	; 255
    191e:	b7 cf       	rjmp	.-146    	; 0x188e <prvCopyDataToQueue+0x22>

00001920 <prvCopyDataFromQueue>:
    1920:	fc 01       	movw	r30, r24
    1922:	cb 01       	movw	r24, r22
    1924:	44 8d       	ldd	r20, Z+28	; 0x1c
    1926:	44 23       	and	r20, r20
    1928:	91 f0       	breq	.+36     	; 0x194e <prvCopyDataFromQueue+0x2e>
    192a:	50 e0       	ldi	r21, 0x00	; 0
    192c:	66 81       	ldd	r22, Z+6	; 0x06
    192e:	77 81       	ldd	r23, Z+7	; 0x07
    1930:	64 0f       	add	r22, r20
    1932:	75 1f       	adc	r23, r21
    1934:	66 83       	std	Z+6, r22	; 0x06
    1936:	77 83       	std	Z+7, r23	; 0x07
    1938:	24 81       	ldd	r18, Z+4	; 0x04
    193a:	35 81       	ldd	r19, Z+5	; 0x05
    193c:	62 17       	cp	r22, r18
    193e:	73 07       	cpc	r23, r19
    1940:	20 f0       	brcs	.+8      	; 0x194a <prvCopyDataFromQueue+0x2a>
    1942:	60 81       	ld	r22, Z
    1944:	71 81       	ldd	r23, Z+1	; 0x01
    1946:	66 83       	std	Z+6, r22	; 0x06
    1948:	77 83       	std	Z+7, r23	; 0x07
    194a:	0c 94 ac 25 	jmp	0x4b58	; 0x4b58 <memcpy>
    194e:	08 95       	ret

00001950 <prvUnlockQueue>:
    1950:	ef 92       	push	r14
    1952:	ff 92       	push	r15
    1954:	0f 93       	push	r16
    1956:	1f 93       	push	r17
    1958:	cf 93       	push	r28
    195a:	8c 01       	movw	r16, r24
    195c:	0f b6       	in	r0, 0x3f	; 63
    195e:	f8 94       	cli
    1960:	0f 92       	push	r0
    1962:	fc 01       	movw	r30, r24
    1964:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1966:	1c 16       	cp	r1, r28
    1968:	c4 f4       	brge	.+48     	; 0x199a <prvUnlockQueue+0x4a>
    196a:	fc 01       	movw	r30, r24
    196c:	81 89       	ldd	r24, Z+17	; 0x11
    196e:	88 23       	and	r24, r24
    1970:	a1 f0       	breq	.+40     	; 0x199a <prvUnlockQueue+0x4a>
    1972:	78 01       	movw	r14, r16
    1974:	f1 e1       	ldi	r31, 0x11	; 17
    1976:	ef 0e       	add	r14, r31
    1978:	f1 1c       	adc	r15, r1
    197a:	06 c0       	rjmp	.+12     	; 0x1988 <prvUnlockQueue+0x38>
    197c:	c1 50       	subi	r28, 0x01	; 1
    197e:	69 f0       	breq	.+26     	; 0x199a <prvUnlockQueue+0x4a>
    1980:	f8 01       	movw	r30, r16
    1982:	81 89       	ldd	r24, Z+17	; 0x11
    1984:	88 23       	and	r24, r24
    1986:	49 f0       	breq	.+18     	; 0x199a <prvUnlockQueue+0x4a>
    1988:	c7 01       	movw	r24, r14
    198a:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    198e:	88 23       	and	r24, r24
    1990:	a9 f3       	breq	.-22     	; 0x197c <prvUnlockQueue+0x2c>
    1992:	0e 94 55 18 	call	0x30aa	; 0x30aa <vTaskMissedYield>
    1996:	c1 50       	subi	r28, 0x01	; 1
    1998:	99 f7       	brne	.-26     	; 0x1980 <prvUnlockQueue+0x30>
    199a:	8f ef       	ldi	r24, 0xFF	; 255
    199c:	f8 01       	movw	r30, r16
    199e:	86 8f       	std	Z+30, r24	; 0x1e
    19a0:	0f 90       	pop	r0
    19a2:	0f be       	out	0x3f, r0	; 63
    19a4:	0f b6       	in	r0, 0x3f	; 63
    19a6:	f8 94       	cli
    19a8:	0f 92       	push	r0
    19aa:	c5 8d       	ldd	r28, Z+29	; 0x1d
    19ac:	1c 16       	cp	r1, r28
    19ae:	c4 f4       	brge	.+48     	; 0x19e0 <prvUnlockQueue+0x90>
    19b0:	f8 01       	movw	r30, r16
    19b2:	80 85       	ldd	r24, Z+8	; 0x08
    19b4:	88 23       	and	r24, r24
    19b6:	a1 f0       	breq	.+40     	; 0x19e0 <prvUnlockQueue+0x90>
    19b8:	78 01       	movw	r14, r16
    19ba:	f8 e0       	ldi	r31, 0x08	; 8
    19bc:	ef 0e       	add	r14, r31
    19be:	f1 1c       	adc	r15, r1
    19c0:	06 c0       	rjmp	.+12     	; 0x19ce <prvUnlockQueue+0x7e>
    19c2:	c1 50       	subi	r28, 0x01	; 1
    19c4:	69 f0       	breq	.+26     	; 0x19e0 <prvUnlockQueue+0x90>
    19c6:	f8 01       	movw	r30, r16
    19c8:	80 85       	ldd	r24, Z+8	; 0x08
    19ca:	88 23       	and	r24, r24
    19cc:	49 f0       	breq	.+18     	; 0x19e0 <prvUnlockQueue+0x90>
    19ce:	c7 01       	movw	r24, r14
    19d0:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    19d4:	88 23       	and	r24, r24
    19d6:	a9 f3       	breq	.-22     	; 0x19c2 <prvUnlockQueue+0x72>
    19d8:	0e 94 55 18 	call	0x30aa	; 0x30aa <vTaskMissedYield>
    19dc:	c1 50       	subi	r28, 0x01	; 1
    19de:	99 f7       	brne	.-26     	; 0x19c6 <prvUnlockQueue+0x76>
    19e0:	8f ef       	ldi	r24, 0xFF	; 255
    19e2:	f8 01       	movw	r30, r16
    19e4:	85 8f       	std	Z+29, r24	; 0x1d
    19e6:	0f 90       	pop	r0
    19e8:	0f be       	out	0x3f, r0	; 63
    19ea:	cf 91       	pop	r28
    19ec:	1f 91       	pop	r17
    19ee:	0f 91       	pop	r16
    19f0:	ff 90       	pop	r15
    19f2:	ef 90       	pop	r14
    19f4:	08 95       	ret

000019f6 <xQueueGenericReset>:
    19f6:	1f 93       	push	r17
    19f8:	cf 93       	push	r28
    19fa:	df 93       	push	r29
    19fc:	ec 01       	movw	r28, r24
    19fe:	16 2f       	mov	r17, r22
    1a00:	89 2b       	or	r24, r25
    1a02:	09 f4       	brne	.+2      	; 0x1a06 <xQueueGenericReset+0x10>
    1a04:	3e c0       	rjmp	.+124    	; 0x1a82 <xQueueGenericReset+0x8c>
    1a06:	0f b6       	in	r0, 0x3f	; 63
    1a08:	f8 94       	cli
    1a0a:	0f 92       	push	r0
    1a0c:	48 81       	ld	r20, Y
    1a0e:	59 81       	ldd	r21, Y+1	; 0x01
    1a10:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a12:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1a14:	9a 01       	movw	r18, r20
    1a16:	86 9f       	mul	r24, r22
    1a18:	20 0d       	add	r18, r0
    1a1a:	31 1d       	adc	r19, r1
    1a1c:	11 24       	eor	r1, r1
    1a1e:	2c 83       	std	Y+4, r18	; 0x04
    1a20:	3d 83       	std	Y+5, r19	; 0x05
    1a22:	1a 8e       	std	Y+26, r1	; 0x1a
    1a24:	4a 83       	std	Y+2, r20	; 0x02
    1a26:	5b 83       	std	Y+3, r21	; 0x03
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	01 97       	sbiw	r24, 0x01	; 1
    1a2c:	68 9f       	mul	r22, r24
    1a2e:	90 01       	movw	r18, r0
    1a30:	69 9f       	mul	r22, r25
    1a32:	30 0d       	add	r19, r0
    1a34:	11 24       	eor	r1, r1
    1a36:	ca 01       	movw	r24, r20
    1a38:	82 0f       	add	r24, r18
    1a3a:	93 1f       	adc	r25, r19
    1a3c:	8e 83       	std	Y+6, r24	; 0x06
    1a3e:	9f 83       	std	Y+7, r25	; 0x07
    1a40:	8f ef       	ldi	r24, 0xFF	; 255
    1a42:	8d 8f       	std	Y+29, r24	; 0x1d
    1a44:	8e 8f       	std	Y+30, r24	; 0x1e
    1a46:	11 11       	cpse	r17, r1
    1a48:	13 c0       	rjmp	.+38     	; 0x1a70 <xQueueGenericReset+0x7a>
    1a4a:	88 85       	ldd	r24, Y+8	; 0x08
    1a4c:	81 11       	cpse	r24, r1
    1a4e:	07 c0       	rjmp	.+14     	; 0x1a5e <xQueueGenericReset+0x68>
    1a50:	0f 90       	pop	r0
    1a52:	0f be       	out	0x3f, r0	; 63
    1a54:	81 e0       	ldi	r24, 0x01	; 1
    1a56:	df 91       	pop	r29
    1a58:	cf 91       	pop	r28
    1a5a:	1f 91       	pop	r17
    1a5c:	08 95       	ret
    1a5e:	ce 01       	movw	r24, r28
    1a60:	08 96       	adiw	r24, 0x08	; 8
    1a62:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    1a66:	88 23       	and	r24, r24
    1a68:	99 f3       	breq	.-26     	; 0x1a50 <xQueueGenericReset+0x5a>
    1a6a:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    1a6e:	f0 cf       	rjmp	.-32     	; 0x1a50 <xQueueGenericReset+0x5a>
    1a70:	ce 01       	movw	r24, r28
    1a72:	08 96       	adiw	r24, 0x08	; 8
    1a74:	0e 94 b1 09 	call	0x1362	; 0x1362 <vListInitialise>
    1a78:	ce 01       	movw	r24, r28
    1a7a:	41 96       	adiw	r24, 0x11	; 17
    1a7c:	0e 94 b1 09 	call	0x1362	; 0x1362 <vListInitialise>
    1a80:	e7 cf       	rjmp	.-50     	; 0x1a50 <xQueueGenericReset+0x5a>
    1a82:	63 e0       	ldi	r22, 0x03	; 3
    1a84:	71 e0       	ldi	r23, 0x01	; 1
    1a86:	87 e2       	ldi	r24, 0x27	; 39
    1a88:	90 e2       	ldi	r25, 0x20	; 32
    1a8a:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1a8e:	bb cf       	rjmp	.-138    	; 0x1a06 <xQueueGenericReset+0x10>

00001a90 <xQueueGenericCreate>:
    1a90:	ff 92       	push	r15
    1a92:	0f 93       	push	r16
    1a94:	1f 93       	push	r17
    1a96:	cf 93       	push	r28
    1a98:	df 93       	push	r29
    1a9a:	18 2f       	mov	r17, r24
    1a9c:	06 2f       	mov	r16, r22
    1a9e:	f4 2e       	mov	r15, r20
    1aa0:	88 23       	and	r24, r24
    1aa2:	99 f1       	breq	.+102    	; 0x1b0a <xQueueGenericCreate+0x7a>
    1aa4:	00 23       	and	r16, r16
    1aa6:	d1 f0       	breq	.+52     	; 0x1adc <xQueueGenericCreate+0x4c>
    1aa8:	10 9f       	mul	r17, r16
    1aaa:	c0 01       	movw	r24, r0
    1aac:	11 24       	eor	r1, r1
    1aae:	81 96       	adiw	r24, 0x21	; 33
    1ab0:	0e 94 e7 08 	call	0x11ce	; 0x11ce <pvPortMalloc>
    1ab4:	ec 01       	movw	r28, r24
    1ab6:	00 97       	sbiw	r24, 0x00	; 0
    1ab8:	51 f0       	breq	.+20     	; 0x1ace <xQueueGenericCreate+0x3e>
    1aba:	81 96       	adiw	r24, 0x21	; 33
    1abc:	88 83       	st	Y, r24
    1abe:	99 83       	std	Y+1, r25	; 0x01
    1ac0:	1b 8f       	std	Y+27, r17	; 0x1b
    1ac2:	0c 8f       	std	Y+28, r16	; 0x1c
    1ac4:	61 e0       	ldi	r22, 0x01	; 1
    1ac6:	ce 01       	movw	r24, r28
    1ac8:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <xQueueGenericReset>
    1acc:	f8 a2       	std	Y+32, r15	; 0x20
    1ace:	ce 01       	movw	r24, r28
    1ad0:	df 91       	pop	r29
    1ad2:	cf 91       	pop	r28
    1ad4:	1f 91       	pop	r17
    1ad6:	0f 91       	pop	r16
    1ad8:	ff 90       	pop	r15
    1ada:	08 95       	ret
    1adc:	81 e2       	ldi	r24, 0x21	; 33
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	0e 94 e7 08 	call	0x11ce	; 0x11ce <pvPortMalloc>
    1ae4:	ec 01       	movw	r28, r24
    1ae6:	89 2b       	or	r24, r25
    1ae8:	91 f3       	breq	.-28     	; 0x1ace <xQueueGenericCreate+0x3e>
    1aea:	c8 83       	st	Y, r28
    1aec:	d9 83       	std	Y+1, r29	; 0x01
    1aee:	1b 8f       	std	Y+27, r17	; 0x1b
    1af0:	0c 8f       	std	Y+28, r16	; 0x1c
    1af2:	61 e0       	ldi	r22, 0x01	; 1
    1af4:	ce 01       	movw	r24, r28
    1af6:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <xQueueGenericReset>
    1afa:	f8 a2       	std	Y+32, r15	; 0x20
    1afc:	ce 01       	movw	r24, r28
    1afe:	df 91       	pop	r29
    1b00:	cf 91       	pop	r28
    1b02:	1f 91       	pop	r17
    1b04:	0f 91       	pop	r16
    1b06:	ff 90       	pop	r15
    1b08:	08 95       	ret
    1b0a:	66 e7       	ldi	r22, 0x76	; 118
    1b0c:	71 e0       	ldi	r23, 0x01	; 1
    1b0e:	87 e2       	ldi	r24, 0x27	; 39
    1b10:	90 e2       	ldi	r25, 0x20	; 32
    1b12:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1b16:	c6 cf       	rjmp	.-116    	; 0x1aa4 <xQueueGenericCreate+0x14>

00001b18 <xQueueGenericSend>:
    1b18:	bf 92       	push	r11
    1b1a:	cf 92       	push	r12
    1b1c:	df 92       	push	r13
    1b1e:	ef 92       	push	r14
    1b20:	ff 92       	push	r15
    1b22:	0f 93       	push	r16
    1b24:	1f 93       	push	r17
    1b26:	cf 93       	push	r28
    1b28:	df 93       	push	r29
    1b2a:	cd b7       	in	r28, 0x3d	; 61
    1b2c:	de b7       	in	r29, 0x3e	; 62
    1b2e:	25 97       	sbiw	r28, 0x05	; 5
    1b30:	cd bf       	out	0x3d, r28	; 61
    1b32:	de bf       	out	0x3e, r29	; 62
    1b34:	8c 01       	movw	r16, r24
    1b36:	6b 01       	movw	r12, r22
    1b38:	4c 83       	std	Y+4, r20	; 0x04
    1b3a:	5d 83       	std	Y+5, r21	; 0x05
    1b3c:	b2 2e       	mov	r11, r18
    1b3e:	89 2b       	or	r24, r25
    1b40:	09 f4       	brne	.+2      	; 0x1b44 <xQueueGenericSend+0x2c>
    1b42:	b2 c0       	rjmp	.+356    	; 0x1ca8 <xQueueGenericSend+0x190>
    1b44:	c1 14       	cp	r12, r1
    1b46:	d1 04       	cpc	r13, r1
    1b48:	09 f4       	brne	.+2      	; 0x1b4c <xQueueGenericSend+0x34>
    1b4a:	a2 c0       	rjmp	.+324    	; 0x1c90 <xQueueGenericSend+0x178>
    1b4c:	f2 e0       	ldi	r31, 0x02	; 2
    1b4e:	bf 16       	cp	r11, r31
    1b50:	09 f4       	brne	.+2      	; 0x1b54 <xQueueGenericSend+0x3c>
    1b52:	7d c0       	rjmp	.+250    	; 0x1c4e <xQueueGenericSend+0x136>
    1b54:	f8 01       	movw	r30, r16
    1b56:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b58:	20 e0       	ldi	r18, 0x00	; 0
    1b5a:	78 01       	movw	r14, r16
    1b5c:	f8 e0       	ldi	r31, 0x08	; 8
    1b5e:	ef 0e       	add	r14, r31
    1b60:	f1 1c       	adc	r15, r1
    1b62:	10 c0       	rjmp	.+32     	; 0x1b84 <xQueueGenericSend+0x6c>
    1b64:	6c 81       	ldd	r22, Y+4	; 0x04
    1b66:	7d 81       	ldd	r23, Y+5	; 0x05
    1b68:	c7 01       	movw	r24, r14
    1b6a:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vTaskPlaceOnEventList>
    1b6e:	c8 01       	movw	r24, r16
    1b70:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
    1b74:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    1b78:	88 23       	and	r24, r24
    1b7a:	09 f4       	brne	.+2      	; 0x1b7e <xQueueGenericSend+0x66>
    1b7c:	4a c0       	rjmp	.+148    	; 0x1c12 <xQueueGenericSend+0xfa>
    1b7e:	f8 01       	movw	r30, r16
    1b80:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b82:	21 e0       	ldi	r18, 0x01	; 1
    1b84:	0f b6       	in	r0, 0x3f	; 63
    1b86:	f8 94       	cli
    1b88:	0f 92       	push	r0
    1b8a:	f8 01       	movw	r30, r16
    1b8c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b8e:	98 17       	cp	r25, r24
    1b90:	08 f4       	brcc	.+2      	; 0x1b94 <xQueueGenericSend+0x7c>
    1b92:	42 c0       	rjmp	.+132    	; 0x1c18 <xQueueGenericSend+0x100>
    1b94:	f2 e0       	ldi	r31, 0x02	; 2
    1b96:	bf 16       	cp	r11, r31
    1b98:	09 f4       	brne	.+2      	; 0x1b9c <xQueueGenericSend+0x84>
    1b9a:	3e c0       	rjmp	.+124    	; 0x1c18 <xQueueGenericSend+0x100>
    1b9c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b9e:	9d 81       	ldd	r25, Y+5	; 0x05
    1ba0:	89 2b       	or	r24, r25
    1ba2:	09 f4       	brne	.+2      	; 0x1ba6 <xQueueGenericSend+0x8e>
    1ba4:	60 c0       	rjmp	.+192    	; 0x1c66 <xQueueGenericSend+0x14e>
    1ba6:	22 23       	and	r18, r18
    1ba8:	59 f1       	breq	.+86     	; 0x1c00 <xQueueGenericSend+0xe8>
    1baa:	0f 90       	pop	r0
    1bac:	0f be       	out	0x3f, r0	; 63
    1bae:	0e 94 7e 15 	call	0x2afc	; 0x2afc <vTaskSuspendAll>
    1bb2:	0f b6       	in	r0, 0x3f	; 63
    1bb4:	f8 94       	cli
    1bb6:	0f 92       	push	r0
    1bb8:	f8 01       	movw	r30, r16
    1bba:	85 8d       	ldd	r24, Z+29	; 0x1d
    1bbc:	8f 3f       	cpi	r24, 0xFF	; 255
    1bbe:	39 f1       	breq	.+78     	; 0x1c0e <xQueueGenericSend+0xf6>
    1bc0:	f8 01       	movw	r30, r16
    1bc2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bc4:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc6:	09 f1       	breq	.+66     	; 0x1c0a <xQueueGenericSend+0xf2>
    1bc8:	0f 90       	pop	r0
    1bca:	0f be       	out	0x3f, r0	; 63
    1bcc:	be 01       	movw	r22, r28
    1bce:	6c 5f       	subi	r22, 0xFC	; 252
    1bd0:	7f 4f       	sbci	r23, 0xFF	; 255
    1bd2:	ce 01       	movw	r24, r28
    1bd4:	01 96       	adiw	r24, 0x01	; 1
    1bd6:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <xTaskCheckForTimeOut>
    1bda:	81 11       	cpse	r24, r1
    1bdc:	48 c0       	rjmp	.+144    	; 0x1c6e <xQueueGenericSend+0x156>
    1bde:	0f b6       	in	r0, 0x3f	; 63
    1be0:	f8 94       	cli
    1be2:	0f 92       	push	r0
    1be4:	f8 01       	movw	r30, r16
    1be6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1be8:	0f 90       	pop	r0
    1bea:	0f be       	out	0x3f, r0	; 63
    1bec:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bee:	98 17       	cp	r25, r24
    1bf0:	09 f4       	brne	.+2      	; 0x1bf4 <xQueueGenericSend+0xdc>
    1bf2:	b8 cf       	rjmp	.-144    	; 0x1b64 <xQueueGenericSend+0x4c>
    1bf4:	c8 01       	movw	r24, r16
    1bf6:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
    1bfa:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    1bfe:	bf cf       	rjmp	.-130    	; 0x1b7e <xQueueGenericSend+0x66>
    1c00:	ce 01       	movw	r24, r28
    1c02:	01 96       	adiw	r24, 0x01	; 1
    1c04:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vTaskInternalSetTimeOutState>
    1c08:	d0 cf       	rjmp	.-96     	; 0x1baa <xQueueGenericSend+0x92>
    1c0a:	16 8e       	std	Z+30, r1	; 0x1e
    1c0c:	dd cf       	rjmp	.-70     	; 0x1bc8 <xQueueGenericSend+0xb0>
    1c0e:	15 8e       	std	Z+29, r1	; 0x1d
    1c10:	d7 cf       	rjmp	.-82     	; 0x1bc0 <xQueueGenericSend+0xa8>
    1c12:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    1c16:	b3 cf       	rjmp	.-154    	; 0x1b7e <xQueueGenericSend+0x66>
    1c18:	4b 2d       	mov	r20, r11
    1c1a:	b6 01       	movw	r22, r12
    1c1c:	c8 01       	movw	r24, r16
    1c1e:	0e 94 36 0c 	call	0x186c	; 0x186c <prvCopyDataToQueue>
    1c22:	f8 01       	movw	r30, r16
    1c24:	91 89       	ldd	r25, Z+17	; 0x11
    1c26:	91 11       	cpse	r25, r1
    1c28:	2c c0       	rjmp	.+88     	; 0x1c82 <xQueueGenericSend+0x16a>
    1c2a:	81 11       	cpse	r24, r1
    1c2c:	27 c0       	rjmp	.+78     	; 0x1c7c <xQueueGenericSend+0x164>
    1c2e:	0f 90       	pop	r0
    1c30:	0f be       	out	0x3f, r0	; 63
    1c32:	81 e0       	ldi	r24, 0x01	; 1
    1c34:	25 96       	adiw	r28, 0x05	; 5
    1c36:	cd bf       	out	0x3d, r28	; 61
    1c38:	de bf       	out	0x3e, r29	; 62
    1c3a:	df 91       	pop	r29
    1c3c:	cf 91       	pop	r28
    1c3e:	1f 91       	pop	r17
    1c40:	0f 91       	pop	r16
    1c42:	ff 90       	pop	r15
    1c44:	ef 90       	pop	r14
    1c46:	df 90       	pop	r13
    1c48:	cf 90       	pop	r12
    1c4a:	bf 90       	pop	r11
    1c4c:	08 95       	ret
    1c4e:	f8 01       	movw	r30, r16
    1c50:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c52:	81 30       	cpi	r24, 0x01	; 1
    1c54:	09 f4       	brne	.+2      	; 0x1c58 <xQueueGenericSend+0x140>
    1c56:	80 cf       	rjmp	.-256    	; 0x1b58 <xQueueGenericSend+0x40>
    1c58:	63 ef       	ldi	r22, 0xF3	; 243
    1c5a:	72 e0       	ldi	r23, 0x02	; 2
    1c5c:	87 e2       	ldi	r24, 0x27	; 39
    1c5e:	90 e2       	ldi	r25, 0x20	; 32
    1c60:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1c64:	77 cf       	rjmp	.-274    	; 0x1b54 <xQueueGenericSend+0x3c>
    1c66:	0f 90       	pop	r0
    1c68:	0f be       	out	0x3f, r0	; 63
    1c6a:	80 e0       	ldi	r24, 0x00	; 0
    1c6c:	e3 cf       	rjmp	.-58     	; 0x1c34 <xQueueGenericSend+0x11c>
    1c6e:	c8 01       	movw	r24, r16
    1c70:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
    1c74:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    1c78:	80 e0       	ldi	r24, 0x00	; 0
    1c7a:	dc cf       	rjmp	.-72     	; 0x1c34 <xQueueGenericSend+0x11c>
    1c7c:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    1c80:	d6 cf       	rjmp	.-84     	; 0x1c2e <xQueueGenericSend+0x116>
    1c82:	c8 01       	movw	r24, r16
    1c84:	41 96       	adiw	r24, 0x11	; 17
    1c86:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    1c8a:	88 23       	and	r24, r24
    1c8c:	81 f2       	breq	.-96     	; 0x1c2e <xQueueGenericSend+0x116>
    1c8e:	f6 cf       	rjmp	.-20     	; 0x1c7c <xQueueGenericSend+0x164>
    1c90:	f8 01       	movw	r30, r16
    1c92:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c94:	88 23       	and	r24, r24
    1c96:	09 f4       	brne	.+2      	; 0x1c9a <xQueueGenericSend+0x182>
    1c98:	59 cf       	rjmp	.-334    	; 0x1b4c <xQueueGenericSend+0x34>
    1c9a:	62 ef       	ldi	r22, 0xF2	; 242
    1c9c:	72 e0       	ldi	r23, 0x02	; 2
    1c9e:	87 e2       	ldi	r24, 0x27	; 39
    1ca0:	90 e2       	ldi	r25, 0x20	; 32
    1ca2:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1ca6:	52 cf       	rjmp	.-348    	; 0x1b4c <xQueueGenericSend+0x34>
    1ca8:	61 ef       	ldi	r22, 0xF1	; 241
    1caa:	72 e0       	ldi	r23, 0x02	; 2
    1cac:	87 e2       	ldi	r24, 0x27	; 39
    1cae:	90 e2       	ldi	r25, 0x20	; 32
    1cb0:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1cb4:	47 cf       	rjmp	.-370    	; 0x1b44 <xQueueGenericSend+0x2c>

00001cb6 <xQueueGenericSendFromISR>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1cb6:	cf 92       	push	r12
    1cb8:	df 92       	push	r13
    1cba:	ef 92       	push	r14
    1cbc:	ff 92       	push	r15
    1cbe:	0f 93       	push	r16
    1cc0:	1f 93       	push	r17
    1cc2:	cf 93       	push	r28
    1cc4:	df 93       	push	r29
    1cc6:	ec 01       	movw	r28, r24
    1cc8:	8b 01       	movw	r16, r22
    1cca:	6a 01       	movw	r12, r20
    1ccc:	f2 2e       	mov	r15, r18
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    1cce:	89 2b       	or	r24, r25
    1cd0:	09 f4       	brne	.+2      	; 0x1cd4 <xQueueGenericSendFromISR+0x1e>
    1cd2:	45 c0       	rjmp	.+138    	; 0x1d5e <xQueueGenericSendFromISR+0xa8>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1cd4:	01 15       	cp	r16, r1
    1cd6:	11 05       	cpc	r17, r1
    1cd8:	c1 f1       	breq	.+112    	; 0x1d4a <xQueueGenericSendFromISR+0x94>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    1cda:	82 e0       	ldi	r24, 0x02	; 2
    1cdc:	f8 16       	cp	r15, r24
    1cde:	71 f0       	breq	.+28     	; 0x1cfc <xQueueGenericSendFromISR+0x46>
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1ce0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1ce2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ce4:	98 17       	cp	r25, r24
    1ce6:	a0 f0       	brcs	.+40     	; 0x1d10 <xQueueGenericSendFromISR+0x5a>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1ce8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1cea:	df 91       	pop	r29
    1cec:	cf 91       	pop	r28
    1cee:	1f 91       	pop	r17
    1cf0:	0f 91       	pop	r16
    1cf2:	ff 90       	pop	r15
    1cf4:	ef 90       	pop	r14
    1cf6:	df 90       	pop	r13
    1cf8:	cf 90       	pop	r12
    1cfa:	08 95       	ret
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    1cfc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1cfe:	81 30       	cpi	r24, 0x01	; 1
    1d00:	31 f0       	breq	.+12     	; 0x1d0e <xQueueGenericSendFromISR+0x58>
    1d02:	65 ec       	ldi	r22, 0xC5	; 197
    1d04:	73 e0       	ldi	r23, 0x03	; 3
    1d06:	87 e2       	ldi	r24, 0x27	; 39
    1d08:	90 e2       	ldi	r25, 0x20	; 32
    1d0a:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1d0e:	8a 8d       	ldd	r24, Y+26	; 0x1a
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1d10:	ee 8c       	ldd	r14, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1d12:	4f 2d       	mov	r20, r15
    1d14:	b8 01       	movw	r22, r16
    1d16:	ce 01       	movw	r24, r28
    1d18:	0e 94 36 0c 	call	0x186c	; 0x186c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1d1c:	ef ef       	ldi	r30, 0xFF	; 255
    1d1e:	ee 16       	cp	r14, r30
    1d20:	21 f0       	breq	.+8      	; 0x1d2a <xQueueGenericSendFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1d22:	e3 94       	inc	r14
    1d24:	ee 8e       	std	Y+30, r14	; 0x1e
			}

			xReturn = pdPASS;
    1d26:	81 e0       	ldi	r24, 0x01	; 1
    1d28:	e0 cf       	rjmp	.-64     	; 0x1cea <xQueueGenericSendFromISR+0x34>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d2a:	89 89       	ldd	r24, Y+17	; 0x11
    1d2c:	88 23       	and	r24, r24
    1d2e:	d9 f3       	breq	.-10     	; 0x1d26 <xQueueGenericSendFromISR+0x70>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d30:	ce 01       	movw	r24, r28
    1d32:	41 96       	adiw	r24, 0x11	; 17
    1d34:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    1d38:	88 23       	and	r24, r24
    1d3a:	a9 f3       	breq	.-22     	; 0x1d26 <xQueueGenericSendFromISR+0x70>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1d3c:	c1 14       	cp	r12, r1
    1d3e:	d1 04       	cpc	r13, r1
    1d40:	91 f3       	breq	.-28     	; 0x1d26 <xQueueGenericSendFromISR+0x70>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1d42:	81 e0       	ldi	r24, 0x01	; 1
    1d44:	f6 01       	movw	r30, r12
    1d46:	80 83       	st	Z, r24
    1d48:	d0 cf       	rjmp	.-96     	; 0x1cea <xQueueGenericSendFromISR+0x34>
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1d4a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1d4c:	88 23       	and	r24, r24
    1d4e:	29 f2       	breq	.-118    	; 0x1cda <xQueueGenericSendFromISR+0x24>
    1d50:	64 ec       	ldi	r22, 0xC4	; 196
    1d52:	73 e0       	ldi	r23, 0x03	; 3
    1d54:	87 e2       	ldi	r24, 0x27	; 39
    1d56:	90 e2       	ldi	r25, 0x20	; 32
    1d58:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1d5c:	be cf       	rjmp	.-132    	; 0x1cda <xQueueGenericSendFromISR+0x24>
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    1d5e:	63 ec       	ldi	r22, 0xC3	; 195
    1d60:	73 e0       	ldi	r23, 0x03	; 3
    1d62:	87 e2       	ldi	r24, 0x27	; 39
    1d64:	90 e2       	ldi	r25, 0x20	; 32
    1d66:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1d6a:	b4 cf       	rjmp	.-152    	; 0x1cd4 <xQueueGenericSendFromISR+0x1e>

00001d6c <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1d6c:	0f 93       	push	r16
    1d6e:	1f 93       	push	r17
    1d70:	cf 93       	push	r28
    1d72:	df 93       	push	r29
    1d74:	ec 01       	movw	r28, r24
    1d76:	8b 01       	movw	r16, r22
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
    1d78:	89 2b       	or	r24, r25
    1d7a:	09 f4       	brne	.+2      	; 0x1d7e <xQueueGiveFromISR+0x12>
    1d7c:	43 c0       	rjmp	.+134    	; 0x1e04 <xQueueGiveFromISR+0x98>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    1d7e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1d80:	81 11       	cpse	r24, r1
    1d82:	1b c0       	rjmp	.+54     	; 0x1dba <xQueueGiveFromISR+0x4e>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    1d84:	88 81       	ld	r24, Y
    1d86:	99 81       	ldd	r25, Y+1	; 0x01
    1d88:	89 2b       	or	r24, r25
    1d8a:	09 f1       	breq	.+66     	; 0x1dce <xQueueGiveFromISR+0x62>
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1d8c:	8a 8d       	ldd	r24, Y+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1d8e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1d90:	89 17       	cp	r24, r25
    1d92:	68 f4       	brcc	.+26     	; 0x1dae <xQueueGiveFromISR+0x42>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1d94:	9e 8d       	ldd	r25, Y+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1d96:	8f 5f       	subi	r24, 0xFF	; 255
    1d98:	8a 8f       	std	Y+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1d9a:	9f 3f       	cpi	r25, 0xFF	; 255
    1d9c:	19 f1       	breq	.+70     	; 0x1de4 <xQueueGiveFromISR+0x78>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1d9e:	9f 5f       	subi	r25, 0xFF	; 255
    1da0:	9e 8f       	std	Y+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    1da2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1da4:	df 91       	pop	r29
    1da6:	cf 91       	pop	r28
    1da8:	1f 91       	pop	r17
    1daa:	0f 91       	pop	r16
    1dac:	08 95       	ret
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1dae:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1db0:	df 91       	pop	r29
    1db2:	cf 91       	pop	r28
    1db4:	1f 91       	pop	r17
    1db6:	0f 91       	pop	r16
    1db8:	08 95       	ret

	configASSERT( pxQueue );

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    1dba:	64 e6       	ldi	r22, 0x64	; 100
    1dbc:	74 e0       	ldi	r23, 0x04	; 4
    1dbe:	87 e2       	ldi	r24, 0x27	; 39
    1dc0:	90 e2       	ldi	r25, 0x20	; 32
    1dc2:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    1dc6:	88 81       	ld	r24, Y
    1dc8:	99 81       	ldd	r25, Y+1	; 0x01
    1dca:	89 2b       	or	r24, r25
    1dcc:	f9 f6       	brne	.-66     	; 0x1d8c <xQueueGiveFromISR+0x20>
    1dce:	8c 81       	ldd	r24, Y+4	; 0x04
    1dd0:	9d 81       	ldd	r25, Y+5	; 0x05
    1dd2:	89 2b       	or	r24, r25
    1dd4:	d9 f2       	breq	.-74     	; 0x1d8c <xQueueGiveFromISR+0x20>
    1dd6:	69 e6       	ldi	r22, 0x69	; 105
    1dd8:	74 e0       	ldi	r23, 0x04	; 4
    1dda:	87 e2       	ldi	r24, 0x27	; 39
    1ddc:	90 e2       	ldi	r25, 0x20	; 32
    1dde:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1de2:	d4 cf       	rjmp	.-88     	; 0x1d8c <xQueueGiveFromISR+0x20>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1de4:	89 89       	ldd	r24, Y+17	; 0x11
    1de6:	88 23       	and	r24, r24
    1de8:	e1 f2       	breq	.-72     	; 0x1da2 <xQueueGiveFromISR+0x36>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1dea:	ce 01       	movw	r24, r28
    1dec:	41 96       	adiw	r24, 0x11	; 17
    1dee:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    1df2:	88 23       	and	r24, r24
    1df4:	b1 f2       	breq	.-84     	; 0x1da2 <xQueueGiveFromISR+0x36>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1df6:	01 15       	cp	r16, r1
    1df8:	11 05       	cpc	r17, r1
    1dfa:	99 f2       	breq	.-90     	; 0x1da2 <xQueueGiveFromISR+0x36>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1dfc:	81 e0       	ldi	r24, 0x01	; 1
    1dfe:	f8 01       	movw	r30, r16
    1e00:	80 83       	st	Z, r24
    1e02:	d0 cf       	rjmp	.-96     	; 0x1da4 <xQueueGiveFromISR+0x38>
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
    1e04:	60 e6       	ldi	r22, 0x60	; 96
    1e06:	74 e0       	ldi	r23, 0x04	; 4
    1e08:	87 e2       	ldi	r24, 0x27	; 39
    1e0a:	90 e2       	ldi	r25, 0x20	; 32
    1e0c:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1e10:	b6 cf       	rjmp	.-148    	; 0x1d7e <xQueueGiveFromISR+0x12>

00001e12 <xQueueReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1e12:	af 92       	push	r10
    1e14:	bf 92       	push	r11
    1e16:	cf 92       	push	r12
    1e18:	df 92       	push	r13
    1e1a:	ff 92       	push	r15
    1e1c:	0f 93       	push	r16
    1e1e:	1f 93       	push	r17
    1e20:	cf 93       	push	r28
    1e22:	df 93       	push	r29
    1e24:	cd b7       	in	r28, 0x3d	; 61
    1e26:	de b7       	in	r29, 0x3e	; 62
    1e28:	25 97       	sbiw	r28, 0x05	; 5
    1e2a:	cd bf       	out	0x3d, r28	; 61
    1e2c:	de bf       	out	0x3e, r29	; 62
    1e2e:	8c 01       	movw	r16, r24
    1e30:	5b 01       	movw	r10, r22
    1e32:	4c 83       	std	Y+4, r20	; 0x04
    1e34:	5d 83       	std	Y+5, r21	; 0x05
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    1e36:	89 2b       	or	r24, r25
    1e38:	09 f4       	brne	.+2      	; 0x1e3c <xQueueReceive+0x2a>
    1e3a:	a1 c0       	rjmp	.+322    	; 0x1f7e <xQueueReceive+0x16c>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1e3c:	a1 14       	cp	r10, r1
    1e3e:	b1 04       	cpc	r11, r1
    1e40:	09 f4       	brne	.+2      	; 0x1e44 <xQueueReceive+0x32>
    1e42:	91 c0       	rjmp	.+290    	; 0x1f66 <xQueueReceive+0x154>
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1e44:	20 e0       	ldi	r18, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e46:	68 01       	movw	r12, r16
    1e48:	f1 e1       	ldi	r31, 0x11	; 17
    1e4a:	cf 0e       	add	r12, r31
    1e4c:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1e4e:	0f b6       	in	r0, 0x3f	; 63
    1e50:	f8 94       	cli
    1e52:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1e54:	f8 01       	movw	r30, r16
    1e56:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e58:	f1 10       	cpse	r15, r1
    1e5a:	6a c0       	rjmp	.+212    	; 0x1f30 <xQueueReceive+0x11e>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e5c:	8c 81       	ldd	r24, Y+4	; 0x04
    1e5e:	9d 81       	ldd	r25, Y+5	; 0x05
    1e60:	89 2b       	or	r24, r25
    1e62:	09 f4       	brne	.+2      	; 0x1e66 <xQueueReceive+0x54>
    1e64:	73 c0       	rjmp	.+230    	; 0x1f4c <xQueueReceive+0x13a>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1e66:	22 23       	and	r18, r18
    1e68:	09 f4       	brne	.+2      	; 0x1e6c <xQueueReceive+0x5a>
    1e6a:	59 c0       	rjmp	.+178    	; 0x1f1e <xQueueReceive+0x10c>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e6c:	0f 90       	pop	r0
    1e6e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e70:	0e 94 7e 15 	call	0x2afc	; 0x2afc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e74:	0f b6       	in	r0, 0x3f	; 63
    1e76:	f8 94       	cli
    1e78:	0f 92       	push	r0
    1e7a:	f8 01       	movw	r30, r16
    1e7c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e7e:	8f 3f       	cpi	r24, 0xFF	; 255
    1e80:	09 f4       	brne	.+2      	; 0x1e84 <xQueueReceive+0x72>
    1e82:	54 c0       	rjmp	.+168    	; 0x1f2c <xQueueReceive+0x11a>
    1e84:	f8 01       	movw	r30, r16
    1e86:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e88:	8f 3f       	cpi	r24, 0xFF	; 255
    1e8a:	09 f4       	brne	.+2      	; 0x1e8e <xQueueReceive+0x7c>
    1e8c:	4d c0       	rjmp	.+154    	; 0x1f28 <xQueueReceive+0x116>
    1e8e:	0f 90       	pop	r0
    1e90:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e92:	be 01       	movw	r22, r28
    1e94:	6c 5f       	subi	r22, 0xFC	; 252
    1e96:	7f 4f       	sbci	r23, 0xFF	; 255
    1e98:	ce 01       	movw	r24, r28
    1e9a:	01 96       	adiw	r24, 0x01	; 1
    1e9c:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <xTaskCheckForTimeOut>
    1ea0:	81 11       	cpse	r24, r1
    1ea2:	22 c0       	rjmp	.+68     	; 0x1ee8 <xQueueReceive+0xd6>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1ea4:	0f b6       	in	r0, 0x3f	; 63
    1ea6:	f8 94       	cli
    1ea8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1eaa:	f8 01       	movw	r30, r16
    1eac:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1eae:	0f 90       	pop	r0
    1eb0:	0f be       	out	0x3f, r0	; 63
		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1eb2:	81 11       	cpse	r24, r1
    1eb4:	12 c0       	rjmp	.+36     	; 0x1eda <xQueueReceive+0xc8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1eb6:	6c 81       	ldd	r22, Y+4	; 0x04
    1eb8:	7d 81       	ldd	r23, Y+5	; 0x05
    1eba:	c6 01       	movw	r24, r12
    1ebc:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ec0:	c8 01       	movw	r24, r16
    1ec2:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ec6:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    1eca:	88 23       	and	r24, r24
    1ecc:	11 f0       	breq	.+4      	; 0x1ed2 <xQueueReceive+0xc0>
    1ece:	21 e0       	ldi	r18, 0x01	; 1
    1ed0:	be cf       	rjmp	.-132    	; 0x1e4e <xQueueReceive+0x3c>
				{
					portYIELD_WITHIN_API();
    1ed2:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    1ed6:	21 e0       	ldi	r18, 0x01	; 1
    1ed8:	ba cf       	rjmp	.-140    	; 0x1e4e <xQueueReceive+0x3c>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1eda:	c8 01       	movw	r24, r16
    1edc:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ee0:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    1ee4:	21 e0       	ldi	r18, 0x01	; 1
    1ee6:	b3 cf       	rjmp	.-154    	; 0x1e4e <xQueueReceive+0x3c>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1ee8:	c8 01       	movw	r24, r16
    1eea:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1eee:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1ef2:	0f b6       	in	r0, 0x3f	; 63
    1ef4:	f8 94       	cli
    1ef6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1ef8:	f8 01       	movw	r30, r16
    1efa:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1efc:	0f 90       	pop	r0
    1efe:	0f be       	out	0x3f, r0	; 63
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f00:	81 11       	cpse	r24, r1
    1f02:	e5 cf       	rjmp	.-54     	; 0x1ece <xQueueReceive+0xbc>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1f04:	25 96       	adiw	r28, 0x05	; 5
    1f06:	cd bf       	out	0x3d, r28	; 61
    1f08:	de bf       	out	0x3e, r29	; 62
    1f0a:	df 91       	pop	r29
    1f0c:	cf 91       	pop	r28
    1f0e:	1f 91       	pop	r17
    1f10:	0f 91       	pop	r16
    1f12:	ff 90       	pop	r15
    1f14:	df 90       	pop	r13
    1f16:	cf 90       	pop	r12
    1f18:	bf 90       	pop	r11
    1f1a:	af 90       	pop	r10
    1f1c:	08 95       	ret
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1f1e:	ce 01       	movw	r24, r28
    1f20:	01 96       	adiw	r24, 0x01	; 1
    1f22:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vTaskInternalSetTimeOutState>
    1f26:	a2 cf       	rjmp	.-188    	; 0x1e6c <xQueueReceive+0x5a>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    1f28:	16 8e       	std	Z+30, r1	; 0x1e
    1f2a:	b1 cf       	rjmp	.-158    	; 0x1e8e <xQueueReceive+0x7c>
    1f2c:	15 8e       	std	Z+29, r1	; 0x1d
    1f2e:	aa cf       	rjmp	.-172    	; 0x1e84 <xQueueReceive+0x72>
			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f30:	b5 01       	movw	r22, r10
    1f32:	c8 01       	movw	r24, r16
    1f34:	0e 94 90 0c 	call	0x1920	; 0x1920 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1f38:	fa 94       	dec	r15
    1f3a:	f8 01       	movw	r30, r16
    1f3c:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f3e:	80 85       	ldd	r24, Z+8	; 0x08
    1f40:	81 11       	cpse	r24, r1
    1f42:	08 c0       	rjmp	.+16     	; 0x1f54 <xQueueReceive+0x142>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1f44:	0f 90       	pop	r0
    1f46:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f48:	81 e0       	ldi	r24, 0x01	; 1
    1f4a:	dc cf       	rjmp	.-72     	; 0x1f04 <xQueueReceive+0xf2>
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f4c:	0f 90       	pop	r0
    1f4e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f50:	80 e0       	ldi	r24, 0x00	; 0
    1f52:	d8 cf       	rjmp	.-80     	; 0x1f04 <xQueueReceive+0xf2>
				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f54:	c8 01       	movw	r24, r16
    1f56:	08 96       	adiw	r24, 0x08	; 8
    1f58:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    1f5c:	88 23       	and	r24, r24
    1f5e:	91 f3       	breq	.-28     	; 0x1f44 <xQueueReceive+0x132>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1f60:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    1f64:	ef cf       	rjmp	.-34     	; 0x1f44 <xQueueReceive+0x132>
	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1f66:	f8 01       	movw	r30, r16
    1f68:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f6a:	88 23       	and	r24, r24
    1f6c:	09 f4       	brne	.+2      	; 0x1f70 <xQueueReceive+0x15e>
    1f6e:	6a cf       	rjmp	.-300    	; 0x1e44 <xQueueReceive+0x32>
    1f70:	64 e0       	ldi	r22, 0x04	; 4
    1f72:	75 e0       	ldi	r23, 0x05	; 5
    1f74:	87 e2       	ldi	r24, 0x27	; 39
    1f76:	90 e2       	ldi	r25, 0x20	; 32
    1f78:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1f7c:	63 cf       	rjmp	.-314    	; 0x1e44 <xQueueReceive+0x32>
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    1f7e:	60 e0       	ldi	r22, 0x00	; 0
    1f80:	75 e0       	ldi	r23, 0x05	; 5
    1f82:	87 e2       	ldi	r24, 0x27	; 39
    1f84:	90 e2       	ldi	r25, 0x20	; 32
    1f86:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    1f8a:	58 cf       	rjmp	.-336    	; 0x1e3c <xQueueReceive+0x2a>

00001f8c <xQueueSemaphoreTake>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1f8c:	df 92       	push	r13
    1f8e:	ef 92       	push	r14
    1f90:	ff 92       	push	r15
    1f92:	0f 93       	push	r16
    1f94:	1f 93       	push	r17
    1f96:	cf 93       	push	r28
    1f98:	df 93       	push	r29
    1f9a:	cd b7       	in	r28, 0x3d	; 61
    1f9c:	de b7       	in	r29, 0x3e	; 62
    1f9e:	25 97       	sbiw	r28, 0x05	; 5
    1fa0:	cd bf       	out	0x3d, r28	; 61
    1fa2:	de bf       	out	0x3e, r29	; 62
    1fa4:	8c 01       	movw	r16, r24
    1fa6:	6c 83       	std	Y+4, r22	; 0x04
    1fa8:	7d 83       	std	Y+5, r23	; 0x05
#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    1faa:	89 2b       	or	r24, r25
    1fac:	09 f4       	brne	.+2      	; 0x1fb0 <xQueueSemaphoreTake+0x24>
    1fae:	d0 c0       	rjmp	.+416    	; 0x2150 <xQueueSemaphoreTake+0x1c4>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    1fb0:	d8 01       	movw	r26, r16
    1fb2:	5c 96       	adiw	r26, 0x1c	; 28
    1fb4:	8c 91       	ld	r24, X
    1fb6:	81 11       	cpse	r24, r1
    1fb8:	bb c0       	rjmp	.+374    	; 0x2130 <xQueueSemaphoreTake+0x1a4>
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1fba:	d1 2c       	mov	r13, r1
    1fbc:	20 e0       	ldi	r18, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fbe:	78 01       	movw	r14, r16
    1fc0:	b1 e1       	ldi	r27, 0x11	; 17
    1fc2:	eb 0e       	add	r14, r27
    1fc4:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1fc6:	0f b6       	in	r0, 0x3f	; 63
    1fc8:	f8 94       	cli
    1fca:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1fcc:	f8 01       	movw	r30, r16
    1fce:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1fd0:	81 11       	cpse	r24, r1
    1fd2:	89 c0       	rjmp	.+274    	; 0x20e6 <xQueueSemaphoreTake+0x15a>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1fd4:	8c 81       	ldd	r24, Y+4	; 0x04
    1fd6:	9d 81       	ldd	r25, Y+5	; 0x05
    1fd8:	89 2b       	or	r24, r25
    1fda:	09 f4       	brne	.+2      	; 0x1fde <xQueueSemaphoreTake+0x52>
    1fdc:	9d c0       	rjmp	.+314    	; 0x2118 <xQueueSemaphoreTake+0x18c>
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1fde:	22 23       	and	r18, r18
    1fe0:	09 f4       	brne	.+2      	; 0x1fe4 <xQueueSemaphoreTake+0x58>
    1fe2:	5f c0       	rjmp	.+190    	; 0x20a2 <xQueueSemaphoreTake+0x116>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1fe4:	0f 90       	pop	r0
    1fe6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1fe8:	0e 94 7e 15 	call	0x2afc	; 0x2afc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1fec:	0f b6       	in	r0, 0x3f	; 63
    1fee:	f8 94       	cli
    1ff0:	0f 92       	push	r0
    1ff2:	d8 01       	movw	r26, r16
    1ff4:	5d 96       	adiw	r26, 0x1d	; 29
    1ff6:	8c 91       	ld	r24, X
    1ff8:	5d 97       	sbiw	r26, 0x1d	; 29
    1ffa:	8f 3f       	cpi	r24, 0xFF	; 255
    1ffc:	09 f4       	brne	.+2      	; 0x2000 <xQueueSemaphoreTake+0x74>
    1ffe:	56 c0       	rjmp	.+172    	; 0x20ac <xQueueSemaphoreTake+0x120>
    2000:	f8 01       	movw	r30, r16
    2002:	86 8d       	ldd	r24, Z+30	; 0x1e
    2004:	8f 3f       	cpi	r24, 0xFF	; 255
    2006:	09 f4       	brne	.+2      	; 0x200a <xQueueSemaphoreTake+0x7e>
    2008:	58 c0       	rjmp	.+176    	; 0x20ba <xQueueSemaphoreTake+0x12e>
    200a:	0f 90       	pop	r0
    200c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    200e:	be 01       	movw	r22, r28
    2010:	6c 5f       	subi	r22, 0xFC	; 252
    2012:	7f 4f       	sbci	r23, 0xFF	; 255
    2014:	ce 01       	movw	r24, r28
    2016:	01 96       	adiw	r24, 0x01	; 1
    2018:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <xTaskCheckForTimeOut>
    201c:	81 11       	cpse	r24, r1
    201e:	23 c0       	rjmp	.+70     	; 0x2066 <xQueueSemaphoreTake+0xda>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2020:	0f b6       	in	r0, 0x3f	; 63
    2022:	f8 94       	cli
    2024:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2026:	d8 01       	movw	r26, r16
    2028:	5a 96       	adiw	r26, 0x1a	; 26
    202a:	8c 91       	ld	r24, X
    202c:	5a 97       	sbiw	r26, 0x1a	; 26
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    202e:	0f 90       	pop	r0
    2030:	0f be       	out	0x3f, r0	; 63
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2032:	81 11       	cpse	r24, r1
    2034:	44 c0       	rjmp	.+136    	; 0x20be <xQueueSemaphoreTake+0x132>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2036:	f8 01       	movw	r30, r16
    2038:	80 81       	ld	r24, Z
    203a:	91 81       	ldd	r25, Z+1	; 0x01
    203c:	89 2b       	or	r24, r25
    203e:	09 f4       	brne	.+2      	; 0x2042 <xQueueSemaphoreTake+0xb6>
    2040:	45 c0       	rjmp	.+138    	; 0x20cc <xQueueSemaphoreTake+0x140>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2042:	6c 81       	ldd	r22, Y+4	; 0x04
    2044:	7d 81       	ldd	r23, Y+5	; 0x05
    2046:	c7 01       	movw	r24, r14
    2048:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    204c:	c8 01       	movw	r24, r16
    204e:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2052:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    2056:	88 23       	and	r24, r24
    2058:	11 f0       	breq	.+4      	; 0x205e <xQueueSemaphoreTake+0xd2>
    205a:	21 e0       	ldi	r18, 0x01	; 1
    205c:	b4 cf       	rjmp	.-152    	; 0x1fc6 <xQueueSemaphoreTake+0x3a>
				{
					portYIELD_WITHIN_API();
    205e:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    2062:	21 e0       	ldi	r18, 0x01	; 1
    2064:	b0 cf       	rjmp	.-160    	; 0x1fc6 <xQueueSemaphoreTake+0x3a>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2066:	c8 01       	movw	r24, r16
    2068:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    206c:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2070:	0f b6       	in	r0, 0x3f	; 63
    2072:	f8 94       	cli
    2074:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2076:	f8 01       	movw	r30, r16
    2078:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    207a:	0f 90       	pop	r0
    207c:	0f be       	out	0x3f, r0	; 63

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    207e:	81 11       	cpse	r24, r1
    2080:	ec cf       	rjmp	.-40     	; 0x205a <xQueueSemaphoreTake+0xce>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    2082:	dd 20       	and	r13, r13
    2084:	09 f4       	brne	.+2      	; 0x2088 <xQueueSemaphoreTake+0xfc>
    2086:	72 c0       	rjmp	.+228    	; 0x216c <xQueueSemaphoreTake+0x1e0>
					{
						taskENTER_CRITICAL();
    2088:	0f b6       	in	r0, 0x3f	; 63
    208a:	f8 94       	cli
    208c:	0f 92       	push	r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    208e:	81 89       	ldd	r24, Z+17	; 0x11
    2090:	81 11       	cpse	r24, r1
    2092:	65 c0       	rjmp	.+202    	; 0x215e <xQueueSemaphoreTake+0x1d2>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    2094:	60 e0       	ldi	r22, 0x00	; 0
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    2096:	f8 01       	movw	r30, r16
    2098:	84 81       	ldd	r24, Z+4	; 0x04
    209a:	95 81       	ldd	r25, Z+5	; 0x05
    209c:	0e 94 23 19 	call	0x3246	; 0x3246 <vTaskPriorityDisinheritAfterTimeout>
    20a0:	43 c0       	rjmp	.+134    	; 0x2128 <xQueueSemaphoreTake+0x19c>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    20a2:	ce 01       	movw	r24, r28
    20a4:	01 96       	adiw	r24, 0x01	; 1
    20a6:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vTaskInternalSetTimeOutState>
    20aa:	9c cf       	rjmp	.-200    	; 0x1fe4 <xQueueSemaphoreTake+0x58>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    20ac:	5d 96       	adiw	r26, 0x1d	; 29
    20ae:	1c 92       	st	X, r1
    20b0:	f8 01       	movw	r30, r16
    20b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    20b4:	8f 3f       	cpi	r24, 0xFF	; 255
    20b6:	09 f0       	breq	.+2      	; 0x20ba <xQueueSemaphoreTake+0x12e>
    20b8:	a8 cf       	rjmp	.-176    	; 0x200a <xQueueSemaphoreTake+0x7e>
    20ba:	16 8e       	std	Z+30, r1	; 0x1e
    20bc:	a6 cf       	rjmp	.-180    	; 0x200a <xQueueSemaphoreTake+0x7e>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    20be:	c8 01       	movw	r24, r16
    20c0:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    20c4:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    20c8:	21 e0       	ldi	r18, 0x01	; 1
    20ca:	7d cf       	rjmp	.-262    	; 0x1fc6 <xQueueSemaphoreTake+0x3a>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						taskENTER_CRITICAL();
    20cc:	0f b6       	in	r0, 0x3f	; 63
    20ce:	f8 94       	cli
    20d0:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    20d2:	14 96       	adiw	r26, 0x04	; 4
    20d4:	8d 91       	ld	r24, X+
    20d6:	9c 91       	ld	r25, X
    20d8:	15 97       	sbiw	r26, 0x05	; 5
    20da:	0e 94 59 18 	call	0x30b2	; 0x30b2 <xTaskPriorityInherit>
    20de:	d8 2e       	mov	r13, r24
						}
						taskEXIT_CRITICAL();
    20e0:	0f 90       	pop	r0
    20e2:	0f be       	out	0x3f, r0	; 63
    20e4:	ae cf       	rjmp	.-164    	; 0x2042 <xQueueSemaphoreTake+0xb6>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    20e6:	81 50       	subi	r24, 0x01	; 1
    20e8:	82 8f       	std	Z+26, r24	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    20ea:	80 81       	ld	r24, Z
    20ec:	91 81       	ldd	r25, Z+1	; 0x01
    20ee:	89 2b       	or	r24, r25
    20f0:	09 f4       	brne	.+2      	; 0x20f4 <xQueueSemaphoreTake+0x168>
    20f2:	3e c0       	rjmp	.+124    	; 0x2170 <xQueueSemaphoreTake+0x1e4>
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20f4:	f8 01       	movw	r30, r16
    20f6:	80 85       	ldd	r24, Z+8	; 0x08
    20f8:	81 11       	cpse	r24, r1
    20fa:	21 c0       	rjmp	.+66     	; 0x213e <xQueueSemaphoreTake+0x1b2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    20fc:	0f 90       	pop	r0
    20fe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2100:	81 e0       	ldi	r24, 0x01	; 1
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    2102:	25 96       	adiw	r28, 0x05	; 5
    2104:	cd bf       	out	0x3d, r28	; 61
    2106:	de bf       	out	0x3e, r29	; 62
    2108:	df 91       	pop	r29
    210a:	cf 91       	pop	r28
    210c:	1f 91       	pop	r17
    210e:	0f 91       	pop	r16
    2110:	ff 90       	pop	r15
    2112:	ef 90       	pop	r14
    2114:	df 90       	pop	r13
    2116:	08 95       	ret
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
    2118:	dd 20       	and	r13, r13
    211a:	31 f0       	breq	.+12     	; 0x2128 <xQueueSemaphoreTake+0x19c>
    211c:	61 ee       	ldi	r22, 0xE1	; 225
    211e:	75 e0       	ldi	r23, 0x05	; 5
    2120:	87 e2       	ldi	r24, 0x27	; 39
    2122:	90 e2       	ldi	r25, 0x20	; 32
    2124:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
						}
						taskEXIT_CRITICAL();
    2128:	0f 90       	pop	r0
    212a:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    212c:	80 e0       	ldi	r24, 0x00	; 0
    212e:	e9 cf       	rjmp	.-46     	; 0x2102 <xQueueSemaphoreTake+0x176>
	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    2130:	65 e9       	ldi	r22, 0x95	; 149
    2132:	75 e0       	ldi	r23, 0x05	; 5
    2134:	87 e2       	ldi	r24, 0x27	; 39
    2136:	90 e2       	ldi	r25, 0x20	; 32
    2138:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    213c:	3e cf       	rjmp	.-388    	; 0x1fba <xQueueSemaphoreTake+0x2e>

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    213e:	c8 01       	movw	r24, r16
    2140:	08 96       	adiw	r24, 0x08	; 8
    2142:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    2146:	88 23       	and	r24, r24
    2148:	c9 f2       	breq	.-78     	; 0x20fc <xQueueSemaphoreTake+0x170>
					{
						queueYIELD_IF_USING_PREEMPTION();
    214a:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    214e:	d6 cf       	rjmp	.-84     	; 0x20fc <xQueueSemaphoreTake+0x170>
#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    2150:	61 e9       	ldi	r22, 0x91	; 145
    2152:	75 e0       	ldi	r23, 0x05	; 5
    2154:	87 e2       	ldi	r24, 0x27	; 39
    2156:	90 e2       	ldi	r25, 0x20	; 32
    2158:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    215c:	29 cf       	rjmp	.-430    	; 0x1fb0 <xQueueSemaphoreTake+0x24>
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    215e:	06 88       	ldd	r0, Z+22	; 0x16
    2160:	f7 89       	ldd	r31, Z+23	; 0x17
    2162:	e0 2d       	mov	r30, r0
    2164:	80 81       	ld	r24, Z
    2166:	6a e0       	ldi	r22, 0x0A	; 10
    2168:	68 1b       	sub	r22, r24
    216a:	95 cf       	rjmp	.-214    	; 0x2096 <xQueueSemaphoreTake+0x10a>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    216c:	80 e0       	ldi	r24, 0x00	; 0
    216e:	c9 cf       	rjmp	.-110    	; 0x2102 <xQueueSemaphoreTake+0x176>
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    2170:	0e 94 92 19 	call	0x3324	; 0x3324 <pvTaskIncrementMutexHeldCount>
    2174:	d8 01       	movw	r26, r16
    2176:	14 96       	adiw	r26, 0x04	; 4
    2178:	8d 93       	st	X+, r24
    217a:	9c 93       	st	X, r25
    217c:	15 97       	sbiw	r26, 0x05	; 5
    217e:	ba cf       	rjmp	.-140    	; 0x20f4 <xQueueSemaphoreTake+0x168>

00002180 <xQueuePeek>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2180:	cf 92       	push	r12
    2182:	df 92       	push	r13
    2184:	ef 92       	push	r14
    2186:	ff 92       	push	r15
    2188:	0f 93       	push	r16
    218a:	1f 93       	push	r17
    218c:	cf 93       	push	r28
    218e:	df 93       	push	r29
    2190:	cd b7       	in	r28, 0x3d	; 61
    2192:	de b7       	in	r29, 0x3e	; 62
    2194:	25 97       	sbiw	r28, 0x05	; 5
    2196:	cd bf       	out	0x3d, r28	; 61
    2198:	de bf       	out	0x3e, r29	; 62
    219a:	8c 01       	movw	r16, r24
    219c:	6b 01       	movw	r12, r22
    219e:	4c 83       	std	Y+4, r20	; 0x04
    21a0:	5d 83       	std	Y+5, r21	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    21a2:	89 2b       	or	r24, r25
    21a4:	09 f4       	brne	.+2      	; 0x21a8 <xQueuePeek+0x28>
    21a6:	a2 c0       	rjmp	.+324    	; 0x22ec <xQueuePeek+0x16c>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    21a8:	c1 14       	cp	r12, r1
    21aa:	d1 04       	cpc	r13, r1
    21ac:	09 f4       	brne	.+2      	; 0x21b0 <xQueuePeek+0x30>
    21ae:	92 c0       	rjmp	.+292    	; 0x22d4 <xQueuePeek+0x154>
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    21b0:	20 e0       	ldi	r18, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    21b2:	78 01       	movw	r14, r16
    21b4:	f1 e1       	ldi	r31, 0x11	; 17
    21b6:	ef 0e       	add	r14, r31
    21b8:	f1 1c       	adc	r15, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    21ba:	0f b6       	in	r0, 0x3f	; 63
    21bc:	f8 94       	cli
    21be:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    21c0:	f8 01       	movw	r30, r16
    21c2:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    21c4:	81 11       	cpse	r24, r1
    21c6:	69 c0       	rjmp	.+210    	; 0x229a <xQueuePeek+0x11a>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    21c8:	8c 81       	ldd	r24, Y+4	; 0x04
    21ca:	9d 81       	ldd	r25, Y+5	; 0x05
    21cc:	89 2b       	or	r24, r25
    21ce:	09 f4       	brne	.+2      	; 0x21d2 <xQueuePeek+0x52>
    21d0:	74 c0       	rjmp	.+232    	; 0x22ba <xQueuePeek+0x13a>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    21d2:	22 23       	and	r18, r18
    21d4:	09 f4       	brne	.+2      	; 0x21d8 <xQueuePeek+0x58>
    21d6:	58 c0       	rjmp	.+176    	; 0x2288 <xQueuePeek+0x108>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    21d8:	0f 90       	pop	r0
    21da:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    21dc:	0e 94 7e 15 	call	0x2afc	; 0x2afc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    21e0:	0f b6       	in	r0, 0x3f	; 63
    21e2:	f8 94       	cli
    21e4:	0f 92       	push	r0
    21e6:	f8 01       	movw	r30, r16
    21e8:	85 8d       	ldd	r24, Z+29	; 0x1d
    21ea:	8f 3f       	cpi	r24, 0xFF	; 255
    21ec:	09 f4       	brne	.+2      	; 0x21f0 <xQueuePeek+0x70>
    21ee:	53 c0       	rjmp	.+166    	; 0x2296 <xQueuePeek+0x116>
    21f0:	f8 01       	movw	r30, r16
    21f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    21f4:	8f 3f       	cpi	r24, 0xFF	; 255
    21f6:	09 f4       	brne	.+2      	; 0x21fa <xQueuePeek+0x7a>
    21f8:	4c c0       	rjmp	.+152    	; 0x2292 <xQueuePeek+0x112>
    21fa:	0f 90       	pop	r0
    21fc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    21fe:	be 01       	movw	r22, r28
    2200:	6c 5f       	subi	r22, 0xFC	; 252
    2202:	7f 4f       	sbci	r23, 0xFF	; 255
    2204:	ce 01       	movw	r24, r28
    2206:	01 96       	adiw	r24, 0x01	; 1
    2208:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <xTaskCheckForTimeOut>
    220c:	81 11       	cpse	r24, r1
    220e:	22 c0       	rjmp	.+68     	; 0x2254 <xQueuePeek+0xd4>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2210:	0f b6       	in	r0, 0x3f	; 63
    2212:	f8 94       	cli
    2214:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2216:	f8 01       	movw	r30, r16
    2218:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    221a:	0f 90       	pop	r0
    221c:	0f be       	out	0x3f, r0	; 63
		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    221e:	81 11       	cpse	r24, r1
    2220:	12 c0       	rjmp	.+36     	; 0x2246 <xQueuePeek+0xc6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2222:	6c 81       	ldd	r22, Y+4	; 0x04
    2224:	7d 81       	ldd	r23, Y+5	; 0x05
    2226:	c7 01       	movw	r24, r14
    2228:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    222c:	c8 01       	movw	r24, r16
    222e:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2232:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    2236:	88 23       	and	r24, r24
    2238:	11 f0       	breq	.+4      	; 0x223e <xQueuePeek+0xbe>
    223a:	21 e0       	ldi	r18, 0x01	; 1
    223c:	be cf       	rjmp	.-132    	; 0x21ba <xQueuePeek+0x3a>
				{
					portYIELD_WITHIN_API();
    223e:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    2242:	21 e0       	ldi	r18, 0x01	; 1
    2244:	ba cf       	rjmp	.-140    	; 0x21ba <xQueuePeek+0x3a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2246:	c8 01       	movw	r24, r16
    2248:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    224c:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    2250:	21 e0       	ldi	r18, 0x01	; 1
    2252:	b3 cf       	rjmp	.-154    	; 0x21ba <xQueuePeek+0x3a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2254:	c8 01       	movw	r24, r16
    2256:	0e 94 a8 0c 	call	0x1950	; 0x1950 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    225a:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    225e:	0f b6       	in	r0, 0x3f	; 63
    2260:	f8 94       	cli
    2262:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2264:	f8 01       	movw	r30, r16
    2266:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2268:	0f 90       	pop	r0
    226a:	0f be       	out	0x3f, r0	; 63
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    226c:	81 11       	cpse	r24, r1
    226e:	e5 cf       	rjmp	.-54     	; 0x223a <xQueuePeek+0xba>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    2270:	25 96       	adiw	r28, 0x05	; 5
    2272:	cd bf       	out	0x3d, r28	; 61
    2274:	de bf       	out	0x3e, r29	; 62
    2276:	df 91       	pop	r29
    2278:	cf 91       	pop	r28
    227a:	1f 91       	pop	r17
    227c:	0f 91       	pop	r16
    227e:	ff 90       	pop	r15
    2280:	ef 90       	pop	r14
    2282:	df 90       	pop	r13
    2284:	cf 90       	pop	r12
    2286:	08 95       	ret
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2288:	ce 01       	movw	r24, r28
    228a:	01 96       	adiw	r24, 0x01	; 1
    228c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vTaskInternalSetTimeOutState>
    2290:	a3 cf       	rjmp	.-186    	; 0x21d8 <xQueuePeek+0x58>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    2292:	16 8e       	std	Z+30, r1	; 0x1e
    2294:	b2 cf       	rjmp	.-156    	; 0x21fa <xQueuePeek+0x7a>
    2296:	15 8e       	std	Z+29, r1	; 0x1d
    2298:	ab cf       	rjmp	.-170    	; 0x21f0 <xQueuePeek+0x70>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    229a:	e6 80       	ldd	r14, Z+6	; 0x06
    229c:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    229e:	b6 01       	movw	r22, r12
    22a0:	c8 01       	movw	r24, r16
    22a2:	0e 94 90 0c 	call	0x1920	; 0x1920 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    22a6:	f8 01       	movw	r30, r16
    22a8:	e6 82       	std	Z+6, r14	; 0x06
    22aa:	f7 82       	std	Z+7, r15	; 0x07

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22ac:	81 89       	ldd	r24, Z+17	; 0x11
    22ae:	81 11       	cpse	r24, r1
    22b0:	08 c0       	rjmp	.+16     	; 0x22c2 <xQueuePeek+0x142>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    22b2:	0f 90       	pop	r0
    22b4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    22b6:	81 e0       	ldi	r24, 0x01	; 1
    22b8:	db cf       	rjmp	.-74     	; 0x2270 <xQueuePeek+0xf0>
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    22ba:	0f 90       	pop	r0
    22bc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    22be:	80 e0       	ldi	r24, 0x00	; 0
    22c0:	d7 cf       	rjmp	.-82     	; 0x2270 <xQueuePeek+0xf0>

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22c2:	c8 01       	movw	r24, r16
    22c4:	41 96       	adiw	r24, 0x11	; 17
    22c6:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    22ca:	88 23       	and	r24, r24
    22cc:	91 f3       	breq	.-28     	; 0x22b2 <xQueuePeek+0x132>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    22ce:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    22d2:	ef cf       	rjmp	.-34     	; 0x22b2 <xQueuePeek+0x132>
	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    22d4:	f8 01       	movw	r30, r16
    22d6:	84 8d       	ldd	r24, Z+28	; 0x1c
    22d8:	88 23       	and	r24, r24
    22da:	09 f4       	brne	.+2      	; 0x22de <xQueuePeek+0x15e>
    22dc:	69 cf       	rjmp	.-302    	; 0x21b0 <xQueuePeek+0x30>
    22de:	6c e6       	ldi	r22, 0x6C	; 108
    22e0:	76 e0       	ldi	r23, 0x06	; 6
    22e2:	87 e2       	ldi	r24, 0x27	; 39
    22e4:	90 e2       	ldi	r25, 0x20	; 32
    22e6:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    22ea:	62 cf       	rjmp	.-316    	; 0x21b0 <xQueuePeek+0x30>
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    22ec:	68 e6       	ldi	r22, 0x68	; 104
    22ee:	76 e0       	ldi	r23, 0x06	; 6
    22f0:	87 e2       	ldi	r24, 0x27	; 39
    22f2:	90 e2       	ldi	r25, 0x20	; 32
    22f4:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    22f8:	57 cf       	rjmp	.-338    	; 0x21a8 <xQueuePeek+0x28>

000022fa <xQueueReceiveFromISR>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    22fa:	cf 92       	push	r12
    22fc:	df 92       	push	r13
    22fe:	ef 92       	push	r14
    2300:	ff 92       	push	r15
    2302:	0f 93       	push	r16
    2304:	1f 93       	push	r17
    2306:	cf 93       	push	r28
    2308:	df 93       	push	r29
    230a:	ec 01       	movw	r28, r24
    230c:	7b 01       	movw	r14, r22
    230e:	6a 01       	movw	r12, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    2310:	89 2b       	or	r24, r25
    2312:	b9 f1       	breq	.+110    	; 0x2382 <xQueueReceiveFromISR+0x88>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2314:	e1 14       	cp	r14, r1
    2316:	f1 04       	cpc	r15, r1
    2318:	d1 f0       	breq	.+52     	; 0x234e <xQueueReceiveFromISR+0x54>
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    231a:	1a 8d       	ldd	r17, Y+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    231c:	11 11       	cpse	r17, r1
    231e:	0a c0       	rjmp	.+20     	; 0x2334 <xQueueReceiveFromISR+0x3a>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    2320:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2322:	df 91       	pop	r29
    2324:	cf 91       	pop	r28
    2326:	1f 91       	pop	r17
    2328:	0f 91       	pop	r16
    232a:	ff 90       	pop	r15
    232c:	ef 90       	pop	r14
    232e:	df 90       	pop	r13
    2330:	cf 90       	pop	r12
    2332:	08 95       	ret
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    2334:	0d 8d       	ldd	r16, Y+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2336:	b7 01       	movw	r22, r14
    2338:	ce 01       	movw	r24, r28
    233a:	0e 94 90 0c 	call	0x1920	; 0x1920 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    233e:	11 50       	subi	r17, 0x01	; 1
    2340:	1a 8f       	std	Y+26, r17	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    2342:	0f 3f       	cpi	r16, 0xFF	; 255
    2344:	71 f0       	breq	.+28     	; 0x2362 <xQueueReceiveFromISR+0x68>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2346:	0f 5f       	subi	r16, 0xFF	; 255
    2348:	0d 8f       	std	Y+29, r16	; 0x1d
			}

			xReturn = pdPASS;
    234a:	81 e0       	ldi	r24, 0x01	; 1
    234c:	ea cf       	rjmp	.-44     	; 0x2322 <xQueueReceiveFromISR+0x28>
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    234e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2350:	88 23       	and	r24, r24
    2352:	19 f3       	breq	.-58     	; 0x231a <xQueueReceiveFromISR+0x20>
    2354:	6c ef       	ldi	r22, 0xFC	; 252
    2356:	76 e0       	ldi	r23, 0x06	; 6
    2358:	87 e2       	ldi	r24, 0x27	; 39
    235a:	90 e2       	ldi	r25, 0x20	; 32
    235c:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2360:	dc cf       	rjmp	.-72     	; 0x231a <xQueueReceiveFromISR+0x20>
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2362:	88 85       	ldd	r24, Y+8	; 0x08
    2364:	88 23       	and	r24, r24
    2366:	89 f3       	breq	.-30     	; 0x234a <xQueueReceiveFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2368:	ce 01       	movw	r24, r28
    236a:	08 96       	adiw	r24, 0x08	; 8
    236c:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskRemoveFromEventList>
    2370:	88 23       	and	r24, r24
    2372:	59 f3       	breq	.-42     	; 0x234a <xQueueReceiveFromISR+0x50>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2374:	c1 14       	cp	r12, r1
    2376:	d1 04       	cpc	r13, r1
    2378:	41 f3       	breq	.-48     	; 0x234a <xQueueReceiveFromISR+0x50>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    237a:	81 e0       	ldi	r24, 0x01	; 1
    237c:	f6 01       	movw	r30, r12
    237e:	80 83       	st	Z, r24
    2380:	d0 cf       	rjmp	.-96     	; 0x2322 <xQueueReceiveFromISR+0x28>
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    2382:	6b ef       	ldi	r22, 0xFB	; 251
    2384:	76 e0       	ldi	r23, 0x06	; 6
    2386:	87 e2       	ldi	r24, 0x27	; 39
    2388:	90 e2       	ldi	r25, 0x20	; 32
    238a:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    238e:	c2 cf       	rjmp	.-124    	; 0x2314 <xQueueReceiveFromISR+0x1a>

00002390 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    2390:	20 c0       	rjmp	.+64     	; 0x23d2 <prvIdleTask+0x42>
    2392:	0f b6       	in	r0, 0x3f	; 63
    2394:	f8 94       	cli
    2396:	0f 92       	push	r0
    2398:	e0 91 81 21 	lds	r30, 0x2181	; 0x802181 <xTasksWaitingTermination+0x5>
    239c:	f0 91 82 21 	lds	r31, 0x2182	; 0x802182 <xTasksWaitingTermination+0x6>
    23a0:	c6 81       	ldd	r28, Z+6	; 0x06
    23a2:	d7 81       	ldd	r29, Z+7	; 0x07
    23a4:	ce 01       	movw	r24, r28
    23a6:	02 96       	adiw	r24, 0x02	; 2
    23a8:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    23ac:	80 91 71 21 	lds	r24, 0x2171	; 0x802171 <uxCurrentNumberOfTasks>
    23b0:	81 50       	subi	r24, 0x01	; 1
    23b2:	80 93 71 21 	sts	0x2171, r24	; 0x802171 <uxCurrentNumberOfTasks>
    23b6:	80 91 7b 21 	lds	r24, 0x217B	; 0x80217b <uxDeletedTasksWaitingCleanUp>
    23ba:	81 50       	subi	r24, 0x01	; 1
    23bc:	80 93 7b 21 	sts	0x217B, r24	; 0x80217b <uxDeletedTasksWaitingCleanUp>
    23c0:	0f 90       	pop	r0
    23c2:	0f be       	out	0x3f, r0	; 63
    23c4:	8f 89       	ldd	r24, Y+23	; 0x17
    23c6:	98 8d       	ldd	r25, Y+24	; 0x18
    23c8:	0e 94 86 09 	call	0x130c	; 0x130c <vPortFree>
    23cc:	ce 01       	movw	r24, r28
    23ce:	0e 94 86 09 	call	0x130c	; 0x130c <vPortFree>
    23d2:	80 91 7b 21 	lds	r24, 0x217B	; 0x80217b <uxDeletedTasksWaitingCleanUp>
    23d6:	81 11       	cpse	r24, r1
    23d8:	dc cf       	rjmp	.-72     	; 0x2392 <prvIdleTask+0x2>
    23da:	80 91 a4 21 	lds	r24, 0x21A4	; 0x8021a4 <pxReadyTasksLists>
    23de:	82 30       	cpi	r24, 0x02	; 2
    23e0:	10 f0       	brcs	.+4      	; 0x23e6 <prvIdleTask+0x56>
    23e2:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    23e6:	0e 94 a4 19 	call	0x3348	; 0x3348 <vApplicationIdleHook>
    23ea:	f3 cf       	rjmp	.-26     	; 0x23d2 <prvIdleTask+0x42>

000023ec <prvResetNextTaskUnblockTime.part.0>:
    23ec:	e0 91 90 21 	lds	r30, 0x2190	; 0x802190 <pxDelayedTaskList>
    23f0:	f0 91 91 21 	lds	r31, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    23f4:	05 80       	ldd	r0, Z+5	; 0x05
    23f6:	f6 81       	ldd	r31, Z+6	; 0x06
    23f8:	e0 2d       	mov	r30, r0
    23fa:	06 80       	ldd	r0, Z+6	; 0x06
    23fc:	f7 81       	ldd	r31, Z+7	; 0x07
    23fe:	e0 2d       	mov	r30, r0
    2400:	82 81       	ldd	r24, Z+2	; 0x02
    2402:	93 81       	ldd	r25, Z+3	; 0x03
    2404:	80 93 67 21 	sts	0x2167, r24	; 0x802167 <xNextTaskUnblockTime>
    2408:	90 93 68 21 	sts	0x2168, r25	; 0x802168 <xNextTaskUnblockTime+0x1>
    240c:	08 95       	ret

0000240e <prvTaskIsTaskSuspended>:
    240e:	cf 93       	push	r28
    2410:	df 93       	push	r29
    2412:	ec 01       	movw	r28, r24
    2414:	89 2b       	or	r24, r25
    2416:	99 f0       	breq	.+38     	; 0x243e <prvTaskIsTaskSuspended+0x30>
    2418:	8a 85       	ldd	r24, Y+10	; 0x0a
    241a:	9b 85       	ldd	r25, Y+11	; 0x0b
    241c:	82 57       	subi	r24, 0x72	; 114
    241e:	91 42       	sbci	r25, 0x21	; 33
    2420:	21 f0       	breq	.+8      	; 0x242a <prvTaskIsTaskSuspended+0x1c>
    2422:	80 e0       	ldi	r24, 0x00	; 0
    2424:	df 91       	pop	r29
    2426:	cf 91       	pop	r28
    2428:	08 95       	ret
    242a:	2c 89       	ldd	r18, Y+20	; 0x14
    242c:	3d 89       	ldd	r19, Y+21	; 0x15
    242e:	81 e2       	ldi	r24, 0x21	; 33
    2430:	25 38       	cpi	r18, 0x85	; 133
    2432:	38 07       	cpc	r19, r24
    2434:	b1 f3       	breq	.-20     	; 0x2422 <prvTaskIsTaskSuspended+0x14>
    2436:	81 e0       	ldi	r24, 0x01	; 1
    2438:	23 2b       	or	r18, r19
    243a:	99 f7       	brne	.-26     	; 0x2422 <prvTaskIsTaskSuspended+0x14>
    243c:	f3 cf       	rjmp	.-26     	; 0x2424 <prvTaskIsTaskSuspended+0x16>
    243e:	62 ef       	ldi	r22, 0xF2	; 242
    2440:	76 e0       	ldi	r23, 0x06	; 6
    2442:	8b e3       	ldi	r24, 0x3B	; 59
    2444:	90 e2       	ldi	r25, 0x20	; 32
    2446:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    244a:	e6 cf       	rjmp	.-52     	; 0x2418 <prvTaskIsTaskSuspended+0xa>

0000244c <prvAddCurrentTaskToDelayedList>:
    244c:	ff 92       	push	r15
    244e:	0f 93       	push	r16
    2450:	1f 93       	push	r17
    2452:	cf 93       	push	r28
    2454:	df 93       	push	r29
    2456:	ec 01       	movw	r28, r24
    2458:	f6 2e       	mov	r15, r22
    245a:	00 91 6f 21 	lds	r16, 0x216F	; 0x80216f <xTickCount>
    245e:	10 91 70 21 	lds	r17, 0x2170	; 0x802170 <xTickCount+0x1>
    2462:	80 91 fe 21 	lds	r24, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2466:	90 91 ff 21 	lds	r25, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    246a:	02 96       	adiw	r24, 0x02	; 2
    246c:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2470:	cf 3f       	cpi	r28, 0xFF	; 255
    2472:	8f ef       	ldi	r24, 0xFF	; 255
    2474:	d8 07       	cpc	r29, r24
    2476:	a9 f1       	breq	.+106    	; 0x24e2 <prvAddCurrentTaskToDelayedList+0x96>
    2478:	c0 0f       	add	r28, r16
    247a:	d1 1f       	adc	r29, r17
    247c:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2480:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2484:	c2 83       	std	Z+2, r28	; 0x02
    2486:	d3 83       	std	Z+3, r29	; 0x03
    2488:	60 91 fe 21 	lds	r22, 0x21FE	; 0x8021fe <pxCurrentTCB>
    248c:	70 91 ff 21 	lds	r23, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2490:	c0 17       	cp	r28, r16
    2492:	d1 07       	cpc	r29, r17
    2494:	c8 f0       	brcs	.+50     	; 0x24c8 <prvAddCurrentTaskToDelayedList+0x7c>
    2496:	80 91 90 21 	lds	r24, 0x2190	; 0x802190 <pxDelayedTaskList>
    249a:	90 91 91 21 	lds	r25, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    249e:	6e 5f       	subi	r22, 0xFE	; 254
    24a0:	7f 4f       	sbci	r23, 0xFF	; 255
    24a2:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <vListInsert>
    24a6:	80 91 67 21 	lds	r24, 0x2167	; 0x802167 <xNextTaskUnblockTime>
    24aa:	90 91 68 21 	lds	r25, 0x2168	; 0x802168 <xNextTaskUnblockTime+0x1>
    24ae:	c8 17       	cp	r28, r24
    24b0:	d9 07       	cpc	r29, r25
    24b2:	20 f4       	brcc	.+8      	; 0x24bc <prvAddCurrentTaskToDelayedList+0x70>
    24b4:	c0 93 67 21 	sts	0x2167, r28	; 0x802167 <xNextTaskUnblockTime>
    24b8:	d0 93 68 21 	sts	0x2168, r29	; 0x802168 <xNextTaskUnblockTime+0x1>
    24bc:	df 91       	pop	r29
    24be:	cf 91       	pop	r28
    24c0:	1f 91       	pop	r17
    24c2:	0f 91       	pop	r16
    24c4:	ff 90       	pop	r15
    24c6:	08 95       	ret
    24c8:	80 91 8e 21 	lds	r24, 0x218E	; 0x80218e <pxOverflowDelayedTaskList>
    24cc:	90 91 8f 21 	lds	r25, 0x218F	; 0x80218f <pxOverflowDelayedTaskList+0x1>
    24d0:	6e 5f       	subi	r22, 0xFE	; 254
    24d2:	7f 4f       	sbci	r23, 0xFF	; 255
    24d4:	df 91       	pop	r29
    24d6:	cf 91       	pop	r28
    24d8:	1f 91       	pop	r17
    24da:	0f 91       	pop	r16
    24dc:	ff 90       	pop	r15
    24de:	0c 94 e4 09 	jmp	0x13c8	; 0x13c8 <vListInsert>
    24e2:	ff 20       	and	r15, r15
    24e4:	49 f2       	breq	.-110    	; 0x2478 <prvAddCurrentTaskToDelayedList+0x2c>
    24e6:	60 91 fe 21 	lds	r22, 0x21FE	; 0x8021fe <pxCurrentTCB>
    24ea:	70 91 ff 21 	lds	r23, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    24ee:	6e 5f       	subi	r22, 0xFE	; 254
    24f0:	7f 4f       	sbci	r23, 0xFF	; 255
    24f2:	82 e7       	ldi	r24, 0x72	; 114
    24f4:	91 e2       	ldi	r25, 0x21	; 33
    24f6:	df 91       	pop	r29
    24f8:	cf 91       	pop	r28
    24fa:	1f 91       	pop	r17
    24fc:	0f 91       	pop	r16
    24fe:	ff 90       	pop	r15
    2500:	0c 94 c3 09 	jmp	0x1386	; 0x1386 <vListInsertEnd>

00002504 <vTaskSwitchContext.part.5>:
    2504:	0f 93       	push	r16
    2506:	1f 93       	push	r17
    2508:	cf 93       	push	r28
    250a:	10 92 6b 21 	sts	0x216B, r1	; 0x80216b <xYieldPending>
    250e:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2512:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2516:	80 91 20 22 	lds	r24, 0x2220	; 0x802220 <StatsTimer>
    251a:	90 91 21 22 	lds	r25, 0x2221	; 0x802221 <StatsTimer+0x1>
    251e:	a0 91 22 22 	lds	r26, 0x2222	; 0x802222 <StatsTimer+0x2>
    2522:	b0 91 23 22 	lds	r27, 0x2223	; 0x802223 <StatsTimer+0x3>
    2526:	82 0f       	add	r24, r18
    2528:	93 1f       	adc	r25, r19
    252a:	a1 1d       	adc	r26, r1
    252c:	b1 1d       	adc	r27, r1
    252e:	00 91 60 21 	lds	r16, 0x2160	; 0x802160 <ulTaskSwitchedInTime>
    2532:	10 91 61 21 	lds	r17, 0x2161	; 0x802161 <ulTaskSwitchedInTime+0x1>
    2536:	20 91 62 21 	lds	r18, 0x2162	; 0x802162 <ulTaskSwitchedInTime+0x2>
    253a:	30 91 63 21 	lds	r19, 0x2163	; 0x802163 <ulTaskSwitchedInTime+0x3>
    253e:	08 17       	cp	r16, r24
    2540:	19 07       	cpc	r17, r25
    2542:	2a 07       	cpc	r18, r26
    2544:	3b 07       	cpc	r19, r27
    2546:	a0 f4       	brcc	.+40     	; 0x2570 <vTaskSwitchContext.part.5+0x6c>
    2548:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    254c:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2550:	47 a1       	ldd	r20, Z+39	; 0x27
    2552:	50 a5       	ldd	r21, Z+40	; 0x28
    2554:	61 a5       	ldd	r22, Z+41	; 0x29
    2556:	72 a5       	ldd	r23, Z+42	; 0x2a
    2558:	40 1b       	sub	r20, r16
    255a:	51 0b       	sbc	r21, r17
    255c:	62 0b       	sbc	r22, r18
    255e:	73 0b       	sbc	r23, r19
    2560:	48 0f       	add	r20, r24
    2562:	59 1f       	adc	r21, r25
    2564:	6a 1f       	adc	r22, r26
    2566:	7b 1f       	adc	r23, r27
    2568:	47 a3       	std	Z+39, r20	; 0x27
    256a:	50 a7       	std	Z+40, r21	; 0x28
    256c:	61 a7       	std	Z+41, r22	; 0x29
    256e:	72 a7       	std	Z+42, r23	; 0x2a
    2570:	80 93 60 21 	sts	0x2160, r24	; 0x802160 <ulTaskSwitchedInTime>
    2574:	90 93 61 21 	sts	0x2161, r25	; 0x802161 <ulTaskSwitchedInTime+0x1>
    2578:	a0 93 62 21 	sts	0x2162, r26	; 0x802162 <ulTaskSwitchedInTime+0x2>
    257c:	b0 93 63 21 	sts	0x2163, r27	; 0x802163 <ulTaskSwitchedInTime+0x3>
    2580:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2584:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2588:	07 88       	ldd	r0, Z+23	; 0x17
    258a:	f0 8d       	ldd	r31, Z+24	; 0x18
    258c:	e0 2d       	mov	r30, r0
    258e:	80 81       	ld	r24, Z
    2590:	91 81       	ldd	r25, Z+1	; 0x01
    2592:	a2 81       	ldd	r26, Z+2	; 0x02
    2594:	b3 81       	ldd	r27, Z+3	; 0x03
    2596:	85 3a       	cpi	r24, 0xA5	; 165
    2598:	95 4a       	sbci	r25, 0xA5	; 165
    259a:	a5 4a       	sbci	r26, 0xA5	; 165
    259c:	b5 4a       	sbci	r27, 0xA5	; 165
    259e:	09 f4       	brne	.+2      	; 0x25a2 <vTaskSwitchContext.part.5+0x9e>
    25a0:	4c c0       	rjmp	.+152    	; 0x263a <vTaskSwitchContext.part.5+0x136>
    25a2:	60 91 fe 21 	lds	r22, 0x21FE	; 0x8021fe <pxCurrentTCB>
    25a6:	70 91 ff 21 	lds	r23, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    25aa:	80 91 fe 21 	lds	r24, 0x21FE	; 0x8021fe <pxCurrentTCB>
    25ae:	90 91 ff 21 	lds	r25, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    25b2:	67 5e       	subi	r22, 0xE7	; 231
    25b4:	7f 4f       	sbci	r23, 0xFF	; 255
    25b6:	0e 94 c4 19 	call	0x3388	; 0x3388 <vApplicationStackOverflowHook>
    25ba:	c0 91 6e 21 	lds	r28, 0x216E	; 0x80216e <uxTopReadyPriority>
    25be:	8c 2f       	mov	r24, r28
    25c0:	90 e0       	ldi	r25, 0x00	; 0
    25c2:	9c 01       	movw	r18, r24
    25c4:	22 0f       	add	r18, r18
    25c6:	33 1f       	adc	r19, r19
    25c8:	22 0f       	add	r18, r18
    25ca:	33 1f       	adc	r19, r19
    25cc:	22 0f       	add	r18, r18
    25ce:	33 1f       	adc	r19, r19
    25d0:	f9 01       	movw	r30, r18
    25d2:	e8 0f       	add	r30, r24
    25d4:	f9 1f       	adc	r31, r25
    25d6:	ec 55       	subi	r30, 0x5C	; 92
    25d8:	fe 4d       	sbci	r31, 0xDE	; 222
    25da:	40 81       	ld	r20, Z
    25dc:	41 11       	cpse	r20, r1
    25de:	0c c0       	rjmp	.+24     	; 0x25f8 <vTaskSwitchContext.part.5+0xf4>
    25e0:	cc 23       	and	r28, r28
    25e2:	11 f0       	breq	.+4      	; 0x25e8 <vTaskSwitchContext.part.5+0xe4>
    25e4:	c1 50       	subi	r28, 0x01	; 1
    25e6:	eb cf       	rjmp	.-42     	; 0x25be <vTaskSwitchContext.part.5+0xba>
    25e8:	6c e8       	ldi	r22, 0x8C	; 140
    25ea:	7b e0       	ldi	r23, 0x0B	; 11
    25ec:	8b e3       	ldi	r24, 0x3B	; 59
    25ee:	90 e2       	ldi	r25, 0x20	; 32
    25f0:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    25f4:	c1 50       	subi	r28, 0x01	; 1
    25f6:	e3 cf       	rjmp	.-58     	; 0x25be <vTaskSwitchContext.part.5+0xba>
    25f8:	82 0f       	add	r24, r18
    25fa:	93 1f       	adc	r25, r19
    25fc:	dc 01       	movw	r26, r24
    25fe:	ac 55       	subi	r26, 0x5C	; 92
    2600:	be 4d       	sbci	r27, 0xDE	; 222
    2602:	11 96       	adiw	r26, 0x01	; 1
    2604:	ed 91       	ld	r30, X+
    2606:	fc 91       	ld	r31, X
    2608:	12 97       	sbiw	r26, 0x02	; 2
    260a:	02 80       	ldd	r0, Z+2	; 0x02
    260c:	f3 81       	ldd	r31, Z+3	; 0x03
    260e:	e0 2d       	mov	r30, r0
    2610:	11 96       	adiw	r26, 0x01	; 1
    2612:	ed 93       	st	X+, r30
    2614:	fc 93       	st	X, r31
    2616:	12 97       	sbiw	r26, 0x02	; 2
    2618:	89 55       	subi	r24, 0x59	; 89
    261a:	9e 4d       	sbci	r25, 0xDE	; 222
    261c:	e8 17       	cp	r30, r24
    261e:	f9 07       	cpc	r31, r25
    2620:	59 f1       	breq	.+86     	; 0x2678 <vTaskSwitchContext.part.5+0x174>
    2622:	86 81       	ldd	r24, Z+6	; 0x06
    2624:	97 81       	ldd	r25, Z+7	; 0x07
    2626:	80 93 fe 21 	sts	0x21FE, r24	; 0x8021fe <pxCurrentTCB>
    262a:	90 93 ff 21 	sts	0x21FF, r25	; 0x8021ff <pxCurrentTCB+0x1>
    262e:	c0 93 6e 21 	sts	0x216E, r28	; 0x80216e <uxTopReadyPriority>
    2632:	cf 91       	pop	r28
    2634:	1f 91       	pop	r17
    2636:	0f 91       	pop	r16
    2638:	08 95       	ret
    263a:	84 81       	ldd	r24, Z+4	; 0x04
    263c:	95 81       	ldd	r25, Z+5	; 0x05
    263e:	a6 81       	ldd	r26, Z+6	; 0x06
    2640:	b7 81       	ldd	r27, Z+7	; 0x07
    2642:	85 3a       	cpi	r24, 0xA5	; 165
    2644:	95 4a       	sbci	r25, 0xA5	; 165
    2646:	a5 4a       	sbci	r26, 0xA5	; 165
    2648:	b5 4a       	sbci	r27, 0xA5	; 165
    264a:	09 f0       	breq	.+2      	; 0x264e <vTaskSwitchContext.part.5+0x14a>
    264c:	aa cf       	rjmp	.-172    	; 0x25a2 <vTaskSwitchContext.part.5+0x9e>
    264e:	80 85       	ldd	r24, Z+8	; 0x08
    2650:	91 85       	ldd	r25, Z+9	; 0x09
    2652:	a2 85       	ldd	r26, Z+10	; 0x0a
    2654:	b3 85       	ldd	r27, Z+11	; 0x0b
    2656:	85 3a       	cpi	r24, 0xA5	; 165
    2658:	95 4a       	sbci	r25, 0xA5	; 165
    265a:	a5 4a       	sbci	r26, 0xA5	; 165
    265c:	b5 4a       	sbci	r27, 0xA5	; 165
    265e:	09 f0       	breq	.+2      	; 0x2662 <vTaskSwitchContext.part.5+0x15e>
    2660:	a0 cf       	rjmp	.-192    	; 0x25a2 <vTaskSwitchContext.part.5+0x9e>
    2662:	84 85       	ldd	r24, Z+12	; 0x0c
    2664:	95 85       	ldd	r25, Z+13	; 0x0d
    2666:	a6 85       	ldd	r26, Z+14	; 0x0e
    2668:	b7 85       	ldd	r27, Z+15	; 0x0f
    266a:	85 3a       	cpi	r24, 0xA5	; 165
    266c:	95 4a       	sbci	r25, 0xA5	; 165
    266e:	a5 4a       	sbci	r26, 0xA5	; 165
    2670:	b5 4a       	sbci	r27, 0xA5	; 165
    2672:	09 f0       	breq	.+2      	; 0x2676 <vTaskSwitchContext.part.5+0x172>
    2674:	96 cf       	rjmp	.-212    	; 0x25a2 <vTaskSwitchContext.part.5+0x9e>
    2676:	a1 cf       	rjmp	.-190    	; 0x25ba <vTaskSwitchContext.part.5+0xb6>
    2678:	02 80       	ldd	r0, Z+2	; 0x02
    267a:	f3 81       	ldd	r31, Z+3	; 0x03
    267c:	e0 2d       	mov	r30, r0
    267e:	11 96       	adiw	r26, 0x01	; 1
    2680:	ed 93       	st	X+, r30
    2682:	fc 93       	st	X, r31
    2684:	12 97       	sbiw	r26, 0x02	; 2
    2686:	cd cf       	rjmp	.-102    	; 0x2622 <vTaskSwitchContext.part.5+0x11e>

00002688 <xTaskCreate>:
    2688:	5f 92       	push	r5
    268a:	6f 92       	push	r6
    268c:	7f 92       	push	r7
    268e:	8f 92       	push	r8
    2690:	9f 92       	push	r9
    2692:	af 92       	push	r10
    2694:	bf 92       	push	r11
    2696:	cf 92       	push	r12
    2698:	df 92       	push	r13
    269a:	ef 92       	push	r14
    269c:	ff 92       	push	r15
    269e:	0f 93       	push	r16
    26a0:	1f 93       	push	r17
    26a2:	cf 93       	push	r28
    26a4:	df 93       	push	r29
    26a6:	4c 01       	movw	r8, r24
    26a8:	eb 01       	movw	r28, r22
    26aa:	5a 01       	movw	r10, r20
    26ac:	39 01       	movw	r6, r18
    26ae:	50 2e       	mov	r5, r16
    26b0:	ca 01       	movw	r24, r20
    26b2:	0e 94 e7 08 	call	0x11ce	; 0x11ce <pvPortMalloc>
    26b6:	8c 01       	movw	r16, r24
    26b8:	89 2b       	or	r24, r25
    26ba:	09 f4       	brne	.+2      	; 0x26be <xTaskCreate+0x36>
    26bc:	de c0       	rjmp	.+444    	; 0x287a <xTaskCreate+0x1f2>
    26be:	80 e3       	ldi	r24, 0x30	; 48
    26c0:	90 e0       	ldi	r25, 0x00	; 0
    26c2:	0e 94 e7 08 	call	0x11ce	; 0x11ce <pvPortMalloc>
    26c6:	6c 01       	movw	r12, r24
    26c8:	00 97       	sbiw	r24, 0x00	; 0
    26ca:	09 f4       	brne	.+2      	; 0x26ce <xTaskCreate+0x46>
    26cc:	d3 c0       	rjmp	.+422    	; 0x2874 <xTaskCreate+0x1ec>
    26ce:	dc 01       	movw	r26, r24
    26d0:	57 96       	adiw	r26, 0x17	; 23
    26d2:	0d 93       	st	X+, r16
    26d4:	1c 93       	st	X, r17
    26d6:	58 97       	sbiw	r26, 0x18	; 24
    26d8:	20 97       	sbiw	r28, 0x00	; 0
    26da:	09 f4       	brne	.+2      	; 0x26de <xTaskCreate+0x56>
    26dc:	d0 c0       	rjmp	.+416    	; 0x287e <xTaskCreate+0x1f6>
    26de:	c8 01       	movw	r24, r16
    26e0:	a5 01       	movw	r20, r10
    26e2:	65 ea       	ldi	r22, 0xA5	; 165
    26e4:	70 e0       	ldi	r23, 0x00	; 0
    26e6:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <memset>
    26ea:	f1 e0       	ldi	r31, 0x01	; 1
    26ec:	af 1a       	sub	r10, r31
    26ee:	b1 08       	sbc	r11, r1
    26f0:	d6 01       	movw	r26, r12
    26f2:	57 96       	adiw	r26, 0x17	; 23
    26f4:	8d 91       	ld	r24, X+
    26f6:	9c 91       	ld	r25, X
    26f8:	58 97       	sbiw	r26, 0x18	; 24
    26fa:	a8 0e       	add	r10, r24
    26fc:	b9 1e       	adc	r11, r25
    26fe:	f6 01       	movw	r30, r12
    2700:	79 96       	adiw	r30, 0x19	; 25
    2702:	9e 01       	movw	r18, r28
    2704:	28 5f       	subi	r18, 0xF8	; 248
    2706:	3f 4f       	sbci	r19, 0xFF	; 255
    2708:	de 01       	movw	r26, r28
    270a:	89 91       	ld	r24, Y+
    270c:	81 93       	st	Z+, r24
    270e:	8c 91       	ld	r24, X
    2710:	88 23       	and	r24, r24
    2712:	19 f0       	breq	.+6      	; 0x271a <xTaskCreate+0x92>
    2714:	c2 17       	cp	r28, r18
    2716:	d3 07       	cpc	r29, r19
    2718:	b9 f7       	brne	.-18     	; 0x2708 <xTaskCreate+0x80>
    271a:	f6 01       	movw	r30, r12
    271c:	10 a2       	std	Z+32, r1	; 0x20
    271e:	05 2d       	mov	r16, r5
    2720:	0a 30       	cpi	r16, 0x0A	; 10
    2722:	08 f0       	brcs	.+2      	; 0x2726 <xTaskCreate+0x9e>
    2724:	a1 c0       	rjmp	.+322    	; 0x2868 <xTaskCreate+0x1e0>
    2726:	d6 01       	movw	r26, r12
    2728:	56 96       	adiw	r26, 0x16	; 22
    272a:	0c 93       	st	X, r16
    272c:	56 97       	sbiw	r26, 0x16	; 22
    272e:	93 96       	adiw	r26, 0x23	; 35
    2730:	0c 93       	st	X, r16
    2732:	93 97       	sbiw	r26, 0x23	; 35
    2734:	94 96       	adiw	r26, 0x24	; 36
    2736:	1c 92       	st	X, r1
    2738:	e6 01       	movw	r28, r12
    273a:	22 96       	adiw	r28, 0x02	; 2
    273c:	ce 01       	movw	r24, r28
    273e:	0e 94 bf 09 	call	0x137e	; 0x137e <vListInitialiseItem>
    2742:	c6 01       	movw	r24, r12
    2744:	0c 96       	adiw	r24, 0x0c	; 12
    2746:	0e 94 bf 09 	call	0x137e	; 0x137e <vListInitialiseItem>
    274a:	f6 01       	movw	r30, r12
    274c:	c0 86       	std	Z+8, r12	; 0x08
    274e:	d1 86       	std	Z+9, r13	; 0x09
    2750:	8a e0       	ldi	r24, 0x0A	; 10
    2752:	90 e0       	ldi	r25, 0x00	; 0
    2754:	80 1b       	sub	r24, r16
    2756:	91 09       	sbc	r25, r1
    2758:	84 87       	std	Z+12, r24	; 0x0c
    275a:	95 87       	std	Z+13, r25	; 0x0d
    275c:	c2 8a       	std	Z+18, r12	; 0x12
    275e:	d3 8a       	std	Z+19, r13	; 0x13
    2760:	15 a2       	std	Z+37, r1	; 0x25
    2762:	16 a2       	std	Z+38, r1	; 0x26
    2764:	17 a2       	std	Z+39, r1	; 0x27
    2766:	10 a6       	std	Z+40, r1	; 0x28
    2768:	11 a6       	std	Z+41, r1	; 0x29
    276a:	12 a6       	std	Z+42, r1	; 0x2a
    276c:	13 a6       	std	Z+43, r1	; 0x2b
    276e:	14 a6       	std	Z+44, r1	; 0x2c
    2770:	15 a6       	std	Z+45, r1	; 0x2d
    2772:	16 a6       	std	Z+46, r1	; 0x2e
    2774:	17 a6       	std	Z+47, r1	; 0x2f
    2776:	a3 01       	movw	r20, r6
    2778:	b4 01       	movw	r22, r8
    277a:	c5 01       	movw	r24, r10
    277c:	0e 94 3b 0a 	call	0x1476	; 0x1476 <pxPortInitialiseStack>
    2780:	d6 01       	movw	r26, r12
    2782:	8d 93       	st	X+, r24
    2784:	9c 93       	st	X, r25
    2786:	e1 14       	cp	r14, r1
    2788:	f1 04       	cpc	r15, r1
    278a:	19 f0       	breq	.+6      	; 0x2792 <xTaskCreate+0x10a>
    278c:	f7 01       	movw	r30, r14
    278e:	c0 82       	st	Z, r12
    2790:	d1 82       	std	Z+1, r13	; 0x01
    2792:	0f b6       	in	r0, 0x3f	; 63
    2794:	f8 94       	cli
    2796:	0f 92       	push	r0
    2798:	80 91 71 21 	lds	r24, 0x2171	; 0x802171 <uxCurrentNumberOfTasks>
    279c:	8f 5f       	subi	r24, 0xFF	; 255
    279e:	80 93 71 21 	sts	0x2171, r24	; 0x802171 <uxCurrentNumberOfTasks>
    27a2:	80 91 fe 21 	lds	r24, 0x21FE	; 0x8021fe <pxCurrentTCB>
    27a6:	90 91 ff 21 	lds	r25, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    27aa:	89 2b       	or	r24, r25
    27ac:	99 f0       	breq	.+38     	; 0x27d4 <xTaskCreate+0x14c>
    27ae:	80 91 6d 21 	lds	r24, 0x216D	; 0x80216d <xSchedulerRunning>
    27b2:	81 11       	cpse	r24, r1
    27b4:	18 c0       	rjmp	.+48     	; 0x27e6 <xTaskCreate+0x15e>
    27b6:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    27ba:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    27be:	d6 01       	movw	r26, r12
    27c0:	56 96       	adiw	r26, 0x16	; 22
    27c2:	8c 91       	ld	r24, X
    27c4:	96 89       	ldd	r25, Z+22	; 0x16
    27c6:	89 17       	cp	r24, r25
    27c8:	88 f0       	brcs	.+34     	; 0x27ec <xTaskCreate+0x164>
    27ca:	c0 92 fe 21 	sts	0x21FE, r12	; 0x8021fe <pxCurrentTCB>
    27ce:	d0 92 ff 21 	sts	0x21FF, r13	; 0x8021ff <pxCurrentTCB+0x1>
    27d2:	0c c0       	rjmp	.+24     	; 0x27ec <xTaskCreate+0x164>
    27d4:	c0 92 fe 21 	sts	0x21FE, r12	; 0x8021fe <pxCurrentTCB>
    27d8:	d0 92 ff 21 	sts	0x21FF, r13	; 0x8021ff <pxCurrentTCB+0x1>
    27dc:	80 91 71 21 	lds	r24, 0x2171	; 0x802171 <uxCurrentNumberOfTasks>
    27e0:	81 30       	cpi	r24, 0x01	; 1
    27e2:	09 f4       	brne	.+2      	; 0x27e6 <xTaskCreate+0x15e>
    27e4:	56 c0       	rjmp	.+172    	; 0x2892 <xTaskCreate+0x20a>
    27e6:	d6 01       	movw	r26, r12
    27e8:	56 96       	adiw	r26, 0x16	; 22
    27ea:	8c 91       	ld	r24, X
    27ec:	90 91 69 21 	lds	r25, 0x2169	; 0x802169 <uxTaskNumber>
    27f0:	9f 5f       	subi	r25, 0xFF	; 255
    27f2:	90 93 69 21 	sts	0x2169, r25	; 0x802169 <uxTaskNumber>
    27f6:	f6 01       	movw	r30, r12
    27f8:	91 a3       	std	Z+33, r25	; 0x21
    27fa:	90 91 6e 21 	lds	r25, 0x216E	; 0x80216e <uxTopReadyPriority>
    27fe:	98 17       	cp	r25, r24
    2800:	80 f1       	brcs	.+96     	; 0x2862 <xTaskCreate+0x1da>
    2802:	90 e0       	ldi	r25, 0x00	; 0
    2804:	9c 01       	movw	r18, r24
    2806:	22 0f       	add	r18, r18
    2808:	33 1f       	adc	r19, r19
    280a:	22 0f       	add	r18, r18
    280c:	33 1f       	adc	r19, r19
    280e:	22 0f       	add	r18, r18
    2810:	33 1f       	adc	r19, r19
    2812:	82 0f       	add	r24, r18
    2814:	93 1f       	adc	r25, r19
    2816:	be 01       	movw	r22, r28
    2818:	8c 55       	subi	r24, 0x5C	; 92
    281a:	9e 4d       	sbci	r25, 0xDE	; 222
    281c:	0e 94 c3 09 	call	0x1386	; 0x1386 <vListInsertEnd>
    2820:	0f 90       	pop	r0
    2822:	0f be       	out	0x3f, r0	; 63
    2824:	80 91 6d 21 	lds	r24, 0x216D	; 0x80216d <xSchedulerRunning>
    2828:	88 23       	and	r24, r24
    282a:	51 f0       	breq	.+20     	; 0x2840 <xTaskCreate+0x1b8>
    282c:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2830:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2834:	96 89       	ldd	r25, Z+22	; 0x16
    2836:	d6 01       	movw	r26, r12
    2838:	56 96       	adiw	r26, 0x16	; 22
    283a:	8c 91       	ld	r24, X
    283c:	98 17       	cp	r25, r24
    283e:	b0 f0       	brcs	.+44     	; 0x286c <xTaskCreate+0x1e4>
    2840:	81 e0       	ldi	r24, 0x01	; 1
    2842:	df 91       	pop	r29
    2844:	cf 91       	pop	r28
    2846:	1f 91       	pop	r17
    2848:	0f 91       	pop	r16
    284a:	ff 90       	pop	r15
    284c:	ef 90       	pop	r14
    284e:	df 90       	pop	r13
    2850:	cf 90       	pop	r12
    2852:	bf 90       	pop	r11
    2854:	af 90       	pop	r10
    2856:	9f 90       	pop	r9
    2858:	8f 90       	pop	r8
    285a:	7f 90       	pop	r7
    285c:	6f 90       	pop	r6
    285e:	5f 90       	pop	r5
    2860:	08 95       	ret
    2862:	80 93 6e 21 	sts	0x216E, r24	; 0x80216e <uxTopReadyPriority>
    2866:	cd cf       	rjmp	.-102    	; 0x2802 <xTaskCreate+0x17a>
    2868:	09 e0       	ldi	r16, 0x09	; 9
    286a:	5d cf       	rjmp	.-326    	; 0x2726 <xTaskCreate+0x9e>
    286c:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    2870:	81 e0       	ldi	r24, 0x01	; 1
    2872:	e7 cf       	rjmp	.-50     	; 0x2842 <xTaskCreate+0x1ba>
    2874:	c8 01       	movw	r24, r16
    2876:	0e 94 86 09 	call	0x130c	; 0x130c <vPortFree>
    287a:	8f ef       	ldi	r24, 0xFF	; 255
    287c:	e2 cf       	rjmp	.-60     	; 0x2842 <xTaskCreate+0x1ba>
    287e:	60 e6       	ldi	r22, 0x60	; 96
    2880:	73 e0       	ldi	r23, 0x03	; 3
    2882:	8b e3       	ldi	r24, 0x3B	; 59
    2884:	90 e2       	ldi	r25, 0x20	; 32
    2886:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    288a:	f6 01       	movw	r30, r12
    288c:	87 89       	ldd	r24, Z+23	; 0x17
    288e:	90 8d       	ldd	r25, Z+24	; 0x18
    2890:	27 cf       	rjmp	.-434    	; 0x26e0 <xTaskCreate+0x58>
    2892:	04 ea       	ldi	r16, 0xA4	; 164
    2894:	11 e2       	ldi	r17, 0x21	; 33
    2896:	5e ef       	ldi	r21, 0xFE	; 254
    2898:	e5 2e       	mov	r14, r21
    289a:	51 e2       	ldi	r21, 0x21	; 33
    289c:	f5 2e       	mov	r15, r21
    289e:	c8 01       	movw	r24, r16
    28a0:	0e 94 b1 09 	call	0x1362	; 0x1362 <vListInitialise>
    28a4:	07 5f       	subi	r16, 0xF7	; 247
    28a6:	1f 4f       	sbci	r17, 0xFF	; 255
    28a8:	e0 16       	cp	r14, r16
    28aa:	f1 06       	cpc	r15, r17
    28ac:	c1 f7       	brne	.-16     	; 0x289e <xTaskCreate+0x216>
    28ae:	8b e9       	ldi	r24, 0x9B	; 155
    28b0:	91 e2       	ldi	r25, 0x21	; 33
    28b2:	0e 94 b1 09 	call	0x1362	; 0x1362 <vListInitialise>
    28b6:	82 e9       	ldi	r24, 0x92	; 146
    28b8:	91 e2       	ldi	r25, 0x21	; 33
    28ba:	0e 94 b1 09 	call	0x1362	; 0x1362 <vListInitialise>
    28be:	85 e8       	ldi	r24, 0x85	; 133
    28c0:	91 e2       	ldi	r25, 0x21	; 33
    28c2:	0e 94 b1 09 	call	0x1362	; 0x1362 <vListInitialise>
    28c6:	8c e7       	ldi	r24, 0x7C	; 124
    28c8:	91 e2       	ldi	r25, 0x21	; 33
    28ca:	0e 94 b1 09 	call	0x1362	; 0x1362 <vListInitialise>
    28ce:	82 e7       	ldi	r24, 0x72	; 114
    28d0:	91 e2       	ldi	r25, 0x21	; 33
    28d2:	0e 94 b1 09 	call	0x1362	; 0x1362 <vListInitialise>
    28d6:	8b e9       	ldi	r24, 0x9B	; 155
    28d8:	91 e2       	ldi	r25, 0x21	; 33
    28da:	80 93 90 21 	sts	0x2190, r24	; 0x802190 <pxDelayedTaskList>
    28de:	90 93 91 21 	sts	0x2191, r25	; 0x802191 <pxDelayedTaskList+0x1>
    28e2:	82 e9       	ldi	r24, 0x92	; 146
    28e4:	91 e2       	ldi	r25, 0x21	; 33
    28e6:	80 93 8e 21 	sts	0x218E, r24	; 0x80218e <pxOverflowDelayedTaskList>
    28ea:	90 93 8f 21 	sts	0x218F, r25	; 0x80218f <pxOverflowDelayedTaskList+0x1>
    28ee:	f6 01       	movw	r30, r12
    28f0:	86 89       	ldd	r24, Z+22	; 0x16
    28f2:	7c cf       	rjmp	.-264    	; 0x27ec <xTaskCreate+0x164>

000028f4 <vTaskSuspend>:
    28f4:	0f 93       	push	r16
    28f6:	1f 93       	push	r17
    28f8:	cf 93       	push	r28
    28fa:	df 93       	push	r29
    28fc:	ec 01       	movw	r28, r24
    28fe:	0f b6       	in	r0, 0x3f	; 63
    2900:	f8 94       	cli
    2902:	0f 92       	push	r0
    2904:	89 2b       	or	r24, r25
    2906:	09 f4       	brne	.+2      	; 0x290a <vTaskSuspend+0x16>
    2908:	62 c0       	rjmp	.+196    	; 0x29ce <vTaskSuspend+0xda>
    290a:	8e 01       	movw	r16, r28
    290c:	0e 5f       	subi	r16, 0xFE	; 254
    290e:	1f 4f       	sbci	r17, 0xFF	; 255
    2910:	c8 01       	movw	r24, r16
    2912:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2916:	8c 89       	ldd	r24, Y+20	; 0x14
    2918:	9d 89       	ldd	r25, Y+21	; 0x15
    291a:	89 2b       	or	r24, r25
    291c:	21 f0       	breq	.+8      	; 0x2926 <vTaskSuspend+0x32>
    291e:	ce 01       	movw	r24, r28
    2920:	0c 96       	adiw	r24, 0x0c	; 12
    2922:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2926:	b8 01       	movw	r22, r16
    2928:	82 e7       	ldi	r24, 0x72	; 114
    292a:	91 e2       	ldi	r25, 0x21	; 33
    292c:	0e 94 c3 09 	call	0x1386	; 0x1386 <vListInsertEnd>
    2930:	8f a5       	ldd	r24, Y+47	; 0x2f
    2932:	81 30       	cpi	r24, 0x01	; 1
    2934:	21 f1       	breq	.+72     	; 0x297e <vTaskSuspend+0x8a>
    2936:	0f 90       	pop	r0
    2938:	0f be       	out	0x3f, r0	; 63
    293a:	80 91 6d 21 	lds	r24, 0x216D	; 0x80216d <xSchedulerRunning>
    293e:	88 23       	and	r24, r24
    2940:	91 f0       	breq	.+36     	; 0x2966 <vTaskSuspend+0x72>
    2942:	0f b6       	in	r0, 0x3f	; 63
    2944:	f8 94       	cli
    2946:	0f 92       	push	r0
    2948:	e0 91 90 21 	lds	r30, 0x2190	; 0x802190 <pxDelayedTaskList>
    294c:	f0 91 91 21 	lds	r31, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    2950:	80 81       	ld	r24, Z
    2952:	81 11       	cpse	r24, r1
    2954:	2b c0       	rjmp	.+86     	; 0x29ac <vTaskSuspend+0xb8>
    2956:	8f ef       	ldi	r24, 0xFF	; 255
    2958:	9f ef       	ldi	r25, 0xFF	; 255
    295a:	80 93 67 21 	sts	0x2167, r24	; 0x802167 <xNextTaskUnblockTime>
    295e:	90 93 68 21 	sts	0x2168, r25	; 0x802168 <xNextTaskUnblockTime+0x1>
    2962:	0f 90       	pop	r0
    2964:	0f be       	out	0x3f, r0	; 63
    2966:	80 91 fe 21 	lds	r24, 0x21FE	; 0x8021fe <pxCurrentTCB>
    296a:	90 91 ff 21 	lds	r25, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    296e:	c8 17       	cp	r28, r24
    2970:	d9 07       	cpc	r29, r25
    2972:	39 f0       	breq	.+14     	; 0x2982 <vTaskSuspend+0x8e>
    2974:	df 91       	pop	r29
    2976:	cf 91       	pop	r28
    2978:	1f 91       	pop	r17
    297a:	0f 91       	pop	r16
    297c:	08 95       	ret
    297e:	1f a6       	std	Y+47, r1	; 0x2f
    2980:	da cf       	rjmp	.-76     	; 0x2936 <vTaskSuspend+0x42>
    2982:	80 91 6d 21 	lds	r24, 0x216D	; 0x80216d <xSchedulerRunning>
    2986:	88 23       	and	r24, r24
    2988:	a1 f0       	breq	.+40     	; 0x29b2 <vTaskSuspend+0xbe>
    298a:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    298e:	88 23       	and	r24, r24
    2990:	31 f0       	breq	.+12     	; 0x299e <vTaskSuspend+0xaa>
    2992:	68 ec       	ldi	r22, 0xC8	; 200
    2994:	76 e0       	ldi	r23, 0x06	; 6
    2996:	8b e3       	ldi	r24, 0x3B	; 59
    2998:	90 e2       	ldi	r25, 0x20	; 32
    299a:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    299e:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    29a2:	df 91       	pop	r29
    29a4:	cf 91       	pop	r28
    29a6:	1f 91       	pop	r17
    29a8:	0f 91       	pop	r16
    29aa:	08 95       	ret
    29ac:	0e 94 f6 11 	call	0x23ec	; 0x23ec <prvResetNextTaskUnblockTime.part.0>
    29b0:	d8 cf       	rjmp	.-80     	; 0x2962 <vTaskSuspend+0x6e>
    29b2:	90 91 72 21 	lds	r25, 0x2172	; 0x802172 <xSuspendedTaskList>
    29b6:	80 91 71 21 	lds	r24, 0x2171	; 0x802171 <uxCurrentNumberOfTasks>
    29ba:	98 17       	cp	r25, r24
    29bc:	99 f0       	breq	.+38     	; 0x29e4 <vTaskSuspend+0xf0>
    29be:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    29c2:	88 23       	and	r24, r24
    29c4:	49 f0       	breq	.+18     	; 0x29d8 <vTaskSuspend+0xe4>
    29c6:	81 e0       	ldi	r24, 0x01	; 1
    29c8:	80 93 6b 21 	sts	0x216B, r24	; 0x80216b <xYieldPending>
    29cc:	d3 cf       	rjmp	.-90     	; 0x2974 <vTaskSuspend+0x80>
    29ce:	c0 91 fe 21 	lds	r28, 0x21FE	; 0x8021fe <pxCurrentTCB>
    29d2:	d0 91 ff 21 	lds	r29, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    29d6:	99 cf       	rjmp	.-206    	; 0x290a <vTaskSuspend+0x16>
    29d8:	df 91       	pop	r29
    29da:	cf 91       	pop	r28
    29dc:	1f 91       	pop	r17
    29de:	0f 91       	pop	r16
    29e0:	0c 94 82 12 	jmp	0x2504	; 0x2504 <vTaskSwitchContext.part.5>
    29e4:	10 92 fe 21 	sts	0x21FE, r1	; 0x8021fe <pxCurrentTCB>
    29e8:	10 92 ff 21 	sts	0x21FF, r1	; 0x8021ff <pxCurrentTCB+0x1>
    29ec:	c3 cf       	rjmp	.-122    	; 0x2974 <vTaskSuspend+0x80>

000029ee <vTaskResume>:
    29ee:	0f 93       	push	r16
    29f0:	1f 93       	push	r17
    29f2:	cf 93       	push	r28
    29f4:	df 93       	push	r29
    29f6:	ec 01       	movw	r28, r24
    29f8:	89 2b       	or	r24, r25
    29fa:	09 f4       	brne	.+2      	; 0x29fe <vTaskResume+0x10>
    29fc:	3d c0       	rjmp	.+122    	; 0x2a78 <vTaskResume+0x8a>
    29fe:	80 91 fe 21 	lds	r24, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2a02:	90 91 ff 21 	lds	r25, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2a06:	c8 17       	cp	r28, r24
    2a08:	d9 07       	cpc	r29, r25
    2a0a:	51 f0       	breq	.+20     	; 0x2a20 <vTaskResume+0x32>
    2a0c:	0f b6       	in	r0, 0x3f	; 63
    2a0e:	f8 94       	cli
    2a10:	0f 92       	push	r0
    2a12:	ce 01       	movw	r24, r28
    2a14:	0e 94 07 12 	call	0x240e	; 0x240e <prvTaskIsTaskSuspended>
    2a18:	81 11       	cpse	r24, r1
    2a1a:	07 c0       	rjmp	.+14     	; 0x2a2a <vTaskResume+0x3c>
    2a1c:	0f 90       	pop	r0
    2a1e:	0f be       	out	0x3f, r0	; 63
    2a20:	df 91       	pop	r29
    2a22:	cf 91       	pop	r28
    2a24:	1f 91       	pop	r17
    2a26:	0f 91       	pop	r16
    2a28:	08 95       	ret
    2a2a:	8e 01       	movw	r16, r28
    2a2c:	0e 5f       	subi	r16, 0xFE	; 254
    2a2e:	1f 4f       	sbci	r17, 0xFF	; 255
    2a30:	c8 01       	movw	r24, r16
    2a32:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2a36:	8e 89       	ldd	r24, Y+22	; 0x16
    2a38:	90 91 6e 21 	lds	r25, 0x216E	; 0x80216e <uxTopReadyPriority>
    2a3c:	98 17       	cp	r25, r24
    2a3e:	10 f4       	brcc	.+4      	; 0x2a44 <vTaskResume+0x56>
    2a40:	80 93 6e 21 	sts	0x216E, r24	; 0x80216e <uxTopReadyPriority>
    2a44:	90 e0       	ldi	r25, 0x00	; 0
    2a46:	9c 01       	movw	r18, r24
    2a48:	22 0f       	add	r18, r18
    2a4a:	33 1f       	adc	r19, r19
    2a4c:	22 0f       	add	r18, r18
    2a4e:	33 1f       	adc	r19, r19
    2a50:	22 0f       	add	r18, r18
    2a52:	33 1f       	adc	r19, r19
    2a54:	82 0f       	add	r24, r18
    2a56:	93 1f       	adc	r25, r19
    2a58:	b8 01       	movw	r22, r16
    2a5a:	8c 55       	subi	r24, 0x5C	; 92
    2a5c:	9e 4d       	sbci	r25, 0xDE	; 222
    2a5e:	0e 94 c3 09 	call	0x1386	; 0x1386 <vListInsertEnd>
    2a62:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2a66:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2a6a:	9e 89       	ldd	r25, Y+22	; 0x16
    2a6c:	86 89       	ldd	r24, Z+22	; 0x16
    2a6e:	98 17       	cp	r25, r24
    2a70:	a8 f2       	brcs	.-86     	; 0x2a1c <vTaskResume+0x2e>
    2a72:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    2a76:	d2 cf       	rjmp	.-92     	; 0x2a1c <vTaskResume+0x2e>
    2a78:	6c e1       	ldi	r22, 0x1C	; 28
    2a7a:	77 e0       	ldi	r23, 0x07	; 7
    2a7c:	8b e3       	ldi	r24, 0x3B	; 59
    2a7e:	90 e2       	ldi	r25, 0x20	; 32
    2a80:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2a84:	80 91 fe 21 	lds	r24, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2a88:	90 91 ff 21 	lds	r25, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2a8c:	c9 cf       	rjmp	.-110    	; 0x2a20 <vTaskResume+0x32>

00002a8e <vTaskStartScheduler>:
    2a8e:	ef 92       	push	r14
    2a90:	ff 92       	push	r15
    2a92:	0f 93       	push	r16
    2a94:	85 e6       	ldi	r24, 0x65	; 101
    2a96:	e8 2e       	mov	r14, r24
    2a98:	81 e2       	ldi	r24, 0x21	; 33
    2a9a:	f8 2e       	mov	r15, r24
    2a9c:	00 e0       	ldi	r16, 0x00	; 0
    2a9e:	20 e0       	ldi	r18, 0x00	; 0
    2aa0:	30 e0       	ldi	r19, 0x00	; 0
    2aa2:	40 e0       	ldi	r20, 0x00	; 0
    2aa4:	51 e0       	ldi	r21, 0x01	; 1
    2aa6:	6f e4       	ldi	r22, 0x4F	; 79
    2aa8:	70 e2       	ldi	r23, 0x20	; 32
    2aaa:	88 ec       	ldi	r24, 0xC8	; 200
    2aac:	91 e1       	ldi	r25, 0x11	; 17
    2aae:	0e 94 44 13 	call	0x2688	; 0x2688 <xTaskCreate>
    2ab2:	81 30       	cpi	r24, 0x01	; 1
    2ab4:	79 f0       	breq	.+30     	; 0x2ad4 <vTaskStartScheduler+0x46>
    2ab6:	8f 3f       	cpi	r24, 0xFF	; 255
    2ab8:	21 f0       	breq	.+8      	; 0x2ac2 <vTaskStartScheduler+0x34>
    2aba:	0f 91       	pop	r16
    2abc:	ff 90       	pop	r15
    2abe:	ef 90       	pop	r14
    2ac0:	08 95       	ret
    2ac2:	67 e0       	ldi	r22, 0x07	; 7
    2ac4:	78 e0       	ldi	r23, 0x08	; 8
    2ac6:	8b e3       	ldi	r24, 0x3B	; 59
    2ac8:	90 e2       	ldi	r25, 0x20	; 32
    2aca:	0f 91       	pop	r16
    2acc:	ff 90       	pop	r15
    2ace:	ef 90       	pop	r14
    2ad0:	0c 94 ee 19 	jmp	0x33dc	; 0x33dc <vAssertCalled>
    2ad4:	f8 94       	cli
    2ad6:	2f ef       	ldi	r18, 0xFF	; 255
    2ad8:	3f ef       	ldi	r19, 0xFF	; 255
    2ada:	20 93 67 21 	sts	0x2167, r18	; 0x802167 <xNextTaskUnblockTime>
    2ade:	30 93 68 21 	sts	0x2168, r19	; 0x802168 <xNextTaskUnblockTime+0x1>
    2ae2:	80 93 6d 21 	sts	0x216D, r24	; 0x80216d <xSchedulerRunning>
    2ae6:	10 92 6f 21 	sts	0x216F, r1	; 0x80216f <xTickCount>
    2aea:	10 92 70 21 	sts	0x2170, r1	; 0x802170 <xTickCount+0x1>
    2aee:	0e 94 d6 0b 	call	0x17ac	; 0x17ac <vConfigureTimerForRunTimeStats>
    2af2:	0f 91       	pop	r16
    2af4:	ff 90       	pop	r15
    2af6:	ef 90       	pop	r14
    2af8:	0c 94 a9 0a 	jmp	0x1552	; 0x1552 <xPortStartScheduler>

00002afc <vTaskSuspendAll>:
    2afc:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2b00:	8f 5f       	subi	r24, 0xFF	; 255
    2b02:	80 93 64 21 	sts	0x2164, r24	; 0x802164 <uxSchedulerSuspended>
    2b06:	08 95       	ret

00002b08 <xTaskGetTickCount>:
    2b08:	0f b6       	in	r0, 0x3f	; 63
    2b0a:	f8 94       	cli
    2b0c:	0f 92       	push	r0
    2b0e:	80 91 6f 21 	lds	r24, 0x216F	; 0x80216f <xTickCount>
    2b12:	90 91 70 21 	lds	r25, 0x2170	; 0x802170 <xTickCount+0x1>
    2b16:	0f 90       	pop	r0
    2b18:	0f be       	out	0x3f, r0	; 63
    2b1a:	08 95       	ret

00002b1c <xTaskIncrementTick>:
    2b1c:	df 92       	push	r13
    2b1e:	ef 92       	push	r14
    2b20:	ff 92       	push	r15
    2b22:	0f 93       	push	r16
    2b24:	1f 93       	push	r17
    2b26:	cf 93       	push	r28
    2b28:	df 93       	push	r29
    2b2a:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2b2e:	81 11       	cpse	r24, r1
    2b30:	b9 c0       	rjmp	.+370    	; 0x2ca4 <xTaskIncrementTick+0x188>
    2b32:	e0 90 6f 21 	lds	r14, 0x216F	; 0x80216f <xTickCount>
    2b36:	f0 90 70 21 	lds	r15, 0x2170	; 0x802170 <xTickCount+0x1>
    2b3a:	8f ef       	ldi	r24, 0xFF	; 255
    2b3c:	e8 1a       	sub	r14, r24
    2b3e:	f8 0a       	sbc	r15, r24
    2b40:	e0 92 6f 21 	sts	0x216F, r14	; 0x80216f <xTickCount>
    2b44:	f0 92 70 21 	sts	0x2170, r15	; 0x802170 <xTickCount+0x1>
    2b48:	e1 14       	cp	r14, r1
    2b4a:	f1 04       	cpc	r15, r1
    2b4c:	49 f5       	brne	.+82     	; 0x2ba0 <xTaskIncrementTick+0x84>
    2b4e:	e0 91 90 21 	lds	r30, 0x2190	; 0x802190 <pxDelayedTaskList>
    2b52:	f0 91 91 21 	lds	r31, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    2b56:	80 81       	ld	r24, Z
    2b58:	81 11       	cpse	r24, r1
    2b5a:	ab c0       	rjmp	.+342    	; 0x2cb2 <xTaskIncrementTick+0x196>
    2b5c:	80 91 90 21 	lds	r24, 0x2190	; 0x802190 <pxDelayedTaskList>
    2b60:	90 91 91 21 	lds	r25, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    2b64:	20 91 8e 21 	lds	r18, 0x218E	; 0x80218e <pxOverflowDelayedTaskList>
    2b68:	30 91 8f 21 	lds	r19, 0x218F	; 0x80218f <pxOverflowDelayedTaskList+0x1>
    2b6c:	20 93 90 21 	sts	0x2190, r18	; 0x802190 <pxDelayedTaskList>
    2b70:	30 93 91 21 	sts	0x2191, r19	; 0x802191 <pxDelayedTaskList+0x1>
    2b74:	80 93 8e 21 	sts	0x218E, r24	; 0x80218e <pxOverflowDelayedTaskList>
    2b78:	90 93 8f 21 	sts	0x218F, r25	; 0x80218f <pxOverflowDelayedTaskList+0x1>
    2b7c:	80 91 6a 21 	lds	r24, 0x216A	; 0x80216a <xNumOfOverflows>
    2b80:	8f 5f       	subi	r24, 0xFF	; 255
    2b82:	80 93 6a 21 	sts	0x216A, r24	; 0x80216a <xNumOfOverflows>
    2b86:	e0 91 90 21 	lds	r30, 0x2190	; 0x802190 <pxDelayedTaskList>
    2b8a:	f0 91 91 21 	lds	r31, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    2b8e:	80 81       	ld	r24, Z
    2b90:	81 11       	cpse	r24, r1
    2b92:	96 c0       	rjmp	.+300    	; 0x2cc0 <xTaskIncrementTick+0x1a4>
    2b94:	8f ef       	ldi	r24, 0xFF	; 255
    2b96:	9f ef       	ldi	r25, 0xFF	; 255
    2b98:	80 93 67 21 	sts	0x2167, r24	; 0x802167 <xNextTaskUnblockTime>
    2b9c:	90 93 68 21 	sts	0x2168, r25	; 0x802168 <xNextTaskUnblockTime+0x1>
    2ba0:	80 91 67 21 	lds	r24, 0x2167	; 0x802167 <xNextTaskUnblockTime>
    2ba4:	90 91 68 21 	lds	r25, 0x2168	; 0x802168 <xNextTaskUnblockTime+0x1>
    2ba8:	d1 2c       	mov	r13, r1
    2baa:	e8 16       	cp	r14, r24
    2bac:	f9 06       	cpc	r15, r25
    2bae:	08 f4       	brcc	.+2      	; 0x2bb2 <xTaskIncrementTick+0x96>
    2bb0:	53 c0       	rjmp	.+166    	; 0x2c58 <xTaskIncrementTick+0x13c>
    2bb2:	e0 91 90 21 	lds	r30, 0x2190	; 0x802190 <pxDelayedTaskList>
    2bb6:	f0 91 91 21 	lds	r31, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    2bba:	80 81       	ld	r24, Z
    2bbc:	88 23       	and	r24, r24
    2bbe:	09 f4       	brne	.+2      	; 0x2bc2 <xTaskIncrementTick+0xa6>
    2bc0:	45 c0       	rjmp	.+138    	; 0x2c4c <xTaskIncrementTick+0x130>
    2bc2:	e0 91 90 21 	lds	r30, 0x2190	; 0x802190 <pxDelayedTaskList>
    2bc6:	f0 91 91 21 	lds	r31, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    2bca:	05 80       	ldd	r0, Z+5	; 0x05
    2bcc:	f6 81       	ldd	r31, Z+6	; 0x06
    2bce:	e0 2d       	mov	r30, r0
    2bd0:	c6 81       	ldd	r28, Z+6	; 0x06
    2bd2:	d7 81       	ldd	r29, Z+7	; 0x07
    2bd4:	8a 81       	ldd	r24, Y+2	; 0x02
    2bd6:	9b 81       	ldd	r25, Y+3	; 0x03
    2bd8:	e8 16       	cp	r14, r24
    2bda:	f9 06       	cpc	r15, r25
    2bdc:	08 f4       	brcc	.+2      	; 0x2be0 <xTaskIncrementTick+0xc4>
    2bde:	73 c0       	rjmp	.+230    	; 0x2cc6 <xTaskIncrementTick+0x1aa>
    2be0:	8e 01       	movw	r16, r28
    2be2:	0e 5f       	subi	r16, 0xFE	; 254
    2be4:	1f 4f       	sbci	r17, 0xFF	; 255
    2be6:	c8 01       	movw	r24, r16
    2be8:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2bec:	8c 89       	ldd	r24, Y+20	; 0x14
    2bee:	9d 89       	ldd	r25, Y+21	; 0x15
    2bf0:	89 2b       	or	r24, r25
    2bf2:	21 f0       	breq	.+8      	; 0x2bfc <xTaskIncrementTick+0xe0>
    2bf4:	ce 01       	movw	r24, r28
    2bf6:	0c 96       	adiw	r24, 0x0c	; 12
    2bf8:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2bfc:	8e 89       	ldd	r24, Y+22	; 0x16
    2bfe:	90 91 6e 21 	lds	r25, 0x216E	; 0x80216e <uxTopReadyPriority>
    2c02:	98 17       	cp	r25, r24
    2c04:	10 f4       	brcc	.+4      	; 0x2c0a <xTaskIncrementTick+0xee>
    2c06:	80 93 6e 21 	sts	0x216E, r24	; 0x80216e <uxTopReadyPriority>
    2c0a:	90 e0       	ldi	r25, 0x00	; 0
    2c0c:	9c 01       	movw	r18, r24
    2c0e:	22 0f       	add	r18, r18
    2c10:	33 1f       	adc	r19, r19
    2c12:	22 0f       	add	r18, r18
    2c14:	33 1f       	adc	r19, r19
    2c16:	22 0f       	add	r18, r18
    2c18:	33 1f       	adc	r19, r19
    2c1a:	82 0f       	add	r24, r18
    2c1c:	93 1f       	adc	r25, r19
    2c1e:	b8 01       	movw	r22, r16
    2c20:	8c 55       	subi	r24, 0x5C	; 92
    2c22:	9e 4d       	sbci	r25, 0xDE	; 222
    2c24:	0e 94 c3 09 	call	0x1386	; 0x1386 <vListInsertEnd>
    2c28:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2c2c:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2c30:	9e 89       	ldd	r25, Y+22	; 0x16
    2c32:	86 89       	ldd	r24, Z+22	; 0x16
    2c34:	98 17       	cp	r25, r24
    2c36:	08 f4       	brcc	.+2      	; 0x2c3a <xTaskIncrementTick+0x11e>
    2c38:	bc cf       	rjmp	.-136    	; 0x2bb2 <xTaskIncrementTick+0x96>
    2c3a:	dd 24       	eor	r13, r13
    2c3c:	d3 94       	inc	r13
    2c3e:	e0 91 90 21 	lds	r30, 0x2190	; 0x802190 <pxDelayedTaskList>
    2c42:	f0 91 91 21 	lds	r31, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    2c46:	80 81       	ld	r24, Z
    2c48:	81 11       	cpse	r24, r1
    2c4a:	bb cf       	rjmp	.-138    	; 0x2bc2 <xTaskIncrementTick+0xa6>
    2c4c:	8f ef       	ldi	r24, 0xFF	; 255
    2c4e:	9f ef       	ldi	r25, 0xFF	; 255
    2c50:	80 93 67 21 	sts	0x2167, r24	; 0x802167 <xNextTaskUnblockTime>
    2c54:	90 93 68 21 	sts	0x2168, r25	; 0x802168 <xNextTaskUnblockTime+0x1>
    2c58:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2c5c:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2c60:	86 89       	ldd	r24, Z+22	; 0x16
    2c62:	90 e0       	ldi	r25, 0x00	; 0
    2c64:	fc 01       	movw	r30, r24
    2c66:	ee 0f       	add	r30, r30
    2c68:	ff 1f       	adc	r31, r31
    2c6a:	ee 0f       	add	r30, r30
    2c6c:	ff 1f       	adc	r31, r31
    2c6e:	ee 0f       	add	r30, r30
    2c70:	ff 1f       	adc	r31, r31
    2c72:	8e 0f       	add	r24, r30
    2c74:	9f 1f       	adc	r25, r31
    2c76:	fc 01       	movw	r30, r24
    2c78:	ec 55       	subi	r30, 0x5C	; 92
    2c7a:	fe 4d       	sbci	r31, 0xDE	; 222
    2c7c:	80 81       	ld	r24, Z
    2c7e:	82 30       	cpi	r24, 0x02	; 2
    2c80:	10 f0       	brcs	.+4      	; 0x2c86 <xTaskIncrementTick+0x16a>
    2c82:	dd 24       	eor	r13, r13
    2c84:	d3 94       	inc	r13
    2c86:	80 91 6b 21 	lds	r24, 0x216B	; 0x80216b <xYieldPending>
    2c8a:	88 23       	and	r24, r24
    2c8c:	11 f0       	breq	.+4      	; 0x2c92 <xTaskIncrementTick+0x176>
    2c8e:	dd 24       	eor	r13, r13
    2c90:	d3 94       	inc	r13
    2c92:	8d 2d       	mov	r24, r13
    2c94:	df 91       	pop	r29
    2c96:	cf 91       	pop	r28
    2c98:	1f 91       	pop	r17
    2c9a:	0f 91       	pop	r16
    2c9c:	ff 90       	pop	r15
    2c9e:	ef 90       	pop	r14
    2ca0:	df 90       	pop	r13
    2ca2:	08 95       	ret
    2ca4:	80 91 6c 21 	lds	r24, 0x216C	; 0x80216c <uxPendedTicks>
    2ca8:	8f 5f       	subi	r24, 0xFF	; 255
    2caa:	80 93 6c 21 	sts	0x216C, r24	; 0x80216c <uxPendedTicks>
    2cae:	d1 2c       	mov	r13, r1
    2cb0:	ea cf       	rjmp	.-44     	; 0x2c86 <xTaskIncrementTick+0x16a>
    2cb2:	66 e6       	ldi	r22, 0x66	; 102
    2cb4:	7a e0       	ldi	r23, 0x0A	; 10
    2cb6:	8b e3       	ldi	r24, 0x3B	; 59
    2cb8:	90 e2       	ldi	r25, 0x20	; 32
    2cba:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2cbe:	4e cf       	rjmp	.-356    	; 0x2b5c <xTaskIncrementTick+0x40>
    2cc0:	0e 94 f6 11 	call	0x23ec	; 0x23ec <prvResetNextTaskUnblockTime.part.0>
    2cc4:	6d cf       	rjmp	.-294    	; 0x2ba0 <xTaskIncrementTick+0x84>
    2cc6:	80 93 67 21 	sts	0x2167, r24	; 0x802167 <xNextTaskUnblockTime>
    2cca:	90 93 68 21 	sts	0x2168, r25	; 0x802168 <xNextTaskUnblockTime+0x1>
    2cce:	c4 cf       	rjmp	.-120    	; 0x2c58 <xTaskIncrementTick+0x13c>

00002cd0 <xTaskResumeAll>:
    2cd0:	ff 92       	push	r15
    2cd2:	0f 93       	push	r16
    2cd4:	1f 93       	push	r17
    2cd6:	cf 93       	push	r28
    2cd8:	df 93       	push	r29
    2cda:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2cde:	88 23       	and	r24, r24
    2ce0:	09 f4       	brne	.+2      	; 0x2ce4 <xTaskResumeAll+0x14>
    2ce2:	77 c0       	rjmp	.+238    	; 0x2dd2 <xTaskResumeAll+0x102>
    2ce4:	0f b6       	in	r0, 0x3f	; 63
    2ce6:	f8 94       	cli
    2ce8:	0f 92       	push	r0
    2cea:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2cee:	81 50       	subi	r24, 0x01	; 1
    2cf0:	80 93 64 21 	sts	0x2164, r24	; 0x802164 <uxSchedulerSuspended>
    2cf4:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2cf8:	81 11       	cpse	r24, r1
    2cfa:	62 c0       	rjmp	.+196    	; 0x2dc0 <xTaskResumeAll+0xf0>
    2cfc:	80 91 71 21 	lds	r24, 0x2171	; 0x802171 <uxCurrentNumberOfTasks>
    2d00:	88 23       	and	r24, r24
    2d02:	09 f4       	brne	.+2      	; 0x2d06 <xTaskResumeAll+0x36>
    2d04:	5d c0       	rjmp	.+186    	; 0x2dc0 <xTaskResumeAll+0xf0>
    2d06:	c0 e0       	ldi	r28, 0x00	; 0
    2d08:	d0 e0       	ldi	r29, 0x00	; 0
    2d0a:	ff 24       	eor	r15, r15
    2d0c:	f3 94       	inc	r15
    2d0e:	80 91 85 21 	lds	r24, 0x2185	; 0x802185 <xPendingReadyList>
    2d12:	88 23       	and	r24, r24
    2d14:	a1 f1       	breq	.+104    	; 0x2d7e <xTaskResumeAll+0xae>
    2d16:	e0 91 8a 21 	lds	r30, 0x218A	; 0x80218a <xPendingReadyList+0x5>
    2d1a:	f0 91 8b 21 	lds	r31, 0x218B	; 0x80218b <xPendingReadyList+0x6>
    2d1e:	c6 81       	ldd	r28, Z+6	; 0x06
    2d20:	d7 81       	ldd	r29, Z+7	; 0x07
    2d22:	ce 01       	movw	r24, r28
    2d24:	0c 96       	adiw	r24, 0x0c	; 12
    2d26:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2d2a:	8e 01       	movw	r16, r28
    2d2c:	0e 5f       	subi	r16, 0xFE	; 254
    2d2e:	1f 4f       	sbci	r17, 0xFF	; 255
    2d30:	c8 01       	movw	r24, r16
    2d32:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2d36:	8e 89       	ldd	r24, Y+22	; 0x16
    2d38:	90 91 6e 21 	lds	r25, 0x216E	; 0x80216e <uxTopReadyPriority>
    2d3c:	98 17       	cp	r25, r24
    2d3e:	10 f4       	brcc	.+4      	; 0x2d44 <xTaskResumeAll+0x74>
    2d40:	80 93 6e 21 	sts	0x216E, r24	; 0x80216e <uxTopReadyPriority>
    2d44:	90 e0       	ldi	r25, 0x00	; 0
    2d46:	9c 01       	movw	r18, r24
    2d48:	22 0f       	add	r18, r18
    2d4a:	33 1f       	adc	r19, r19
    2d4c:	22 0f       	add	r18, r18
    2d4e:	33 1f       	adc	r19, r19
    2d50:	22 0f       	add	r18, r18
    2d52:	33 1f       	adc	r19, r19
    2d54:	82 0f       	add	r24, r18
    2d56:	93 1f       	adc	r25, r19
    2d58:	b8 01       	movw	r22, r16
    2d5a:	8c 55       	subi	r24, 0x5C	; 92
    2d5c:	9e 4d       	sbci	r25, 0xDE	; 222
    2d5e:	0e 94 c3 09 	call	0x1386	; 0x1386 <vListInsertEnd>
    2d62:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2d66:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2d6a:	9e 89       	ldd	r25, Y+22	; 0x16
    2d6c:	86 89       	ldd	r24, Z+22	; 0x16
    2d6e:	98 17       	cp	r25, r24
    2d70:	70 f2       	brcs	.-100    	; 0x2d0e <xTaskResumeAll+0x3e>
    2d72:	f0 92 6b 21 	sts	0x216B, r15	; 0x80216b <xYieldPending>
    2d76:	80 91 85 21 	lds	r24, 0x2185	; 0x802185 <xPendingReadyList>
    2d7a:	81 11       	cpse	r24, r1
    2d7c:	cc cf       	rjmp	.-104    	; 0x2d16 <xTaskResumeAll+0x46>
    2d7e:	cd 2b       	or	r28, r29
    2d80:	69 f0       	breq	.+26     	; 0x2d9c <xTaskResumeAll+0xcc>
    2d82:	e0 91 90 21 	lds	r30, 0x2190	; 0x802190 <pxDelayedTaskList>
    2d86:	f0 91 91 21 	lds	r31, 0x2191	; 0x802191 <pxDelayedTaskList+0x1>
    2d8a:	80 81       	ld	r24, Z
    2d8c:	81 11       	cpse	r24, r1
    2d8e:	2c c0       	rjmp	.+88     	; 0x2de8 <xTaskResumeAll+0x118>
    2d90:	8f ef       	ldi	r24, 0xFF	; 255
    2d92:	9f ef       	ldi	r25, 0xFF	; 255
    2d94:	80 93 67 21 	sts	0x2167, r24	; 0x802167 <xNextTaskUnblockTime>
    2d98:	90 93 68 21 	sts	0x2168, r25	; 0x802168 <xNextTaskUnblockTime+0x1>
    2d9c:	c0 91 6c 21 	lds	r28, 0x216C	; 0x80216c <uxPendedTicks>
    2da0:	cc 23       	and	r28, r28
    2da2:	51 f0       	breq	.+20     	; 0x2db8 <xTaskResumeAll+0xe8>
    2da4:	d1 e0       	ldi	r29, 0x01	; 1
    2da6:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xTaskIncrementTick>
    2daa:	81 11       	cpse	r24, r1
    2dac:	d0 93 6b 21 	sts	0x216B, r29	; 0x80216b <xYieldPending>
    2db0:	c1 50       	subi	r28, 0x01	; 1
    2db2:	c9 f7       	brne	.-14     	; 0x2da6 <xTaskResumeAll+0xd6>
    2db4:	10 92 6c 21 	sts	0x216C, r1	; 0x80216c <uxPendedTicks>
    2db8:	80 91 6b 21 	lds	r24, 0x216B	; 0x80216b <xYieldPending>
    2dbc:	81 11       	cpse	r24, r1
    2dbe:	10 c0       	rjmp	.+32     	; 0x2de0 <xTaskResumeAll+0x110>
    2dc0:	80 e0       	ldi	r24, 0x00	; 0
    2dc2:	0f 90       	pop	r0
    2dc4:	0f be       	out	0x3f, r0	; 63
    2dc6:	df 91       	pop	r29
    2dc8:	cf 91       	pop	r28
    2dca:	1f 91       	pop	r17
    2dcc:	0f 91       	pop	r16
    2dce:	ff 90       	pop	r15
    2dd0:	08 95       	ret
    2dd2:	6c e6       	ldi	r22, 0x6C	; 108
    2dd4:	78 e0       	ldi	r23, 0x08	; 8
    2dd6:	8b e3       	ldi	r24, 0x3B	; 59
    2dd8:	90 e2       	ldi	r25, 0x20	; 32
    2dda:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2dde:	82 cf       	rjmp	.-252    	; 0x2ce4 <xTaskResumeAll+0x14>
    2de0:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    2de4:	81 e0       	ldi	r24, 0x01	; 1
    2de6:	ed cf       	rjmp	.-38     	; 0x2dc2 <xTaskResumeAll+0xf2>
    2de8:	0e 94 f6 11 	call	0x23ec	; 0x23ec <prvResetNextTaskUnblockTime.part.0>
    2dec:	d7 cf       	rjmp	.-82     	; 0x2d9c <xTaskResumeAll+0xcc>

00002dee <vTaskDelayUntil>:
    2dee:	0f 93       	push	r16
    2df0:	1f 93       	push	r17
    2df2:	cf 93       	push	r28
    2df4:	df 93       	push	r29
    2df6:	8c 01       	movw	r16, r24
    2df8:	eb 01       	movw	r28, r22
    2dfa:	89 2b       	or	r24, r25
    2dfc:	09 f4       	brne	.+2      	; 0x2e00 <vTaskDelayUntil+0x12>
    2dfe:	46 c0       	rjmp	.+140    	; 0x2e8c <vTaskDelayUntil+0x9e>
    2e00:	20 97       	sbiw	r28, 0x00	; 0
    2e02:	e9 f1       	breq	.+122    	; 0x2e7e <vTaskDelayUntil+0x90>
    2e04:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2e08:	81 11       	cpse	r24, r1
    2e0a:	32 c0       	rjmp	.+100    	; 0x2e70 <vTaskDelayUntil+0x82>
    2e0c:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2e10:	8f 5f       	subi	r24, 0xFF	; 255
    2e12:	80 93 64 21 	sts	0x2164, r24	; 0x802164 <uxSchedulerSuspended>
    2e16:	40 91 6f 21 	lds	r20, 0x216F	; 0x80216f <xTickCount>
    2e1a:	50 91 70 21 	lds	r21, 0x2170	; 0x802170 <xTickCount+0x1>
    2e1e:	f8 01       	movw	r30, r16
    2e20:	20 81       	ld	r18, Z
    2e22:	31 81       	ldd	r19, Z+1	; 0x01
    2e24:	ce 01       	movw	r24, r28
    2e26:	82 0f       	add	r24, r18
    2e28:	93 1f       	adc	r25, r19
    2e2a:	42 17       	cp	r20, r18
    2e2c:	53 07       	cpc	r21, r19
    2e2e:	88 f4       	brcc	.+34     	; 0x2e52 <vTaskDelayUntil+0x64>
    2e30:	82 17       	cp	r24, r18
    2e32:	93 07       	cpc	r25, r19
    2e34:	88 f0       	brcs	.+34     	; 0x2e58 <vTaskDelayUntil+0x6a>
    2e36:	f8 01       	movw	r30, r16
    2e38:	80 83       	st	Z, r24
    2e3a:	91 83       	std	Z+1, r25	; 0x01
    2e3c:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    2e40:	81 11       	cpse	r24, r1
    2e42:	02 c0       	rjmp	.+4      	; 0x2e48 <vTaskDelayUntil+0x5a>
    2e44:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    2e48:	df 91       	pop	r29
    2e4a:	cf 91       	pop	r28
    2e4c:	1f 91       	pop	r17
    2e4e:	0f 91       	pop	r16
    2e50:	08 95       	ret
    2e52:	82 17       	cp	r24, r18
    2e54:	93 07       	cpc	r25, r19
    2e56:	18 f0       	brcs	.+6      	; 0x2e5e <vTaskDelayUntil+0x70>
    2e58:	48 17       	cp	r20, r24
    2e5a:	59 07       	cpc	r21, r25
    2e5c:	60 f7       	brcc	.-40     	; 0x2e36 <vTaskDelayUntil+0x48>
    2e5e:	f8 01       	movw	r30, r16
    2e60:	80 83       	st	Z, r24
    2e62:	91 83       	std	Z+1, r25	; 0x01
    2e64:	60 e0       	ldi	r22, 0x00	; 0
    2e66:	84 1b       	sub	r24, r20
    2e68:	95 0b       	sbc	r25, r21
    2e6a:	0e 94 26 12 	call	0x244c	; 0x244c <prvAddCurrentTaskToDelayedList>
    2e6e:	e6 cf       	rjmp	.-52     	; 0x2e3c <vTaskDelayUntil+0x4e>
    2e70:	6c ec       	ldi	r22, 0xCC	; 204
    2e72:	74 e0       	ldi	r23, 0x04	; 4
    2e74:	8b e3       	ldi	r24, 0x3B	; 59
    2e76:	90 e2       	ldi	r25, 0x20	; 32
    2e78:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2e7c:	c7 cf       	rjmp	.-114    	; 0x2e0c <vTaskDelayUntil+0x1e>
    2e7e:	6b ec       	ldi	r22, 0xCB	; 203
    2e80:	74 e0       	ldi	r23, 0x04	; 4
    2e82:	8b e3       	ldi	r24, 0x3B	; 59
    2e84:	90 e2       	ldi	r25, 0x20	; 32
    2e86:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2e8a:	bc cf       	rjmp	.-136    	; 0x2e04 <vTaskDelayUntil+0x16>
    2e8c:	6a ec       	ldi	r22, 0xCA	; 202
    2e8e:	74 e0       	ldi	r23, 0x04	; 4
    2e90:	8b e3       	ldi	r24, 0x3B	; 59
    2e92:	90 e2       	ldi	r25, 0x20	; 32
    2e94:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2e98:	b3 cf       	rjmp	.-154    	; 0x2e00 <vTaskDelayUntil+0x12>

00002e9a <vTaskDelay>:
    2e9a:	cf 93       	push	r28
    2e9c:	df 93       	push	r29
    2e9e:	ec 01       	movw	r28, r24
    2ea0:	89 2b       	or	r24, r25
    2ea2:	29 f4       	brne	.+10     	; 0x2eae <vTaskDelay+0x14>
    2ea4:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vPortYield>
    2ea8:	df 91       	pop	r29
    2eaa:	cf 91       	pop	r28
    2eac:	08 95       	ret
    2eae:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2eb2:	81 11       	cpse	r24, r1
    2eb4:	10 c0       	rjmp	.+32     	; 0x2ed6 <vTaskDelay+0x3c>
    2eb6:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2eba:	8f 5f       	subi	r24, 0xFF	; 255
    2ebc:	80 93 64 21 	sts	0x2164, r24	; 0x802164 <uxSchedulerSuspended>
    2ec0:	60 e0       	ldi	r22, 0x00	; 0
    2ec2:	ce 01       	movw	r24, r28
    2ec4:	0e 94 26 12 	call	0x244c	; 0x244c <prvAddCurrentTaskToDelayedList>
    2ec8:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskResumeAll>
    2ecc:	88 23       	and	r24, r24
    2ece:	51 f3       	breq	.-44     	; 0x2ea4 <vTaskDelay+0xa>
    2ed0:	df 91       	pop	r29
    2ed2:	cf 91       	pop	r28
    2ed4:	08 95       	ret
    2ed6:	60 e2       	ldi	r22, 0x20	; 32
    2ed8:	75 e0       	ldi	r23, 0x05	; 5
    2eda:	8b e3       	ldi	r24, 0x3B	; 59
    2edc:	90 e2       	ldi	r25, 0x20	; 32
    2ede:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2ee2:	e9 cf       	rjmp	.-46     	; 0x2eb6 <vTaskDelay+0x1c>

00002ee4 <vTaskSwitchContext>:
    2ee4:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2ee8:	81 11       	cpse	r24, r1
    2eea:	02 c0       	rjmp	.+4      	; 0x2ef0 <vTaskSwitchContext+0xc>
    2eec:	0c 94 82 12 	jmp	0x2504	; 0x2504 <vTaskSwitchContext.part.5>
    2ef0:	81 e0       	ldi	r24, 0x01	; 1
    2ef2:	80 93 6b 21 	sts	0x216B, r24	; 0x80216b <xYieldPending>
    2ef6:	08 95       	ret

00002ef8 <vTaskPlaceOnEventList>:
    2ef8:	0f 93       	push	r16
    2efa:	1f 93       	push	r17
    2efc:	cf 93       	push	r28
    2efe:	df 93       	push	r29
    2f00:	ec 01       	movw	r28, r24
    2f02:	8b 01       	movw	r16, r22
    2f04:	89 2b       	or	r24, r25
    2f06:	89 f0       	breq	.+34     	; 0x2f2a <vTaskPlaceOnEventList+0x32>
    2f08:	60 91 fe 21 	lds	r22, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2f0c:	70 91 ff 21 	lds	r23, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2f10:	64 5f       	subi	r22, 0xF4	; 244
    2f12:	7f 4f       	sbci	r23, 0xFF	; 255
    2f14:	ce 01       	movw	r24, r28
    2f16:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <vListInsert>
    2f1a:	61 e0       	ldi	r22, 0x01	; 1
    2f1c:	c8 01       	movw	r24, r16
    2f1e:	df 91       	pop	r29
    2f20:	cf 91       	pop	r28
    2f22:	1f 91       	pop	r17
    2f24:	0f 91       	pop	r16
    2f26:	0c 94 26 12 	jmp	0x244c	; 0x244c <prvAddCurrentTaskToDelayedList>
    2f2a:	63 ea       	ldi	r22, 0xA3	; 163
    2f2c:	7b e0       	ldi	r23, 0x0B	; 11
    2f2e:	8b e3       	ldi	r24, 0x3B	; 59
    2f30:	90 e2       	ldi	r25, 0x20	; 32
    2f32:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2f36:	e8 cf       	rjmp	.-48     	; 0x2f08 <vTaskPlaceOnEventList+0x10>

00002f38 <xTaskRemoveFromEventList>:
    2f38:	0f 93       	push	r16
    2f3a:	1f 93       	push	r17
    2f3c:	cf 93       	push	r28
    2f3e:	df 93       	push	r29
    2f40:	dc 01       	movw	r26, r24
    2f42:	15 96       	adiw	r26, 0x05	; 5
    2f44:	ed 91       	ld	r30, X+
    2f46:	fc 91       	ld	r31, X
    2f48:	16 97       	sbiw	r26, 0x06	; 6
    2f4a:	c6 81       	ldd	r28, Z+6	; 0x06
    2f4c:	d7 81       	ldd	r29, Z+7	; 0x07
    2f4e:	20 97       	sbiw	r28, 0x00	; 0
    2f50:	09 f4       	brne	.+2      	; 0x2f54 <xTaskRemoveFromEventList+0x1c>
    2f52:	42 c0       	rjmp	.+132    	; 0x2fd8 <xTaskRemoveFromEventList+0xa0>
    2f54:	8e 01       	movw	r16, r28
    2f56:	04 5f       	subi	r16, 0xF4	; 244
    2f58:	1f 4f       	sbci	r17, 0xFF	; 255
    2f5a:	c8 01       	movw	r24, r16
    2f5c:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2f60:	80 91 64 21 	lds	r24, 0x2164	; 0x802164 <uxSchedulerSuspended>
    2f64:	81 11       	cpse	r24, r1
    2f66:	29 c0       	rjmp	.+82     	; 0x2fba <xTaskRemoveFromEventList+0x82>
    2f68:	0a 50       	subi	r16, 0x0A	; 10
    2f6a:	11 09       	sbc	r17, r1
    2f6c:	c8 01       	movw	r24, r16
    2f6e:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    2f72:	8e 89       	ldd	r24, Y+22	; 0x16
    2f74:	90 91 6e 21 	lds	r25, 0x216E	; 0x80216e <uxTopReadyPriority>
    2f78:	98 17       	cp	r25, r24
    2f7a:	28 f1       	brcs	.+74     	; 0x2fc6 <xTaskRemoveFromEventList+0x8e>
    2f7c:	90 e0       	ldi	r25, 0x00	; 0
    2f7e:	9c 01       	movw	r18, r24
    2f80:	22 0f       	add	r18, r18
    2f82:	33 1f       	adc	r19, r19
    2f84:	22 0f       	add	r18, r18
    2f86:	33 1f       	adc	r19, r19
    2f88:	22 0f       	add	r18, r18
    2f8a:	33 1f       	adc	r19, r19
    2f8c:	82 0f       	add	r24, r18
    2f8e:	93 1f       	adc	r25, r19
    2f90:	b8 01       	movw	r22, r16
    2f92:	8c 55       	subi	r24, 0x5C	; 92
    2f94:	9e 4d       	sbci	r25, 0xDE	; 222
    2f96:	0e 94 c3 09 	call	0x1386	; 0x1386 <vListInsertEnd>
    2f9a:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    2f9e:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    2fa2:	9e 89       	ldd	r25, Y+22	; 0x16
    2fa4:	86 89       	ldd	r24, Z+22	; 0x16
    2fa6:	89 17       	cp	r24, r25
    2fa8:	88 f4       	brcc	.+34     	; 0x2fcc <xTaskRemoveFromEventList+0x94>
    2faa:	81 e0       	ldi	r24, 0x01	; 1
    2fac:	80 93 6b 21 	sts	0x216B, r24	; 0x80216b <xYieldPending>
    2fb0:	df 91       	pop	r29
    2fb2:	cf 91       	pop	r28
    2fb4:	1f 91       	pop	r17
    2fb6:	0f 91       	pop	r16
    2fb8:	08 95       	ret
    2fba:	b8 01       	movw	r22, r16
    2fbc:	85 e8       	ldi	r24, 0x85	; 133
    2fbe:	91 e2       	ldi	r25, 0x21	; 33
    2fc0:	0e 94 c3 09 	call	0x1386	; 0x1386 <vListInsertEnd>
    2fc4:	ea cf       	rjmp	.-44     	; 0x2f9a <xTaskRemoveFromEventList+0x62>
    2fc6:	80 93 6e 21 	sts	0x216E, r24	; 0x80216e <uxTopReadyPriority>
    2fca:	d8 cf       	rjmp	.-80     	; 0x2f7c <xTaskRemoveFromEventList+0x44>
    2fcc:	80 e0       	ldi	r24, 0x00	; 0
    2fce:	df 91       	pop	r29
    2fd0:	cf 91       	pop	r28
    2fd2:	1f 91       	pop	r17
    2fd4:	0f 91       	pop	r16
    2fd6:	08 95       	ret
    2fd8:	6e ef       	ldi	r22, 0xFE	; 254
    2fda:	7b e0       	ldi	r23, 0x0B	; 11
    2fdc:	8b e3       	ldi	r24, 0x3B	; 59
    2fde:	90 e2       	ldi	r25, 0x20	; 32
    2fe0:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    2fe4:	b7 cf       	rjmp	.-146    	; 0x2f54 <xTaskRemoveFromEventList+0x1c>

00002fe6 <vTaskInternalSetTimeOutState>:
    2fe6:	20 91 6a 21 	lds	r18, 0x216A	; 0x80216a <xNumOfOverflows>
    2fea:	fc 01       	movw	r30, r24
    2fec:	20 83       	st	Z, r18
    2fee:	20 91 6f 21 	lds	r18, 0x216F	; 0x80216f <xTickCount>
    2ff2:	30 91 70 21 	lds	r19, 0x2170	; 0x802170 <xTickCount+0x1>
    2ff6:	21 83       	std	Z+1, r18	; 0x01
    2ff8:	32 83       	std	Z+2, r19	; 0x02
    2ffa:	08 95       	ret

00002ffc <xTaskCheckForTimeOut>:
    2ffc:	0f 93       	push	r16
    2ffe:	1f 93       	push	r17
    3000:	cf 93       	push	r28
    3002:	df 93       	push	r29
    3004:	ec 01       	movw	r28, r24
    3006:	8b 01       	movw	r16, r22
    3008:	89 2b       	or	r24, r25
    300a:	09 f4       	brne	.+2      	; 0x300e <xTaskCheckForTimeOut+0x12>
    300c:	40 c0       	rjmp	.+128    	; 0x308e <xTaskCheckForTimeOut+0x92>
    300e:	01 15       	cp	r16, r1
    3010:	11 05       	cpc	r17, r1
    3012:	09 f4       	brne	.+2      	; 0x3016 <xTaskCheckForTimeOut+0x1a>
    3014:	43 c0       	rjmp	.+134    	; 0x309c <xTaskCheckForTimeOut+0xa0>
    3016:	0f b6       	in	r0, 0x3f	; 63
    3018:	f8 94       	cli
    301a:	0f 92       	push	r0
    301c:	80 91 6f 21 	lds	r24, 0x216F	; 0x80216f <xTickCount>
    3020:	90 91 70 21 	lds	r25, 0x2170	; 0x802170 <xTickCount+0x1>
    3024:	f8 01       	movw	r30, r16
    3026:	20 81       	ld	r18, Z
    3028:	31 81       	ldd	r19, Z+1	; 0x01
    302a:	2f 3f       	cpi	r18, 0xFF	; 255
    302c:	ff ef       	ldi	r31, 0xFF	; 255
    302e:	3f 07       	cpc	r19, r31
    3030:	61 f1       	breq	.+88     	; 0x308a <xTaskCheckForTimeOut+0x8e>
    3032:	49 81       	ldd	r20, Y+1	; 0x01
    3034:	5a 81       	ldd	r21, Y+2	; 0x02
    3036:	60 91 6a 21 	lds	r22, 0x216A	; 0x80216a <xNumOfOverflows>
    303a:	78 81       	ld	r23, Y
    303c:	76 17       	cp	r23, r22
    303e:	19 f0       	breq	.+6      	; 0x3046 <xTaskCheckForTimeOut+0x4a>
    3040:	84 17       	cp	r24, r20
    3042:	95 07       	cpc	r25, r21
    3044:	80 f4       	brcc	.+32     	; 0x3066 <xTaskCheckForTimeOut+0x6a>
    3046:	84 1b       	sub	r24, r20
    3048:	95 0b       	sbc	r25, r21
    304a:	82 17       	cp	r24, r18
    304c:	93 07       	cpc	r25, r19
    304e:	68 f0       	brcs	.+26     	; 0x306a <xTaskCheckForTimeOut+0x6e>
    3050:	f8 01       	movw	r30, r16
    3052:	10 82       	st	Z, r1
    3054:	11 82       	std	Z+1, r1	; 0x01
    3056:	81 e0       	ldi	r24, 0x01	; 1
    3058:	0f 90       	pop	r0
    305a:	0f be       	out	0x3f, r0	; 63
    305c:	df 91       	pop	r29
    305e:	cf 91       	pop	r28
    3060:	1f 91       	pop	r17
    3062:	0f 91       	pop	r16
    3064:	08 95       	ret
    3066:	81 e0       	ldi	r24, 0x01	; 1
    3068:	f7 cf       	rjmp	.-18     	; 0x3058 <xTaskCheckForTimeOut+0x5c>
    306a:	28 1b       	sub	r18, r24
    306c:	39 0b       	sbc	r19, r25
    306e:	f8 01       	movw	r30, r16
    3070:	20 83       	st	Z, r18
    3072:	31 83       	std	Z+1, r19	; 0x01
    3074:	80 91 6a 21 	lds	r24, 0x216A	; 0x80216a <xNumOfOverflows>
    3078:	88 83       	st	Y, r24
    307a:	80 91 6f 21 	lds	r24, 0x216F	; 0x80216f <xTickCount>
    307e:	90 91 70 21 	lds	r25, 0x2170	; 0x802170 <xTickCount+0x1>
    3082:	89 83       	std	Y+1, r24	; 0x01
    3084:	9a 83       	std	Y+2, r25	; 0x02
    3086:	80 e0       	ldi	r24, 0x00	; 0
    3088:	e7 cf       	rjmp	.-50     	; 0x3058 <xTaskCheckForTimeOut+0x5c>
    308a:	80 e0       	ldi	r24, 0x00	; 0
    308c:	e5 cf       	rjmp	.-54     	; 0x3058 <xTaskCheckForTimeOut+0x5c>
    308e:	69 e6       	ldi	r22, 0x69	; 105
    3090:	7c e0       	ldi	r23, 0x0C	; 12
    3092:	8b e3       	ldi	r24, 0x3B	; 59
    3094:	90 e2       	ldi	r25, 0x20	; 32
    3096:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    309a:	b9 cf       	rjmp	.-142    	; 0x300e <xTaskCheckForTimeOut+0x12>
    309c:	6a e6       	ldi	r22, 0x6A	; 106
    309e:	7c e0       	ldi	r23, 0x0C	; 12
    30a0:	8b e3       	ldi	r24, 0x3B	; 59
    30a2:	90 e2       	ldi	r25, 0x20	; 32
    30a4:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    30a8:	b6 cf       	rjmp	.-148    	; 0x3016 <xTaskCheckForTimeOut+0x1a>

000030aa <vTaskMissedYield>:
    30aa:	81 e0       	ldi	r24, 0x01	; 1
    30ac:	80 93 6b 21 	sts	0x216B, r24	; 0x80216b <xYieldPending>
    30b0:	08 95       	ret

000030b2 <xTaskPriorityInherit>:
    30b2:	0f 93       	push	r16
    30b4:	1f 93       	push	r17
    30b6:	cf 93       	push	r28
    30b8:	df 93       	push	r29
    30ba:	fc 01       	movw	r30, r24
    30bc:	89 2b       	or	r24, r25
    30be:	09 f4       	brne	.+2      	; 0x30c2 <xTaskPriorityInherit+0x10>
    30c0:	41 c0       	rjmp	.+130    	; 0x3144 <xTaskPriorityInherit+0x92>
    30c2:	26 89       	ldd	r18, Z+22	; 0x16
    30c4:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    30c8:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    30cc:	56 96       	adiw	r26, 0x16	; 22
    30ce:	8c 91       	ld	r24, X
    30d0:	28 17       	cp	r18, r24
    30d2:	70 f5       	brcc	.+92     	; 0x3130 <xTaskPriorityInherit+0x7e>
    30d4:	84 85       	ldd	r24, Z+12	; 0x0c
    30d6:	95 85       	ldd	r25, Z+13	; 0x0d
    30d8:	97 fd       	sbrc	r25, 7
    30da:	0c c0       	rjmp	.+24     	; 0x30f4 <xTaskPriorityInherit+0x42>
    30dc:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    30e0:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    30e4:	56 96       	adiw	r26, 0x16	; 22
    30e6:	3c 91       	ld	r19, X
    30e8:	8a e0       	ldi	r24, 0x0A	; 10
    30ea:	90 e0       	ldi	r25, 0x00	; 0
    30ec:	83 1b       	sub	r24, r19
    30ee:	91 09       	sbc	r25, r1
    30f0:	84 87       	std	Z+12, r24	; 0x0c
    30f2:	95 87       	std	Z+13, r25	; 0x0d
    30f4:	30 e0       	ldi	r19, 0x00	; 0
    30f6:	c9 01       	movw	r24, r18
    30f8:	88 0f       	add	r24, r24
    30fa:	99 1f       	adc	r25, r25
    30fc:	88 0f       	add	r24, r24
    30fe:	99 1f       	adc	r25, r25
    3100:	88 0f       	add	r24, r24
    3102:	99 1f       	adc	r25, r25
    3104:	28 0f       	add	r18, r24
    3106:	39 1f       	adc	r19, r25
    3108:	2c 55       	subi	r18, 0x5C	; 92
    310a:	3e 4d       	sbci	r19, 0xDE	; 222
    310c:	82 85       	ldd	r24, Z+10	; 0x0a
    310e:	93 85       	ldd	r25, Z+11	; 0x0b
    3110:	82 17       	cp	r24, r18
    3112:	93 07       	cpc	r25, r19
    3114:	e9 f0       	breq	.+58     	; 0x3150 <xTaskPriorityInherit+0x9e>
    3116:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    311a:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    311e:	56 96       	adiw	r26, 0x16	; 22
    3120:	8c 91       	ld	r24, X
    3122:	86 8b       	std	Z+22, r24	; 0x16
    3124:	81 e0       	ldi	r24, 0x01	; 1
    3126:	df 91       	pop	r29
    3128:	cf 91       	pop	r28
    312a:	1f 91       	pop	r17
    312c:	0f 91       	pop	r16
    312e:	08 95       	ret
    3130:	a0 91 fe 21 	lds	r26, 0x21FE	; 0x8021fe <pxCurrentTCB>
    3134:	b0 91 ff 21 	lds	r27, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    3138:	81 e0       	ldi	r24, 0x01	; 1
    313a:	23 a1       	ldd	r18, Z+35	; 0x23
    313c:	56 96       	adiw	r26, 0x16	; 22
    313e:	9c 91       	ld	r25, X
    3140:	29 17       	cp	r18, r25
    3142:	88 f3       	brcs	.-30     	; 0x3126 <xTaskPriorityInherit+0x74>
    3144:	80 e0       	ldi	r24, 0x00	; 0
    3146:	df 91       	pop	r29
    3148:	cf 91       	pop	r28
    314a:	1f 91       	pop	r17
    314c:	0f 91       	pop	r16
    314e:	08 95       	ret
    3150:	8f 01       	movw	r16, r30
    3152:	ef 01       	movw	r28, r30
    3154:	22 96       	adiw	r28, 0x02	; 2
    3156:	ce 01       	movw	r24, r28
    3158:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    315c:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    3160:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    3164:	86 89       	ldd	r24, Z+22	; 0x16
    3166:	f8 01       	movw	r30, r16
    3168:	86 8b       	std	Z+22, r24	; 0x16
    316a:	90 91 6e 21 	lds	r25, 0x216E	; 0x80216e <uxTopReadyPriority>
    316e:	98 17       	cp	r25, r24
    3170:	10 f4       	brcc	.+4      	; 0x3176 <xTaskPriorityInherit+0xc4>
    3172:	80 93 6e 21 	sts	0x216E, r24	; 0x80216e <uxTopReadyPriority>
    3176:	90 e0       	ldi	r25, 0x00	; 0
    3178:	9c 01       	movw	r18, r24
    317a:	22 0f       	add	r18, r18
    317c:	33 1f       	adc	r19, r19
    317e:	22 0f       	add	r18, r18
    3180:	33 1f       	adc	r19, r19
    3182:	22 0f       	add	r18, r18
    3184:	33 1f       	adc	r19, r19
    3186:	82 0f       	add	r24, r18
    3188:	93 1f       	adc	r25, r19
    318a:	be 01       	movw	r22, r28
    318c:	8c 55       	subi	r24, 0x5C	; 92
    318e:	9e 4d       	sbci	r25, 0xDE	; 222
    3190:	0e 94 c3 09 	call	0x1386	; 0x1386 <vListInsertEnd>
    3194:	81 e0       	ldi	r24, 0x01	; 1
    3196:	c7 cf       	rjmp	.-114    	; 0x3126 <xTaskPriorityInherit+0x74>

00003198 <xTaskPriorityDisinherit>:
    3198:	0f 93       	push	r16
    319a:	1f 93       	push	r17
    319c:	cf 93       	push	r28
    319e:	df 93       	push	r29
    31a0:	00 97       	sbiw	r24, 0x00	; 0
    31a2:	c9 f0       	breq	.+50     	; 0x31d6 <xTaskPriorityDisinherit+0x3e>
    31a4:	ec 01       	movw	r28, r24
    31a6:	80 91 fe 21 	lds	r24, 0x21FE	; 0x8021fe <pxCurrentTCB>
    31aa:	90 91 ff 21 	lds	r25, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    31ae:	c8 17       	cp	r28, r24
    31b0:	d9 07       	cpc	r29, r25
    31b2:	31 f0       	breq	.+12     	; 0x31c0 <xTaskPriorityDisinherit+0x28>
    31b4:	6e e7       	ldi	r22, 0x7E	; 126
    31b6:	7f e0       	ldi	r23, 0x0F	; 15
    31b8:	8b e3       	ldi	r24, 0x3B	; 59
    31ba:	90 e2       	ldi	r25, 0x20	; 32
    31bc:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    31c0:	8c a1       	ldd	r24, Y+36	; 0x24
    31c2:	88 23       	and	r24, r24
    31c4:	c1 f1       	breq	.+112    	; 0x3236 <xTaskPriorityDisinherit+0x9e>
    31c6:	81 50       	subi	r24, 0x01	; 1
    31c8:	8c a3       	std	Y+36, r24	; 0x24
    31ca:	2e 89       	ldd	r18, Y+22	; 0x16
    31cc:	9b a1       	ldd	r25, Y+35	; 0x23
    31ce:	29 17       	cp	r18, r25
    31d0:	11 f0       	breq	.+4      	; 0x31d6 <xTaskPriorityDisinherit+0x3e>
    31d2:	88 23       	and	r24, r24
    31d4:	31 f0       	breq	.+12     	; 0x31e2 <xTaskPriorityDisinherit+0x4a>
    31d6:	80 e0       	ldi	r24, 0x00	; 0
    31d8:	df 91       	pop	r29
    31da:	cf 91       	pop	r28
    31dc:	1f 91       	pop	r17
    31de:	0f 91       	pop	r16
    31e0:	08 95       	ret
    31e2:	8e 01       	movw	r16, r28
    31e4:	0e 5f       	subi	r16, 0xFE	; 254
    31e6:	1f 4f       	sbci	r17, 0xFF	; 255
    31e8:	c8 01       	movw	r24, r16
    31ea:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    31ee:	2b a1       	ldd	r18, Y+35	; 0x23
    31f0:	2e 8b       	std	Y+22, r18	; 0x16
    31f2:	82 2f       	mov	r24, r18
    31f4:	90 e0       	ldi	r25, 0x00	; 0
    31f6:	4a e0       	ldi	r20, 0x0A	; 10
    31f8:	50 e0       	ldi	r21, 0x00	; 0
    31fa:	48 1b       	sub	r20, r24
    31fc:	59 0b       	sbc	r21, r25
    31fe:	4c 87       	std	Y+12, r20	; 0x0c
    3200:	5d 87       	std	Y+13, r21	; 0x0d
    3202:	30 91 6e 21 	lds	r19, 0x216E	; 0x80216e <uxTopReadyPriority>
    3206:	32 17       	cp	r19, r18
    3208:	10 f4       	brcc	.+4      	; 0x320e <xTaskPriorityDisinherit+0x76>
    320a:	20 93 6e 21 	sts	0x216E, r18	; 0x80216e <uxTopReadyPriority>
    320e:	9c 01       	movw	r18, r24
    3210:	22 0f       	add	r18, r18
    3212:	33 1f       	adc	r19, r19
    3214:	22 0f       	add	r18, r18
    3216:	33 1f       	adc	r19, r19
    3218:	22 0f       	add	r18, r18
    321a:	33 1f       	adc	r19, r19
    321c:	82 0f       	add	r24, r18
    321e:	93 1f       	adc	r25, r19
    3220:	b8 01       	movw	r22, r16
    3222:	8c 55       	subi	r24, 0x5C	; 92
    3224:	9e 4d       	sbci	r25, 0xDE	; 222
    3226:	0e 94 c3 09 	call	0x1386	; 0x1386 <vListInsertEnd>
    322a:	81 e0       	ldi	r24, 0x01	; 1
    322c:	df 91       	pop	r29
    322e:	cf 91       	pop	r28
    3230:	1f 91       	pop	r17
    3232:	0f 91       	pop	r16
    3234:	08 95       	ret
    3236:	6f e7       	ldi	r22, 0x7F	; 127
    3238:	7f e0       	ldi	r23, 0x0F	; 15
    323a:	8b e3       	ldi	r24, 0x3B	; 59
    323c:	90 e2       	ldi	r25, 0x20	; 32
    323e:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    3242:	8c a1       	ldd	r24, Y+36	; 0x24
    3244:	c0 cf       	rjmp	.-128    	; 0x31c6 <xTaskPriorityDisinherit+0x2e>

00003246 <vTaskPriorityDisinheritAfterTimeout>:
    3246:	0f 93       	push	r16
    3248:	1f 93       	push	r17
    324a:	cf 93       	push	r28
    324c:	df 93       	push	r29
    324e:	00 97       	sbiw	r24, 0x00	; 0
    3250:	79 f0       	breq	.+30     	; 0x3270 <vTaskPriorityDisinheritAfterTimeout+0x2a>
    3252:	16 2f       	mov	r17, r22
    3254:	ec 01       	movw	r28, r24
    3256:	8c a1       	ldd	r24, Y+36	; 0x24
    3258:	88 23       	and	r24, r24
    325a:	09 f4       	brne	.+2      	; 0x325e <vTaskPriorityDisinheritAfterTimeout+0x18>
    325c:	54 c0       	rjmp	.+168    	; 0x3306 <vTaskPriorityDisinheritAfterTimeout+0xc0>
    325e:	0b a1       	ldd	r16, Y+35	; 0x23
    3260:	01 17       	cp	r16, r17
    3262:	58 f0       	brcs	.+22     	; 0x327a <vTaskPriorityDisinheritAfterTimeout+0x34>
    3264:	8e 89       	ldd	r24, Y+22	; 0x16
    3266:	80 17       	cp	r24, r16
    3268:	19 f0       	breq	.+6      	; 0x3270 <vTaskPriorityDisinheritAfterTimeout+0x2a>
    326a:	9c a1       	ldd	r25, Y+36	; 0x24
    326c:	91 30       	cpi	r25, 0x01	; 1
    326e:	39 f0       	breq	.+14     	; 0x327e <vTaskPriorityDisinheritAfterTimeout+0x38>
    3270:	df 91       	pop	r29
    3272:	cf 91       	pop	r28
    3274:	1f 91       	pop	r17
    3276:	0f 91       	pop	r16
    3278:	08 95       	ret
    327a:	01 2f       	mov	r16, r17
    327c:	f3 cf       	rjmp	.-26     	; 0x3264 <vTaskPriorityDisinheritAfterTimeout+0x1e>
    327e:	20 91 fe 21 	lds	r18, 0x21FE	; 0x8021fe <pxCurrentTCB>
    3282:	30 91 ff 21 	lds	r19, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    3286:	c2 17       	cp	r28, r18
    3288:	d3 07       	cpc	r29, r19
    328a:	09 f4       	brne	.+2      	; 0x328e <vTaskPriorityDisinheritAfterTimeout+0x48>
    328c:	43 c0       	rjmp	.+134    	; 0x3314 <vTaskPriorityDisinheritAfterTimeout+0xce>
    328e:	0e 8b       	std	Y+22, r16	; 0x16
    3290:	2c 85       	ldd	r18, Y+12	; 0x0c
    3292:	3d 85       	ldd	r19, Y+13	; 0x0d
    3294:	37 fd       	sbrc	r19, 7
    3296:	06 c0       	rjmp	.+12     	; 0x32a4 <vTaskPriorityDisinheritAfterTimeout+0x5e>
    3298:	2a e0       	ldi	r18, 0x0A	; 10
    329a:	30 e0       	ldi	r19, 0x00	; 0
    329c:	20 1b       	sub	r18, r16
    329e:	31 09       	sbc	r19, r1
    32a0:	2c 87       	std	Y+12, r18	; 0x0c
    32a2:	3d 87       	std	Y+13, r19	; 0x0d
    32a4:	90 e0       	ldi	r25, 0x00	; 0
    32a6:	9c 01       	movw	r18, r24
    32a8:	22 0f       	add	r18, r18
    32aa:	33 1f       	adc	r19, r19
    32ac:	22 0f       	add	r18, r18
    32ae:	33 1f       	adc	r19, r19
    32b0:	22 0f       	add	r18, r18
    32b2:	33 1f       	adc	r19, r19
    32b4:	82 0f       	add	r24, r18
    32b6:	93 1f       	adc	r25, r19
    32b8:	8c 55       	subi	r24, 0x5C	; 92
    32ba:	9e 4d       	sbci	r25, 0xDE	; 222
    32bc:	2a 85       	ldd	r18, Y+10	; 0x0a
    32be:	3b 85       	ldd	r19, Y+11	; 0x0b
    32c0:	28 17       	cp	r18, r24
    32c2:	39 07       	cpc	r19, r25
    32c4:	a9 f6       	brne	.-86     	; 0x3270 <vTaskPriorityDisinheritAfterTimeout+0x2a>
    32c6:	8e 01       	movw	r16, r28
    32c8:	0e 5f       	subi	r16, 0xFE	; 254
    32ca:	1f 4f       	sbci	r17, 0xFF	; 255
    32cc:	c8 01       	movw	r24, r16
    32ce:	0e 94 15 0a 	call	0x142a	; 0x142a <uxListRemove>
    32d2:	8e 89       	ldd	r24, Y+22	; 0x16
    32d4:	90 91 6e 21 	lds	r25, 0x216E	; 0x80216e <uxTopReadyPriority>
    32d8:	98 17       	cp	r25, r24
    32da:	10 f4       	brcc	.+4      	; 0x32e0 <vTaskPriorityDisinheritAfterTimeout+0x9a>
    32dc:	80 93 6e 21 	sts	0x216E, r24	; 0x80216e <uxTopReadyPriority>
    32e0:	90 e0       	ldi	r25, 0x00	; 0
    32e2:	9c 01       	movw	r18, r24
    32e4:	22 0f       	add	r18, r18
    32e6:	33 1f       	adc	r19, r19
    32e8:	22 0f       	add	r18, r18
    32ea:	33 1f       	adc	r19, r19
    32ec:	22 0f       	add	r18, r18
    32ee:	33 1f       	adc	r19, r19
    32f0:	82 0f       	add	r24, r18
    32f2:	93 1f       	adc	r25, r19
    32f4:	b8 01       	movw	r22, r16
    32f6:	8c 55       	subi	r24, 0x5C	; 92
    32f8:	9e 4d       	sbci	r25, 0xDE	; 222
    32fa:	df 91       	pop	r29
    32fc:	cf 91       	pop	r28
    32fe:	1f 91       	pop	r17
    3300:	0f 91       	pop	r16
    3302:	0c 94 c3 09 	jmp	0x1386	; 0x1386 <vListInsertEnd>
    3306:	6d ec       	ldi	r22, 0xCD	; 205
    3308:	7f e0       	ldi	r23, 0x0F	; 15
    330a:	8b e3       	ldi	r24, 0x3B	; 59
    330c:	90 e2       	ldi	r25, 0x20	; 32
    330e:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    3312:	a5 cf       	rjmp	.-182    	; 0x325e <vTaskPriorityDisinheritAfterTimeout+0x18>
    3314:	68 ee       	ldi	r22, 0xE8	; 232
    3316:	7f e0       	ldi	r23, 0x0F	; 15
    3318:	8b e3       	ldi	r24, 0x3B	; 59
    331a:	90 e2       	ldi	r25, 0x20	; 32
    331c:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vAssertCalled>
    3320:	8e 89       	ldd	r24, Y+22	; 0x16
    3322:	b5 cf       	rjmp	.-150    	; 0x328e <vTaskPriorityDisinheritAfterTimeout+0x48>

00003324 <pvTaskIncrementMutexHeldCount>:

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    3324:	80 91 fe 21 	lds	r24, 0x21FE	; 0x8021fe <pxCurrentTCB>
    3328:	90 91 ff 21 	lds	r25, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    332c:	89 2b       	or	r24, r25
    332e:	39 f0       	breq	.+14     	; 0x333e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    3330:	e0 91 fe 21 	lds	r30, 0x21FE	; 0x8021fe <pxCurrentTCB>
    3334:	f0 91 ff 21 	lds	r31, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
    3338:	84 a1       	ldd	r24, Z+36	; 0x24
    333a:	8f 5f       	subi	r24, 0xFF	; 255
    333c:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    333e:	80 91 fe 21 	lds	r24, 0x21FE	; 0x8021fe <pxCurrentTCB>
    3342:	90 91 ff 21 	lds	r25, 0x21FF	; 0x8021ff <pxCurrentTCB+0x1>
	}
    3346:	08 95       	ret

00003348 <vApplicationIdleHook>:
#define SET_ERR_LED() PORTA.OUTSET=1<<7
#define CLR_ERR_LED() PORTA.OUTCLR=1<<7


void vApplicationIdleHook( void )
{
    3348:	08 95       	ret

0000334a <vApplicationMallocFailedHook>:
	
}

void vApplicationMallocFailedHook(void)
{
	taskDISABLE_INTERRUPTS();
    334a:	f8 94       	cli
	DbgPrint ("ERROR: memory allocation failed\r\n");
    334c:	8e e7       	ldi	r24, 0x7E	; 126
    334e:	90 e2       	ldi	r25, 0x20	; 32
    3350:	0e 94 b5 02 	call	0x56a	; 0x56a <DbgPrint>
	CFG_ERR_LED();
    3354:	80 e8       	ldi	r24, 0x80	; 128
    3356:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	while (1)
	{
		SET_ERR_LED();
    335a:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    335e:	2f ef       	ldi	r18, 0xFF	; 255
    3360:	33 ec       	ldi	r19, 0xC3	; 195
    3362:	99 e0       	ldi	r25, 0x09	; 9
    3364:	21 50       	subi	r18, 0x01	; 1
    3366:	30 40       	sbci	r19, 0x00	; 0
    3368:	90 40       	sbci	r25, 0x00	; 0
    336a:	e1 f7       	brne	.-8      	; 0x3364 <vApplicationMallocFailedHook+0x1a>
    336c:	00 c0       	rjmp	.+0      	; 0x336e <vApplicationMallocFailedHook+0x24>
    336e:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    3370:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    3374:	2f ef       	ldi	r18, 0xFF	; 255
    3376:	33 ec       	ldi	r19, 0xC3	; 195
    3378:	99 e0       	ldi	r25, 0x09	; 9
    337a:	21 50       	subi	r18, 0x01	; 1
    337c:	30 40       	sbci	r19, 0x00	; 0
    337e:	90 40       	sbci	r25, 0x00	; 0
    3380:	e1 f7       	brne	.-8      	; 0x337a <vApplicationMallocFailedHook+0x30>
    3382:	00 c0       	rjmp	.+0      	; 0x3384 <vApplicationMallocFailedHook+0x3a>
    3384:	00 00       	nop
    3386:	e9 cf       	rjmp	.-46     	; 0x335a <vApplicationMallocFailedHook+0x10>

00003388 <vApplicationStackOverflowHook>:
}



void vApplicationStackOverflowHook( TaskHandle_t xTask,signed char *pcTaskName )
{
    3388:	eb 01       	movw	r28, r22
	taskDISABLE_INTERRUPTS();
    338a:	f8 94       	cli
	CFG_ERR_LED();
    338c:	80 e8       	ldi	r24, 0x80	; 128
    338e:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	DbgPrint("STACK overflow in task ");
    3392:	80 ea       	ldi	r24, 0xA0	; 160
    3394:	90 e2       	ldi	r25, 0x20	; 32
    3396:	0e 94 b5 02 	call	0x56a	; 0x56a <DbgPrint>
	DbgPrintn(pcTaskName,10);
    339a:	6a e0       	ldi	r22, 0x0A	; 10
    339c:	70 e0       	ldi	r23, 0x00	; 0
    339e:	ce 01       	movw	r24, r28
    33a0:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <DbgPrintn>
	DbgPrint("\r\n");
    33a4:	8b e7       	ldi	r24, 0x7B	; 123
    33a6:	90 e2       	ldi	r25, 0x20	; 32
    33a8:	0e 94 b5 02 	call	0x56a	; 0x56a <DbgPrint>
	while (1)
	{
		SET_ERR_LED();
    33ac:	80 e8       	ldi	r24, 0x80	; 128
    33ae:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    33b2:	2f ef       	ldi	r18, 0xFF	; 255
    33b4:	33 ed       	ldi	r19, 0xD3	; 211
    33b6:	90 e3       	ldi	r25, 0x30	; 48
    33b8:	21 50       	subi	r18, 0x01	; 1
    33ba:	30 40       	sbci	r19, 0x00	; 0
    33bc:	90 40       	sbci	r25, 0x00	; 0
    33be:	e1 f7       	brne	.-8      	; 0x33b8 <vApplicationStackOverflowHook+0x30>
    33c0:	00 c0       	rjmp	.+0      	; 0x33c2 <vApplicationStackOverflowHook+0x3a>
    33c2:	00 00       	nop
		_delay_ms(500);
		CLR_ERR_LED();
    33c4:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    33c8:	2f ef       	ldi	r18, 0xFF	; 255
    33ca:	33 ed       	ldi	r19, 0xD3	; 211
    33cc:	90 e3       	ldi	r25, 0x30	; 48
    33ce:	21 50       	subi	r18, 0x01	; 1
    33d0:	30 40       	sbci	r19, 0x00	; 0
    33d2:	90 40       	sbci	r25, 0x00	; 0
    33d4:	e1 f7       	brne	.-8      	; 0x33ce <vApplicationStackOverflowHook+0x46>
    33d6:	00 c0       	rjmp	.+0      	; 0x33d8 <vApplicationStackOverflowHook+0x50>
    33d8:	00 00       	nop
    33da:	e9 cf       	rjmp	.-46     	; 0x33ae <vApplicationStackOverflowHook+0x26>

000033dc <vAssertCalled>:
		_delay_ms(500);
	}
}

void vAssertCalled( char *File, int Line)
{
    33dc:	8c 01       	movw	r16, r24
    33de:	eb 01       	movw	r28, r22
	taskDISABLE_INTERRUPTS();	
    33e0:	f8 94       	cli
	CFG_ERR_LED();
    33e2:	80 e8       	ldi	r24, 0x80	; 128
    33e4:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	DbgPrint("Assert in file ");
    33e8:	88 eb       	ldi	r24, 0xB8	; 184
    33ea:	90 e2       	ldi	r25, 0x20	; 32
    33ec:	0e 94 b5 02 	call	0x56a	; 0x56a <DbgPrint>
	DbgPrintn(File,100);
    33f0:	64 e6       	ldi	r22, 0x64	; 100
    33f2:	70 e0       	ldi	r23, 0x00	; 0
    33f4:	c8 01       	movw	r24, r16
    33f6:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <DbgPrintn>
	DbgPrint(", line nr ");
    33fa:	88 ec       	ldi	r24, 0xC8	; 200
    33fc:	90 e2       	ldi	r25, 0x20	; 32
    33fe:	0e 94 b5 02 	call	0x56a	; 0x56a <DbgPrint>
	DbgPrintInt(Line);
    3402:	ce 01       	movw	r24, r28
    3404:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <DbgPrintInt>
	DbgPrint("\r\n");
    3408:	8b e7       	ldi	r24, 0x7B	; 123
    340a:	90 e2       	ldi	r25, 0x20	; 32
    340c:	0e 94 b5 02 	call	0x56a	; 0x56a <DbgPrint>

	while (1)
	{
		SET_ERR_LED();
    3410:	80 e8       	ldi	r24, 0x80	; 128
    3412:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    3416:	2f ef       	ldi	r18, 0xFF	; 255
    3418:	33 ec       	ldi	r19, 0xC3	; 195
    341a:	99 e0       	ldi	r25, 0x09	; 9
    341c:	21 50       	subi	r18, 0x01	; 1
    341e:	30 40       	sbci	r19, 0x00	; 0
    3420:	90 40       	sbci	r25, 0x00	; 0
    3422:	e1 f7       	brne	.-8      	; 0x341c <vAssertCalled+0x40>
    3424:	00 c0       	rjmp	.+0      	; 0x3426 <vAssertCalled+0x4a>
    3426:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    3428:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    342c:	2f ef       	ldi	r18, 0xFF	; 255
    342e:	33 ed       	ldi	r19, 0xD3	; 211
    3430:	90 e3       	ldi	r25, 0x30	; 48
    3432:	21 50       	subi	r18, 0x01	; 1
    3434:	30 40       	sbci	r19, 0x00	; 0
    3436:	90 40       	sbci	r25, 0x00	; 0
    3438:	e1 f7       	brne	.-8      	; 0x3432 <vAssertCalled+0x56>
    343a:	00 c0       	rjmp	.+0      	; 0x343c <vAssertCalled+0x60>
    343c:	00 00       	nop
    343e:	e9 cf       	rjmp	.-46     	; 0x3412 <vAssertCalled+0x36>

00003440 <main>:

uint8_t *ucHeap;

int main(void)
{
	DriverSysClkXtalInit();	//Clock init
    3440:	0e 94 68 07 	call	0xed0	; 0xed0 <DriverSysClkXtalInit>
	//Allocate FreeRTOS heap
	ucHeap=malloc(configTOTAL_HEAP_SIZE);
    3444:	80 e0       	ldi	r24, 0x00	; 0
    3446:	90 e4       	ldi	r25, 0x40	; 64
    3448:	0e 94 a8 23 	call	0x4750	; 0x4750 <malloc>
    344c:	80 93 24 22 	sts	0x2224, r24	; 0x802224 <ucHeap>
    3450:	90 93 25 22 	sts	0x2225, r25	; 0x802225 <ucHeap+0x1>
	if (ucHeap==NULL) while(1);
    3454:	89 2b       	or	r24, r25
    3456:	a9 f0       	breq	.+42     	; 0x3482 <main+0x42>
	
	//Enable interrupts
	PMIC.CTRL=0b111;		
    3458:	87 e0       	ldi	r24, 0x07	; 7
    345a:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    345e:	78 94       	sei
	
	
	//Init startup task
	InitStartupTask();
    3460:	0e 94 11 1d 	call	0x3a22	; 0x3a22 <InitStartupTask>
	
	SLEEP.CTRL |= (010 << 1);
    3464:	80 91 48 00 	lds	r24, 0x0048	; 0x800048 <__TEXT_REGION_LENGTH__+0x700048>
    3468:	80 61       	ori	r24, 0x10	; 16
    346a:	80 93 48 00 	sts	0x0048, r24	; 0x800048 <__TEXT_REGION_LENGTH__+0x700048>
	SLEEP.CTRL |= 1;
    346e:	80 91 48 00 	lds	r24, 0x0048	; 0x800048 <__TEXT_REGION_LENGTH__+0x700048>
    3472:	81 60       	ori	r24, 0x01	; 1
    3474:	80 93 48 00 	sts	0x0048, r24	; 0x800048 <__TEXT_REGION_LENGTH__+0x700048>
	
	//Start scheduler loop
	vTaskStartScheduler();	
    3478:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <vTaskStartScheduler>
	
	return 0;
}
    347c:	80 e0       	ldi	r24, 0x00	; 0
    347e:	90 e0       	ldi	r25, 0x00	; 0
    3480:	08 95       	ret
    3482:	ff cf       	rjmp	.-2      	; 0x3482 <main+0x42>

00003484 <WorkerMotorPos>:
	IncSet.IncSet2=IncSet2;
	xQueueSend(IncSetQueue,&IncSet,portMAX_DELAY);
}

void WorkerMotorPos(void *pvParameters)
{
    3484:	cf 93       	push	r28
    3486:	df 93       	push	r29
    3488:	cd b7       	in	r28, 0x3d	; 61
    348a:	de b7       	in	r29, 0x3e	; 62
    348c:	2c 97       	sbiw	r28, 0x0c	; 12
    348e:	cd bf       	out	0x3d, r28	; 61
    3490:	de bf       	out	0x3e, r29	; 62
	float Err1=0,Err2=0;
	
	IncSetStruct IncSet;
	EncoderStruct EncoderInfo;
	
	xLastWakeTime = xTaskGetTickCount();
    3492:	0e 94 84 15 	call	0x2b08	; 0x2b08 <xTaskGetTickCount>
    3496:	80 93 00 22 	sts	0x2200, r24	; 0x802200 <xLastWakeTime>
    349a:	90 93 01 22 	sts	0x2201, r25	; 0x802201 <xLastWakeTime+0x1>
void WorkerMotorPos(void *pvParameters)
{
	
	const TickType_t xPeriod = 10;
	
	float Set1=0,Set2=0;
    349e:	19 86       	std	Y+9, r1	; 0x09
    34a0:	1a 86       	std	Y+10, r1	; 0x0a
    34a2:	1b 86       	std	Y+11, r1	; 0x0b
    34a4:	1c 86       	std	Y+12, r1	; 0x0c
    34a6:	1d 82       	std	Y+5, r1	; 0x05
    34a8:	1e 82       	std	Y+6, r1	; 0x06
    34aa:	1f 82       	std	Y+7, r1	; 0x07
    34ac:	18 86       	std	Y+8, r1	; 0x08
    34ae:	77 c0       	rjmp	.+238    	; 0x359e <WorkerMotorPos+0x11a>
			//PID 1
			Err1=Set1-EncoderInfo.Cnt1;
			Out1=Err1*MOTPOS_KP;
			if (Out1>0) Out1+=MOTPOS_FF_OFFSET;
			if (Out1>4095) Out1=4095;
			if (Out1<0) Out1-=MOTPOS_FF_OFFSET;			
    34b0:	20 e0       	ldi	r18, 0x00	; 0
    34b2:	30 e0       	ldi	r19, 0x00	; 0
    34b4:	a9 01       	movw	r20, r18
    34b6:	c7 01       	movw	r24, r14
    34b8:	b6 01       	movw	r22, r12
    34ba:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <__cmpsf2>
    34be:	87 ff       	sbrs	r24, 7
    34c0:	0a c0       	rjmp	.+20     	; 0x34d6 <WorkerMotorPos+0x52>
    34c2:	20 e0       	ldi	r18, 0x00	; 0
    34c4:	30 e8       	ldi	r19, 0x80	; 128
    34c6:	4b eb       	ldi	r20, 0xBB	; 187
    34c8:	54 e4       	ldi	r21, 0x44	; 68
    34ca:	c7 01       	movw	r24, r14
    34cc:	b6 01       	movw	r22, r12
    34ce:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <__subsf3>
    34d2:	6b 01       	movw	r12, r22
    34d4:	7c 01       	movw	r14, r24
			if (Out1<-4095) Out1=-4095;
    34d6:	20 e0       	ldi	r18, 0x00	; 0
    34d8:	30 ef       	ldi	r19, 0xF0	; 240
    34da:	4f e7       	ldi	r20, 0x7F	; 127
    34dc:	55 ec       	ldi	r21, 0xC5	; 197
    34de:	c7 01       	movw	r24, r14
    34e0:	b6 01       	movw	r22, r12
    34e2:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <__cmpsf2>
    34e6:	87 ff       	sbrs	r24, 7
    34e8:	b6 c0       	rjmp	.+364    	; 0x3656 <WorkerMotorPos+0x1d2>
    34ea:	01 e0       	ldi	r16, 0x01	; 1
    34ec:	10 ef       	ldi	r17, 0xF0	; 240

			//PID 2
			Err2=Set2-EncoderInfo.Cnt2;
			Out2=Err2*MOTPOS_KP;
    34ee:	c5 01       	movw	r24, r10
    34f0:	b4 01       	movw	r22, r8
    34f2:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__floatsisf>
    34f6:	9b 01       	movw	r18, r22
    34f8:	ac 01       	movw	r20, r24
    34fa:	69 85       	ldd	r22, Y+9	; 0x09
    34fc:	7a 85       	ldd	r23, Y+10	; 0x0a
    34fe:	8b 85       	ldd	r24, Y+11	; 0x0b
    3500:	9c 85       	ldd	r25, Y+12	; 0x0c
    3502:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <__subsf3>
    3506:	20 e0       	ldi	r18, 0x00	; 0
    3508:	30 e0       	ldi	r19, 0x00	; 0
    350a:	46 e9       	ldi	r20, 0x96	; 150
    350c:	53 e4       	ldi	r21, 0x43	; 67
    350e:	0e 94 64 1f 	call	0x3ec8	; 0x3ec8 <__mulsf3>
    3512:	6b 01       	movw	r12, r22
    3514:	7c 01       	movw	r14, r24
			if (Out2>0) Out2+=MOTPOS_FF_OFFSET;
    3516:	20 e0       	ldi	r18, 0x00	; 0
    3518:	30 e0       	ldi	r19, 0x00	; 0
    351a:	a9 01       	movw	r20, r18
    351c:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <__gesf2>
    3520:	18 16       	cp	r1, r24
    3522:	54 f4       	brge	.+20     	; 0x3538 <WorkerMotorPos+0xb4>
    3524:	20 e0       	ldi	r18, 0x00	; 0
    3526:	30 e8       	ldi	r19, 0x80	; 128
    3528:	4b eb       	ldi	r20, 0xBB	; 187
    352a:	54 e4       	ldi	r21, 0x44	; 68
    352c:	c7 01       	movw	r24, r14
    352e:	b6 01       	movw	r22, r12
    3530:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <__addsf3>
    3534:	6b 01       	movw	r12, r22
    3536:	7c 01       	movw	r14, r24
			if (Out2>4095) Out2=4095;
    3538:	20 e0       	ldi	r18, 0x00	; 0
    353a:	30 ef       	ldi	r19, 0xF0	; 240
    353c:	4f e7       	ldi	r20, 0x7F	; 127
    353e:	55 e4       	ldi	r21, 0x45	; 69
    3540:	c7 01       	movw	r24, r14
    3542:	b6 01       	movw	r22, r12
    3544:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <__gesf2>
    3548:	18 16       	cp	r1, r24
    354a:	0c f4       	brge	.+2      	; 0x354e <WorkerMotorPos+0xca>
    354c:	8a c0       	rjmp	.+276    	; 0x3662 <WorkerMotorPos+0x1de>
			if (Out2<0) Out2-=MOTPOS_FF_OFFSET;
    354e:	20 e0       	ldi	r18, 0x00	; 0
    3550:	30 e0       	ldi	r19, 0x00	; 0
    3552:	a9 01       	movw	r20, r18
    3554:	c7 01       	movw	r24, r14
    3556:	b6 01       	movw	r22, r12
    3558:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <__cmpsf2>
    355c:	87 ff       	sbrs	r24, 7
    355e:	0a c0       	rjmp	.+20     	; 0x3574 <WorkerMotorPos+0xf0>
    3560:	20 e0       	ldi	r18, 0x00	; 0
    3562:	30 e8       	ldi	r19, 0x80	; 128
    3564:	4b eb       	ldi	r20, 0xBB	; 187
    3566:	54 e4       	ldi	r21, 0x44	; 68
    3568:	c7 01       	movw	r24, r14
    356a:	b6 01       	movw	r22, r12
    356c:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <__subsf3>
    3570:	6b 01       	movw	r12, r22
    3572:	7c 01       	movw	r14, r24
			if (Out2<-4095) Out2=-4095;
    3574:	20 e0       	ldi	r18, 0x00	; 0
    3576:	30 ef       	ldi	r19, 0xF0	; 240
    3578:	4f e7       	ldi	r20, 0x7F	; 127
    357a:	55 ec       	ldi	r21, 0xC5	; 197
    357c:	c7 01       	movw	r24, r14
    357e:	b6 01       	movw	r22, r12
    3580:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <__cmpsf2>
    3584:	87 ff       	sbrs	r24, 7
    3586:	74 c0       	rjmp	.+232    	; 0x3670 <WorkerMotorPos+0x1ec>
    3588:	61 e0       	ldi	r22, 0x01	; 1
    358a:	70 ef       	ldi	r23, 0xF0	; 240
			
			//printf ("Err:%f   Out:%f\r\n",Err2 ,Out2);			
			
			DriverMotorSet(Out1,Out2);
    358c:	c8 01       	movw	r24, r16
    358e:	0e 94 88 03 	call	0x710	; 0x710 <DriverMotorSet>
			
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    3592:	6a e0       	ldi	r22, 0x0A	; 10
    3594:	70 e0       	ldi	r23, 0x00	; 0
    3596:	80 e0       	ldi	r24, 0x00	; 0
    3598:	92 e2       	ldi	r25, 0x22	; 34
    359a:	0e 94 f7 16 	call	0x2dee	; 0x2dee <vTaskDelayUntil>
	
	xLastWakeTime = xTaskGetTickCount();
	
	while (1)
	{		
			EncoderInfo=DriverMotorGetEncoder();
    359e:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <DriverMotorGetEncoder>
    35a2:	6b 01       	movw	r12, r22
    35a4:	7c 01       	movw	r14, r24

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
    35a6:	60 e0       	ldi	r22, 0x00	; 0
    35a8:	70 e0       	ldi	r23, 0x00	; 0
    35aa:	80 91 06 22 	lds	r24, 0x2206	; 0x802206 <ResetSetpointSema>
    35ae:	90 91 07 22 	lds	r25, 0x2207	; 0x802207 <ResetSetpointSema+0x1>
    35b2:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <xQueueSemaphoreTake>
			{
				Set1=EncoderInfo.Cnt1;
    35b6:	26 01       	movw	r4, r12
    35b8:	dd 0c       	add	r13, r13
    35ba:	66 08       	sbc	r6, r6
    35bc:	77 08       	sbc	r7, r7
	while (1)
	{		
			EncoderInfo=DriverMotorGetEncoder();

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
    35be:	81 30       	cpi	r24, 0x01	; 1
    35c0:	09 f4       	brne	.+2      	; 0x35c4 <WorkerMotorPos+0x140>
    35c2:	90 c0       	rjmp	.+288    	; 0x36e4 <WorkerMotorPos+0x260>
    35c4:	47 01       	movw	r8, r14
    35c6:	ff 0c       	add	r15, r15
    35c8:	aa 08       	sbc	r10, r10
    35ca:	bb 08       	sbc	r11, r11
				Set1=EncoderInfo.Cnt1;
				Set2=EncoderInfo.Cnt2;
			}
			
			//Process setpoint increment data
			if (xQueueReceive(IncSetQueue,&IncSet,0)==pdPASS)
    35cc:	40 e0       	ldi	r20, 0x00	; 0
    35ce:	50 e0       	ldi	r21, 0x00	; 0
    35d0:	be 01       	movw	r22, r28
    35d2:	6f 5f       	subi	r22, 0xFF	; 255
    35d4:	7f 4f       	sbci	r23, 0xFF	; 255
    35d6:	80 91 04 22 	lds	r24, 0x2204	; 0x802204 <IncSetQueue>
    35da:	90 91 05 22 	lds	r25, 0x2205	; 0x802205 <IncSetQueue+0x1>
    35de:	0e 94 09 0f 	call	0x1e12	; 0x1e12 <xQueueReceive>
    35e2:	81 30       	cpi	r24, 0x01	; 1
    35e4:	09 f4       	brne	.+2      	; 0x35e8 <WorkerMotorPos+0x164>
    35e6:	49 c0       	rjmp	.+146    	; 0x367a <WorkerMotorPos+0x1f6>
				Set2+=((float) IncSet.IncSet2)/100;
			}
			
			//PID 1
			Err1=Set1-EncoderInfo.Cnt1;
			Out1=Err1*MOTPOS_KP;
    35e8:	c3 01       	movw	r24, r6
    35ea:	b2 01       	movw	r22, r4
    35ec:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__floatsisf>
    35f0:	9b 01       	movw	r18, r22
    35f2:	ac 01       	movw	r20, r24
    35f4:	6d 81       	ldd	r22, Y+5	; 0x05
    35f6:	7e 81       	ldd	r23, Y+6	; 0x06
    35f8:	8f 81       	ldd	r24, Y+7	; 0x07
    35fa:	98 85       	ldd	r25, Y+8	; 0x08
    35fc:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <__subsf3>
    3600:	20 e0       	ldi	r18, 0x00	; 0
    3602:	30 e0       	ldi	r19, 0x00	; 0
    3604:	46 e9       	ldi	r20, 0x96	; 150
    3606:	53 e4       	ldi	r21, 0x43	; 67
    3608:	0e 94 64 1f 	call	0x3ec8	; 0x3ec8 <__mulsf3>
    360c:	6b 01       	movw	r12, r22
    360e:	7c 01       	movw	r14, r24
			if (Out1>0) Out1+=MOTPOS_FF_OFFSET;
    3610:	20 e0       	ldi	r18, 0x00	; 0
    3612:	30 e0       	ldi	r19, 0x00	; 0
    3614:	a9 01       	movw	r20, r18
    3616:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <__gesf2>
    361a:	18 16       	cp	r1, r24
    361c:	54 f4       	brge	.+20     	; 0x3632 <WorkerMotorPos+0x1ae>
    361e:	20 e0       	ldi	r18, 0x00	; 0
    3620:	30 e8       	ldi	r19, 0x80	; 128
    3622:	4b eb       	ldi	r20, 0xBB	; 187
    3624:	54 e4       	ldi	r21, 0x44	; 68
    3626:	c7 01       	movw	r24, r14
    3628:	b6 01       	movw	r22, r12
    362a:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <__addsf3>
    362e:	6b 01       	movw	r12, r22
    3630:	7c 01       	movw	r14, r24
			if (Out1>4095) Out1=4095;
    3632:	20 e0       	ldi	r18, 0x00	; 0
    3634:	30 ef       	ldi	r19, 0xF0	; 240
    3636:	4f e7       	ldi	r20, 0x7F	; 127
    3638:	55 e4       	ldi	r21, 0x45	; 69
    363a:	c7 01       	movw	r24, r14
    363c:	b6 01       	movw	r22, r12
    363e:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <__gesf2>
    3642:	18 16       	cp	r1, r24
    3644:	0c f0       	brlt	.+2      	; 0x3648 <WorkerMotorPos+0x1c4>
    3646:	34 cf       	rjmp	.-408    	; 0x34b0 <WorkerMotorPos+0x2c>
    3648:	c1 2c       	mov	r12, r1
    364a:	90 ef       	ldi	r25, 0xF0	; 240
    364c:	d9 2e       	mov	r13, r25
    364e:	9f e7       	ldi	r25, 0x7F	; 127
    3650:	e9 2e       	mov	r14, r25
    3652:	95 e4       	ldi	r25, 0x45	; 69
    3654:	f9 2e       	mov	r15, r25
    3656:	c7 01       	movw	r24, r14
    3658:	b6 01       	movw	r22, r12
    365a:	0e 94 77 1e 	call	0x3cee	; 0x3cee <__fixsfsi>
    365e:	8b 01       	movw	r16, r22
    3660:	46 cf       	rjmp	.-372    	; 0x34ee <WorkerMotorPos+0x6a>

			//PID 2
			Err2=Set2-EncoderInfo.Cnt2;
			Out2=Err2*MOTPOS_KP;
			if (Out2>0) Out2+=MOTPOS_FF_OFFSET;
			if (Out2>4095) Out2=4095;
    3662:	c1 2c       	mov	r12, r1
    3664:	80 ef       	ldi	r24, 0xF0	; 240
    3666:	d8 2e       	mov	r13, r24
    3668:	8f e7       	ldi	r24, 0x7F	; 127
    366a:	e8 2e       	mov	r14, r24
    366c:	85 e4       	ldi	r24, 0x45	; 69
    366e:	f8 2e       	mov	r15, r24
    3670:	c7 01       	movw	r24, r14
    3672:	b6 01       	movw	r22, r12
    3674:	0e 94 77 1e 	call	0x3cee	; 0x3cee <__fixsfsi>
    3678:	89 cf       	rjmp	.-238    	; 0x358c <WorkerMotorPos+0x108>
			}
			
			//Process setpoint increment data
			if (xQueueReceive(IncSetQueue,&IncSet,0)==pdPASS)
			{
				Set1+=((float) IncSet.IncSet1)/100;
    367a:	69 81       	ldd	r22, Y+1	; 0x01
    367c:	7a 81       	ldd	r23, Y+2	; 0x02
    367e:	07 2e       	mov	r0, r23
    3680:	00 0c       	add	r0, r0
    3682:	88 0b       	sbc	r24, r24
    3684:	99 0b       	sbc	r25, r25
    3686:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__floatsisf>
    368a:	20 e0       	ldi	r18, 0x00	; 0
    368c:	30 e0       	ldi	r19, 0x00	; 0
    368e:	48 ec       	ldi	r20, 0xC8	; 200
    3690:	52 e4       	ldi	r21, 0x42	; 66
    3692:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <__divsf3>
    3696:	9b 01       	movw	r18, r22
    3698:	ac 01       	movw	r20, r24
    369a:	6d 81       	ldd	r22, Y+5	; 0x05
    369c:	7e 81       	ldd	r23, Y+6	; 0x06
    369e:	8f 81       	ldd	r24, Y+7	; 0x07
    36a0:	98 85       	ldd	r25, Y+8	; 0x08
    36a2:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <__addsf3>
    36a6:	6d 83       	std	Y+5, r22	; 0x05
    36a8:	7e 83       	std	Y+6, r23	; 0x06
    36aa:	8f 83       	std	Y+7, r24	; 0x07
    36ac:	98 87       	std	Y+8, r25	; 0x08
				Set2+=((float) IncSet.IncSet2)/100;
    36ae:	6b 81       	ldd	r22, Y+3	; 0x03
    36b0:	7c 81       	ldd	r23, Y+4	; 0x04
    36b2:	07 2e       	mov	r0, r23
    36b4:	00 0c       	add	r0, r0
    36b6:	88 0b       	sbc	r24, r24
    36b8:	99 0b       	sbc	r25, r25
    36ba:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__floatsisf>
    36be:	20 e0       	ldi	r18, 0x00	; 0
    36c0:	30 e0       	ldi	r19, 0x00	; 0
    36c2:	48 ec       	ldi	r20, 0xC8	; 200
    36c4:	52 e4       	ldi	r21, 0x42	; 66
    36c6:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <__divsf3>
    36ca:	9b 01       	movw	r18, r22
    36cc:	ac 01       	movw	r20, r24
    36ce:	69 85       	ldd	r22, Y+9	; 0x09
    36d0:	7a 85       	ldd	r23, Y+10	; 0x0a
    36d2:	8b 85       	ldd	r24, Y+11	; 0x0b
    36d4:	9c 85       	ldd	r25, Y+12	; 0x0c
    36d6:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <__addsf3>
    36da:	69 87       	std	Y+9, r22	; 0x09
    36dc:	7a 87       	std	Y+10, r23	; 0x0a
    36de:	8b 87       	std	Y+11, r24	; 0x0b
    36e0:	9c 87       	std	Y+12, r25	; 0x0c
    36e2:	82 cf       	rjmp	.-252    	; 0x35e8 <WorkerMotorPos+0x164>
			EncoderInfo=DriverMotorGetEncoder();

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
			{
				Set1=EncoderInfo.Cnt1;
    36e4:	c3 01       	movw	r24, r6
    36e6:	b2 01       	movw	r22, r4
    36e8:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__floatsisf>
    36ec:	6d 83       	std	Y+5, r22	; 0x05
    36ee:	7e 83       	std	Y+6, r23	; 0x06
    36f0:	8f 83       	std	Y+7, r24	; 0x07
    36f2:	98 87       	std	Y+8, r25	; 0x08
				Set2=EncoderInfo.Cnt2;
    36f4:	47 01       	movw	r8, r14
    36f6:	ff 0c       	add	r15, r15
    36f8:	aa 08       	sbc	r10, r10
    36fa:	bb 08       	sbc	r11, r11
    36fc:	c5 01       	movw	r24, r10
    36fe:	b4 01       	movw	r22, r8
    3700:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__floatsisf>
    3704:	69 87       	std	Y+9, r22	; 0x09
    3706:	7a 87       	std	Y+10, r23	; 0x0a
    3708:	8b 87       	std	Y+11, r24	; 0x0b
    370a:	9c 87       	std	Y+12, r25	; 0x0c
    370c:	5f cf       	rjmp	.-322    	; 0x35cc <WorkerMotorPos+0x148>

0000370e <EnableMotorPosTask>:
	vSemaphoreCreateBinary(ResetSetpointSema);
}

void EnableMotorPosTask()
{
	DriverMotorResetEncoder();
    370e:	0e 94 30 06 	call	0xc60	; 0xc60 <DriverMotorResetEncoder>
	xSemaphoreGive(ResetSetpointSema);
    3712:	20 e0       	ldi	r18, 0x00	; 0
    3714:	40 e0       	ldi	r20, 0x00	; 0
    3716:	50 e0       	ldi	r21, 0x00	; 0
    3718:	60 e0       	ldi	r22, 0x00	; 0
    371a:	70 e0       	ldi	r23, 0x00	; 0
    371c:	80 91 06 22 	lds	r24, 0x2206	; 0x802206 <ResetSetpointSema>
    3720:	90 91 07 22 	lds	r25, 0x2207	; 0x802207 <ResetSetpointSema+0x1>
    3724:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <xQueueGenericSend>
	xLastWakeTime = xTaskGetTickCount();
    3728:	0e 94 84 15 	call	0x2b08	; 0x2b08 <xTaskGetTickCount>
    372c:	80 93 00 22 	sts	0x2200, r24	; 0x802200 <xLastWakeTime>
    3730:	90 93 01 22 	sts	0x2201, r25	; 0x802201 <xLastWakeTime+0x1>
	vTaskResume(MotorPosTaskHandle);
    3734:	80 91 02 22 	lds	r24, 0x2202	; 0x802202 <MotorPosTaskHandle>
    3738:	90 91 03 22 	lds	r25, 0x2203	; 0x802203 <MotorPosTaskHandle+0x1>
    373c:	0c 94 f7 14 	jmp	0x29ee	; 0x29ee <vTaskResume>

00003740 <DisableMotorPosTask>:
}

void DisableMotorPosTask()
{
	vTaskSuspend(MotorPosTaskHandle);
    3740:	80 91 02 22 	lds	r24, 0x2202	; 0x802202 <MotorPosTaskHandle>
    3744:	90 91 03 22 	lds	r25, 0x2203	; 0x802203 <MotorPosTaskHandle+0x1>
    3748:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <vTaskSuspend>
	DriverMotorSet(0,0);
    374c:	60 e0       	ldi	r22, 0x00	; 0
    374e:	70 e0       	ldi	r23, 0x00	; 0
    3750:	80 e0       	ldi	r24, 0x00	; 0
    3752:	90 e0       	ldi	r25, 0x00	; 0
    3754:	0c 94 88 03 	jmp	0x710	; 0x710 <DriverMotorSet>

00003758 <InitMotorPosTask>:
//Private function prototypes
void WorkerMotorPos(void *pvParameters);

//Function definitions
void InitMotorPosTask()
{
    3758:	ef 92       	push	r14
    375a:	ff 92       	push	r15
    375c:	0f 93       	push	r16
	DriverMotorInit();
    375e:	0e 94 57 03 	call	0x6ae	; 0x6ae <DriverMotorInit>
	xTaskCreate( WorkerMotorPos, "motpos", 256, NULL, tskIDLE_PRIORITY+3, &MotorPosTaskHandle );
    3762:	82 e0       	ldi	r24, 0x02	; 2
    3764:	e8 2e       	mov	r14, r24
    3766:	82 e2       	ldi	r24, 0x22	; 34
    3768:	f8 2e       	mov	r15, r24
    376a:	03 e0       	ldi	r16, 0x03	; 3
    376c:	20 e0       	ldi	r18, 0x00	; 0
    376e:	30 e0       	ldi	r19, 0x00	; 0
    3770:	40 e0       	ldi	r20, 0x00	; 0
    3772:	51 e0       	ldi	r21, 0x01	; 1
    3774:	63 ed       	ldi	r22, 0xD3	; 211
    3776:	70 e2       	ldi	r23, 0x20	; 32
    3778:	82 e4       	ldi	r24, 0x42	; 66
    377a:	9a e1       	ldi	r25, 0x1A	; 26
    377c:	0e 94 44 13 	call	0x2688	; 0x2688 <xTaskCreate>
	DisableMotorPosTask(); 	
    3780:	0e 94 a0 1b 	call	0x3740	; 0x3740 <DisableMotorPosTask>
	
	IncSetQueue=xQueueCreate(1,sizeof(IncSetStruct));
    3784:	40 e0       	ldi	r20, 0x00	; 0
    3786:	64 e0       	ldi	r22, 0x04	; 4
    3788:	81 e0       	ldi	r24, 0x01	; 1
    378a:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericCreate>
    378e:	80 93 04 22 	sts	0x2204, r24	; 0x802204 <IncSetQueue>
    3792:	90 93 05 22 	sts	0x2205, r25	; 0x802205 <IncSetQueue+0x1>
	vSemaphoreCreateBinary(ResetSetpointSema);
    3796:	43 e0       	ldi	r20, 0x03	; 3
    3798:	60 e0       	ldi	r22, 0x00	; 0
    379a:	81 e0       	ldi	r24, 0x01	; 1
    379c:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericCreate>
    37a0:	80 93 06 22 	sts	0x2206, r24	; 0x802206 <ResetSetpointSema>
    37a4:	90 93 07 22 	sts	0x2207, r25	; 0x802207 <ResetSetpointSema+0x1>
    37a8:	00 97       	sbiw	r24, 0x00	; 0
    37aa:	51 f0       	breq	.+20     	; 0x37c0 <InitMotorPosTask+0x68>
    37ac:	20 e0       	ldi	r18, 0x00	; 0
    37ae:	40 e0       	ldi	r20, 0x00	; 0
    37b0:	50 e0       	ldi	r21, 0x00	; 0
    37b2:	60 e0       	ldi	r22, 0x00	; 0
    37b4:	70 e0       	ldi	r23, 0x00	; 0
}
    37b6:	0f 91       	pop	r16
    37b8:	ff 90       	pop	r15
    37ba:	ef 90       	pop	r14
	DriverMotorInit();
	xTaskCreate( WorkerMotorPos, "motpos", 256, NULL, tskIDLE_PRIORITY+3, &MotorPosTaskHandle );
	DisableMotorPosTask(); 	
	
	IncSetQueue=xQueueCreate(1,sizeof(IncSetStruct));
	vSemaphoreCreateBinary(ResetSetpointSema);
    37bc:	0c 94 8c 0d 	jmp	0x1b18	; 0x1b18 <xQueueGenericSend>
}
    37c0:	0f 91       	pop	r16
    37c2:	ff 90       	pop	r15
    37c4:	ef 90       	pop	r14
    37c6:	08 95       	ret

000037c8 <MotorPosIncSet>:
	DriverMotorSet(0,0);
}


void MotorPosIncSet(int16_t IncSet1,int16_t IncSet2)
{
    37c8:	cf 93       	push	r28
    37ca:	df 93       	push	r29
    37cc:	00 d0       	rcall	.+0      	; 0x37ce <MotorPosIncSet+0x6>
    37ce:	1f 92       	push	r1
    37d0:	cd b7       	in	r28, 0x3d	; 61
    37d2:	de b7       	in	r29, 0x3e	; 62
	IncSetStruct IncSet;
	IncSet.IncSet1=IncSet1;
    37d4:	89 83       	std	Y+1, r24	; 0x01
    37d6:	9a 83       	std	Y+2, r25	; 0x02
	IncSet.IncSet2=IncSet2;
    37d8:	6b 83       	std	Y+3, r22	; 0x03
    37da:	7c 83       	std	Y+4, r23	; 0x04
	xQueueSend(IncSetQueue,&IncSet,portMAX_DELAY);
    37dc:	20 e0       	ldi	r18, 0x00	; 0
    37de:	4f ef       	ldi	r20, 0xFF	; 255
    37e0:	5f ef       	ldi	r21, 0xFF	; 255
    37e2:	be 01       	movw	r22, r28
    37e4:	6f 5f       	subi	r22, 0xFF	; 255
    37e6:	7f 4f       	sbci	r23, 0xFF	; 255
    37e8:	80 91 04 22 	lds	r24, 0x2204	; 0x802204 <IncSetQueue>
    37ec:	90 91 05 22 	lds	r25, 0x2205	; 0x802205 <IncSetQueue+0x1>
    37f0:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <xQueueGenericSend>
}
    37f4:	24 96       	adiw	r28, 0x04	; 4
    37f6:	cd bf       	out	0x3d, r28	; 61
    37f8:	de bf       	out	0x3e, r29	; 62
    37fa:	df 91       	pop	r29
    37fc:	cf 91       	pop	r28
    37fe:	08 95       	ret

00003800 <WorkerMotorSpeed>:
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
	
}

void WorkerMotorSpeed(void *pvParameters)
{
    3800:	cf 93       	push	r28
    3802:	df 93       	push	r29
    3804:	00 d0       	rcall	.+0      	; 0x3806 <WorkerMotorSpeed+0x6>
    3806:	1f 92       	push	r1
    3808:	cd b7       	in	r28, 0x3d	; 61
    380a:	de b7       	in	r29, 0x3e	; 62
	const TickType_t xPeriod = 10;
	MotorSpeedStruct MotorSpeed;

	xLastWakeTime = xTaskGetTickCount();
    380c:	0e 94 84 15 	call	0x2b08	; 0x2b08 <xTaskGetTickCount>
    3810:	80 93 08 22 	sts	0x2208, r24	; 0x802208 <xLastWakeTime>
    3814:	90 93 09 22 	sts	0x2209, r25	; 0x802209 <xLastWakeTime+0x1>
	
	while (1)
	{
			xQueuePeek(MotorSpeedQueue,&MotorSpeed,portMAX_DELAY);
    3818:	4f ef       	ldi	r20, 0xFF	; 255
    381a:	5f ef       	ldi	r21, 0xFF	; 255
    381c:	be 01       	movw	r22, r28
    381e:	6f 5f       	subi	r22, 0xFF	; 255
    3820:	7f 4f       	sbci	r23, 0xFF	; 255
    3822:	80 91 0c 22 	lds	r24, 0x220C	; 0x80220c <MotorSpeedQueue>
    3826:	90 91 0d 22 	lds	r25, 0x220D	; 0x80220d <MotorSpeedQueue+0x1>
    382a:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueuePeek>
			MotorPosIncSet(MotorSpeed.Speed1,MotorSpeed.Speed2);
    382e:	6b 81       	ldd	r22, Y+3	; 0x03
    3830:	7c 81       	ldd	r23, Y+4	; 0x04
    3832:	89 81       	ldd	r24, Y+1	; 0x01
    3834:	9a 81       	ldd	r25, Y+2	; 0x02
    3836:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <MotorPosIncSet>
			
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    383a:	6a e0       	ldi	r22, 0x0A	; 10
    383c:	70 e0       	ldi	r23, 0x00	; 0
    383e:	88 e0       	ldi	r24, 0x08	; 8
    3840:	92 e2       	ldi	r25, 0x22	; 34
    3842:	0e 94 f7 16 	call	0x2dee	; 0x2dee <vTaskDelayUntil>
    3846:	e8 cf       	rjmp	.-48     	; 0x3818 <WorkerMotorSpeed+0x18>

00003848 <InitMotorSpeedTask>:
//Private function prototypes
void WorkerMotorSpeed(void *pvParameters);

//Function definitions
void InitMotorSpeedTask()
{
    3848:	ef 92       	push	r14
    384a:	ff 92       	push	r15
    384c:	0f 93       	push	r16
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
    384e:	8a e0       	ldi	r24, 0x0A	; 10
    3850:	e8 2e       	mov	r14, r24
    3852:	82 e2       	ldi	r24, 0x22	; 34
    3854:	f8 2e       	mov	r15, r24
    3856:	03 e0       	ldi	r16, 0x03	; 3
    3858:	20 e0       	ldi	r18, 0x00	; 0
    385a:	30 e0       	ldi	r19, 0x00	; 0
    385c:	40 e0       	ldi	r20, 0x00	; 0
    385e:	51 e0       	ldi	r21, 0x01	; 1
    3860:	6a ed       	ldi	r22, 0xDA	; 218
    3862:	70 e2       	ldi	r23, 0x20	; 32
    3864:	80 e0       	ldi	r24, 0x00	; 0
    3866:	9c e1       	ldi	r25, 0x1C	; 28
    3868:	0e 94 44 13 	call	0x2688	; 0x2688 <xTaskCreate>
	vTaskResume(MotorSpeedTaskHandle);
}

void DisableMotorSpeedTask()
{
	vTaskSuspend(MotorSpeedTaskHandle);
    386c:	80 91 0a 22 	lds	r24, 0x220A	; 0x80220a <MotorSpeedTaskHandle>
    3870:	90 91 0b 22 	lds	r25, 0x220B	; 0x80220b <MotorSpeedTaskHandle+0x1>
    3874:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <vTaskSuspend>
void InitMotorSpeedTask()
{
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
	DisableMotorSpeedTask();
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
    3878:	40 e0       	ldi	r20, 0x00	; 0
    387a:	64 e0       	ldi	r22, 0x04	; 4
    387c:	81 e0       	ldi	r24, 0x01	; 1
    387e:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericCreate>
    3882:	80 93 0c 22 	sts	0x220C, r24	; 0x80220c <MotorSpeedQueue>
    3886:	90 93 0d 22 	sts	0x220D, r25	; 0x80220d <MotorSpeedQueue+0x1>
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    388a:	ee e0       	ldi	r30, 0x0E	; 14
    388c:	f2 e2       	ldi	r31, 0x22	; 34
    388e:	10 82       	st	Z, r1
    3890:	11 82       	std	Z+1, r1	; 0x01
	MotorSpeed.Speed2=Speed2;
    3892:	12 82       	std	Z+2, r1	; 0x02
    3894:	13 82       	std	Z+3, r1	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    3896:	22 e0       	ldi	r18, 0x02	; 2
    3898:	40 e0       	ldi	r20, 0x00	; 0
    389a:	50 e0       	ldi	r21, 0x00	; 0
    389c:	bf 01       	movw	r22, r30
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
	DisableMotorSpeedTask();
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
	MotorSpeedSet(0,0);
}
    389e:	0f 91       	pop	r16
    38a0:	ff 90       	pop	r15
    38a2:	ef 90       	pop	r14
void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
	MotorSpeed.Speed2=Speed2;
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    38a4:	0c 94 8c 0d 	jmp	0x1b18	; 0x1b18 <xQueueGenericSend>

000038a8 <EnableMotorSpeedTask>:
	MotorSpeedSet(0,0);
}

void EnableMotorSpeedTask()
{
	xLastWakeTime = xTaskGetTickCount();
    38a8:	0e 94 84 15 	call	0x2b08	; 0x2b08 <xTaskGetTickCount>
    38ac:	80 93 08 22 	sts	0x2208, r24	; 0x802208 <xLastWakeTime>
    38b0:	90 93 09 22 	sts	0x2209, r25	; 0x802209 <xLastWakeTime+0x1>
	vTaskResume(MotorSpeedTaskHandle);
    38b4:	80 91 0a 22 	lds	r24, 0x220A	; 0x80220a <MotorSpeedTaskHandle>
    38b8:	90 91 0b 22 	lds	r25, 0x220B	; 0x80220b <MotorSpeedTaskHandle+0x1>
    38bc:	0c 94 f7 14 	jmp	0x29ee	; 0x29ee <vTaskResume>

000038c0 <DisableMotorSpeedTask>:
}

void DisableMotorSpeedTask()
{
	vTaskSuspend(MotorSpeedTaskHandle);
    38c0:	80 91 0a 22 	lds	r24, 0x220A	; 0x80220a <MotorSpeedTaskHandle>
    38c4:	90 91 0b 22 	lds	r25, 0x220B	; 0x80220b <MotorSpeedTaskHandle+0x1>
    38c8:	0c 94 7a 14 	jmp	0x28f4	; 0x28f4 <vTaskSuspend>

000038cc <MotorSpeedSet>:
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    38cc:	ee e0       	ldi	r30, 0x0E	; 14
    38ce:	f2 e2       	ldi	r31, 0x22	; 34
    38d0:	80 83       	st	Z, r24
    38d2:	91 83       	std	Z+1, r25	; 0x01
	MotorSpeed.Speed2=Speed2;
    38d4:	62 83       	std	Z+2, r22	; 0x02
    38d6:	73 83       	std	Z+3, r23	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    38d8:	22 e0       	ldi	r18, 0x02	; 2
    38da:	40 e0       	ldi	r20, 0x00	; 0
    38dc:	50 e0       	ldi	r21, 0x00	; 0
    38de:	bf 01       	movw	r22, r30
    38e0:	80 91 0c 22 	lds	r24, 0x220C	; 0x80220c <MotorSpeedQueue>
    38e4:	90 91 0d 22 	lds	r25, 0x220D	; 0x80220d <MotorSpeedQueue+0x1>
    38e8:	0c 94 8c 0d 	jmp	0x1b18	; 0x1b18 <xQueueGenericSend>

000038ec <WorkerRGB>:
	xQueueOverwrite(EffectQueue,&Effect);
	
}

void WorkerRGB(void *pvParameters)
{
    38ec:	cf 93       	push	r28
    38ee:	df 93       	push	r29
    38f0:	1f 92       	push	r1
    38f2:	cd b7       	in	r28, 0x3d	; 61
    38f4:	de b7       	in	r29, 0x3e	; 62
    38f6:	4a c0       	rjmp	.+148    	; 0x398c <WorkerRGB+0xa0>
		
		//Time slot 1
		if (Effect & RGB_HEADLIGHT_HIGH)
		{
			FrontRight=PL9823_RGB(255,255,255);
			FrontLeft=PL9823_RGB(255,255,255);
    38f8:	66 24       	eor	r6, r6
    38fa:	6a 94       	dec	r6
    38fc:	77 24       	eor	r7, r7
    38fe:	7a 94       	dec	r7
    3900:	88 24       	eor	r8, r8
    3902:	8a 94       	dec	r8
    3904:	91 2c       	mov	r9, r1
		}
		if (Effect & RGB_HEADLIGHT_LOW)
    3906:	80 ff       	sbrs	r24, 0
    3908:	07 c0       	rjmp	.+14     	; 0x3918 <WorkerRGB+0x2c>
		{
			FrontRight=PL9823_RGB(128,128,128);
			FrontLeft=PL9823_RGB(128,128,128);
    390a:	90 e8       	ldi	r25, 0x80	; 128
    390c:	69 2e       	mov	r6, r25
    390e:	20 e8       	ldi	r18, 0x80	; 128
    3910:	72 2e       	mov	r7, r18
    3912:	30 e8       	ldi	r19, 0x80	; 128
    3914:	83 2e       	mov	r8, r19
    3916:	91 2c       	mov	r9, r1
		}
		if (Effect & RGB_BRAKE)
    3918:	84 ff       	sbrs	r24, 4
    391a:	4b c0       	rjmp	.+150    	; 0x39b2 <WorkerRGB+0xc6>
		{
			RearRight=PL9823_RED;
    391c:	22 24       	eor	r2, r2
    391e:	2a 94       	dec	r2
    3920:	31 2c       	mov	r3, r1
    3922:	41 2c       	mov	r4, r1
    3924:	51 2c       	mov	r5, r1
			RearLeft=PL9823_RED;
		}

		DriverPL9823Set(FrontLeft,FrontRight,RearRight,RearLeft);
    3926:	51 01       	movw	r10, r2
    3928:	62 01       	movw	r12, r4
    392a:	71 01       	movw	r14, r2
    392c:	82 01       	movw	r16, r4
    392e:	93 01       	movw	r18, r6
    3930:	a4 01       	movw	r20, r8
    3932:	b3 01       	movw	r22, r6
    3934:	c4 01       	movw	r24, r8
    3936:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DriverPL9823Set>
		vTaskDelay(250); 
    393a:	8a ef       	ldi	r24, 0xFA	; 250
    393c:	90 e0       	ldi	r25, 0x00	; 0
    393e:	0e 94 4d 17 	call	0x2e9a	; 0x2e9a <vTaskDelay>
		
		//Time slot 2
		if (Effect & RGB_BLINK_LEFT)
    3942:	29 81       	ldd	r18, Y+1	; 0x01
    3944:	22 ff       	sbrs	r18, 2
    3946:	3a c0       	rjmp	.+116    	; 0x39bc <WorkerRGB+0xd0>
		{
			FrontLeft=PL9823_YELLOW;
			RearLeft=PL9823_YELLOW;
    3948:	aa 24       	eor	r10, r10
    394a:	aa 94       	dec	r10
    394c:	bb 24       	eor	r11, r11
    394e:	ba 94       	dec	r11
    3950:	c1 2c       	mov	r12, r1
    3952:	d1 2c       	mov	r13, r1
		vTaskDelay(250); 
		
		//Time slot 2
		if (Effect & RGB_BLINK_LEFT)
		{
			FrontLeft=PL9823_YELLOW;
    3954:	6f ef       	ldi	r22, 0xFF	; 255
    3956:	7f ef       	ldi	r23, 0xFF	; 255
    3958:	80 e0       	ldi	r24, 0x00	; 0
    395a:	90 e0       	ldi	r25, 0x00	; 0
			RearLeft=PL9823_YELLOW;
		}
		if (Effect & RGB_BLINK_RIGHT)
    395c:	23 ff       	sbrs	r18, 3
    395e:	0c c0       	rjmp	.+24     	; 0x3978 <WorkerRGB+0x8c>
		{
			FrontRight=PL9823_YELLOW;
			RearRight=PL9823_YELLOW;
    3960:	22 24       	eor	r2, r2
    3962:	2a 94       	dec	r2
    3964:	33 24       	eor	r3, r3
    3966:	3a 94       	dec	r3
    3968:	41 2c       	mov	r4, r1
    396a:	51 2c       	mov	r5, r1
			FrontLeft=PL9823_YELLOW;
			RearLeft=PL9823_YELLOW;
		}
		if (Effect & RGB_BLINK_RIGHT)
		{
			FrontRight=PL9823_YELLOW;
    396c:	66 24       	eor	r6, r6
    396e:	6a 94       	dec	r6
    3970:	77 24       	eor	r7, r7
    3972:	7a 94       	dec	r7
    3974:	81 2c       	mov	r8, r1
    3976:	91 2c       	mov	r9, r1
			RearRight=PL9823_YELLOW;
		}
		DriverPL9823Set(FrontLeft,FrontRight,RearRight,RearLeft);
    3978:	71 01       	movw	r14, r2
    397a:	82 01       	movw	r16, r4
    397c:	93 01       	movw	r18, r6
    397e:	a4 01       	movw	r20, r8
    3980:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DriverPL9823Set>
		vTaskDelay(250);
    3984:	8a ef       	ldi	r24, 0xFA	; 250
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	0e 94 4d 17 	call	0x2e9a	; 0x2e9a <vTaskDelay>
	{
		FrontLeft=PL9823_BLANK;
		FrontRight=PL9823_BLANK;
		RearLeft=PL9823_BLANK;
		RearRight=PL9823_BLANK;	
		xQueuePeek(EffectQueue,&Effect,0);
    398c:	40 e0       	ldi	r20, 0x00	; 0
    398e:	50 e0       	ldi	r21, 0x00	; 0
    3990:	be 01       	movw	r22, r28
    3992:	6f 5f       	subi	r22, 0xFF	; 255
    3994:	7f 4f       	sbci	r23, 0xFF	; 255
    3996:	80 91 26 22 	lds	r24, 0x2226	; 0x802226 <EffectQueue>
    399a:	90 91 27 22 	lds	r25, 0x2227	; 0x802227 <EffectQueue+0x1>
    399e:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueuePeek>
		
		
		
		//Time slot 1
		if (Effect & RGB_HEADLIGHT_HIGH)
    39a2:	89 81       	ldd	r24, Y+1	; 0x01
    39a4:	81 fd       	sbrc	r24, 1
    39a6:	a8 cf       	rjmp	.-176    	; 0x38f8 <WorkerRGB+0xc>
	uint8_t Effect;
	uint32_t FrontLeft,FrontRight,RearRight,RearLeft;
	
	while(1)
	{
		FrontLeft=PL9823_BLANK;
    39a8:	61 2c       	mov	r6, r1
    39aa:	71 2c       	mov	r7, r1
    39ac:	81 2c       	mov	r8, r1
    39ae:	91 2c       	mov	r9, r1
    39b0:	aa cf       	rjmp	.-172    	; 0x3906 <WorkerRGB+0x1a>
		FrontRight=PL9823_BLANK;
		RearLeft=PL9823_BLANK;
		RearRight=PL9823_BLANK;	
    39b2:	21 2c       	mov	r2, r1
    39b4:	31 2c       	mov	r3, r1
    39b6:	41 2c       	mov	r4, r1
    39b8:	51 2c       	mov	r5, r1
    39ba:	b5 cf       	rjmp	.-150    	; 0x3926 <WorkerRGB+0x3a>
    39bc:	51 01       	movw	r10, r2
    39be:	62 01       	movw	r12, r4
    39c0:	b3 01       	movw	r22, r6
    39c2:	c4 01       	movw	r24, r8
    39c4:	cb cf       	rjmp	.-106    	; 0x395c <WorkerRGB+0x70>

000039c6 <InitRGBTask>:
void WorkerRGB(void *pvParameters);


//Function definitions
void InitRGBTask()
{
    39c6:	ef 92       	push	r14
    39c8:	ff 92       	push	r15
    39ca:	0f 93       	push	r16
    39cc:	cf 93       	push	r28
    39ce:	df 93       	push	r29
    39d0:	1f 92       	push	r1
    39d2:	cd b7       	in	r28, 0x3d	; 61
    39d4:	de b7       	in	r29, 0x3e	; 62
	EffectQueue=xQueueCreate(1,sizeof(uint8_t));
    39d6:	40 e0       	ldi	r20, 0x00	; 0
    39d8:	61 e0       	ldi	r22, 0x01	; 1
    39da:	81 e0       	ldi	r24, 0x01	; 1
    39dc:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xQueueGenericCreate>
    39e0:	80 93 26 22 	sts	0x2226, r24	; 0x802226 <EffectQueue>
    39e4:	90 93 27 22 	sts	0x2227, r25	; 0x802227 <EffectQueue+0x1>
    39e8:	19 82       	std	Y+1, r1	; 0x01
	xTaskCreate( WorkerRGB, "rgb", 512, NULL, tskIDLE_PRIORITY+4, NULL );	
}

void SetRGB(uint8_t Effect)
{
	xQueueOverwrite(EffectQueue,&Effect);
    39ea:	22 e0       	ldi	r18, 0x02	; 2
    39ec:	40 e0       	ldi	r20, 0x00	; 0
    39ee:	50 e0       	ldi	r21, 0x00	; 0
    39f0:	be 01       	movw	r22, r28
    39f2:	6f 5f       	subi	r22, 0xFF	; 255
    39f4:	7f 4f       	sbci	r23, 0xFF	; 255
    39f6:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <xQueueGenericSend>
//Function definitions
void InitRGBTask()
{
	EffectQueue=xQueueCreate(1,sizeof(uint8_t));
	SetRGB(RGB_NONE);
	xTaskCreate( WorkerRGB, "rgb", 512, NULL, tskIDLE_PRIORITY+4, NULL );	
    39fa:	e1 2c       	mov	r14, r1
    39fc:	f1 2c       	mov	r15, r1
    39fe:	04 e0       	ldi	r16, 0x04	; 4
    3a00:	20 e0       	ldi	r18, 0x00	; 0
    3a02:	30 e0       	ldi	r19, 0x00	; 0
    3a04:	40 e0       	ldi	r20, 0x00	; 0
    3a06:	52 e0       	ldi	r21, 0x02	; 2
    3a08:	61 ee       	ldi	r22, 0xE1	; 225
    3a0a:	70 e2       	ldi	r23, 0x20	; 32
    3a0c:	86 e7       	ldi	r24, 0x76	; 118
    3a0e:	9c e1       	ldi	r25, 0x1C	; 28
    3a10:	0e 94 44 13 	call	0x2688	; 0x2688 <xTaskCreate>
}
    3a14:	0f 90       	pop	r0
    3a16:	df 91       	pop	r29
    3a18:	cf 91       	pop	r28
    3a1a:	0f 91       	pop	r16
    3a1c:	ff 90       	pop	r15
    3a1e:	ef 90       	pop	r14
    3a20:	08 95       	ret

00003a22 <InitStartupTask>:
//Private function prototypes
static void WorkerStartup(void *pvParameters);

//Function definitions
void InitStartupTask()
{
    3a22:	ef 92       	push	r14
    3a24:	ff 92       	push	r15
    3a26:	0f 93       	push	r16
	xTaskCreate( WorkerStartup, "startup", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
    3a28:	e1 2c       	mov	r14, r1
    3a2a:	f1 2c       	mov	r15, r1
    3a2c:	03 e0       	ldi	r16, 0x03	; 3
    3a2e:	20 e0       	ldi	r18, 0x00	; 0
    3a30:	30 e0       	ldi	r19, 0x00	; 0
    3a32:	40 e0       	ldi	r20, 0x00	; 0
    3a34:	51 e0       	ldi	r21, 0x01	; 1
    3a36:	65 ee       	ldi	r22, 0xE5	; 229
    3a38:	70 e2       	ldi	r23, 0x20	; 32
    3a3a:	8c e7       	ldi	r24, 0x7C	; 124
    3a3c:	9d e1       	ldi	r25, 0x1D	; 29
    3a3e:	0e 94 44 13 	call	0x2688	; 0x2688 <xTaskCreate>
}
    3a42:	0f 91       	pop	r16
    3a44:	ff 90       	pop	r15
    3a46:	ef 90       	pop	r14
    3a48:	08 95       	ret

00003a4a <MotorSpeed>:

}

void MotorSpeed() {
	uint8_t Stick;
	int16_t Speed1=0,Speed2=0;
    3a4a:	e1 2c       	mov	r14, r1
    3a4c:	f1 2c       	mov	r15, r1
    3a4e:	00 e0       	ldi	r16, 0x00	; 0
    3a50:	10 e0       	ldi	r17, 0x00	; 0
    3a52:	0c c0       	rjmp	.+24     	; 0x3a6c <MotorSpeed+0x22>
			EnableMotorPosTask();
			EnableMotorSpeedTask();
			Speed1 = 1000;
			Speed2 = 1000;
		}
		if (Stick & CURSOR_DOWN) {
    3a54:	c2 fd       	sbrc	r28, 2
    3a56:	1d c0       	rjmp	.+58     	; 0x3a92 <MotorSpeed+0x48>
			EnableMotorPosTask();
			EnableMotorSpeedTask();
			Speed1 = -1000;
			Speed2 = -1000;
		}
		if (Stick & CURSOR_RIGHT) {
    3a58:	c1 fd       	sbrc	r28, 1
    3a5a:	27 c0       	rjmp	.+78     	; 0x3aaa <MotorSpeed+0x60>
			EnableMotorPosTask();
			EnableMotorSpeedTask();
			Speed1 = -1000;
			Speed2 = 1000;
		}
		if (Stick & CURSOR_LEFT) {
    3a5c:	c3 fd       	sbrc	r28, 3
    3a5e:	31 c0       	rjmp	.+98     	; 0x3ac2 <MotorSpeed+0x78>
			EnableMotorPosTask();
			EnableMotorSpeedTask();
			Speed1 = 1000;
			Speed2 = -1000;
		}
		if (Stick & CURSOR_PRESS) {
    3a60:	c0 fd       	sbrc	r28, 0
    3a62:	3b c0       	rjmp	.+118    	; 0x3ada <MotorSpeed+0x90>
			MotorSpeedSet(0,0);
			vTaskDelay(300);
			DisableMotorSpeedTask();
			DisableMotorPosTask();
		}
		MotorSpeedSet(Speed1,Speed2);
    3a64:	b7 01       	movw	r22, r14
    3a66:	c8 01       	movw	r24, r16
    3a68:	0e 94 66 1c 	call	0x38cc	; 0x38cc <MotorSpeedSet>
	uint8_t Stick;
	int16_t Speed1=0,Speed2=0;
	char s[32];
	
	while (1) {
		Stick=DriverCursorStickGetFifo(300);
    3a6c:	8c e2       	ldi	r24, 0x2C	; 44
    3a6e:	91 e0       	ldi	r25, 0x01	; 1
    3a70:	0e 94 19 02 	call	0x432	; 0x432 <DriverCursorStickGetFifo>
    3a74:	c8 2f       	mov	r28, r24
		
		if (Stick & CURSOR_UP) {
    3a76:	84 ff       	sbrs	r24, 4
    3a78:	ed cf       	rjmp	.-38     	; 0x3a54 <MotorSpeed+0xa>
			EnableMotorPosTask();
    3a7a:	0e 94 87 1b 	call	0x370e	; 0x370e <EnableMotorPosTask>
			EnableMotorSpeedTask();
    3a7e:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <EnableMotorSpeedTask>
			Speed1 = 1000;
			Speed2 = 1000;
    3a82:	38 ee       	ldi	r19, 0xE8	; 232
    3a84:	e3 2e       	mov	r14, r19
    3a86:	33 e0       	ldi	r19, 0x03	; 3
    3a88:	f3 2e       	mov	r15, r19
		Stick=DriverCursorStickGetFifo(300);
		
		if (Stick & CURSOR_UP) {
			EnableMotorPosTask();
			EnableMotorSpeedTask();
			Speed1 = 1000;
    3a8a:	08 ee       	ldi	r16, 0xE8	; 232
    3a8c:	13 e0       	ldi	r17, 0x03	; 3
			Speed2 = 1000;
		}
		if (Stick & CURSOR_DOWN) {
    3a8e:	c2 ff       	sbrs	r28, 2
    3a90:	e3 cf       	rjmp	.-58     	; 0x3a58 <MotorSpeed+0xe>
			EnableMotorPosTask();
    3a92:	0e 94 87 1b 	call	0x370e	; 0x370e <EnableMotorPosTask>
			EnableMotorSpeedTask();
    3a96:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <EnableMotorSpeedTask>
			Speed1 = -1000;
			Speed2 = -1000;
    3a9a:	28 e1       	ldi	r18, 0x18	; 24
    3a9c:	e2 2e       	mov	r14, r18
    3a9e:	2c ef       	ldi	r18, 0xFC	; 252
    3aa0:	f2 2e       	mov	r15, r18
			Speed2 = 1000;
		}
		if (Stick & CURSOR_DOWN) {
			EnableMotorPosTask();
			EnableMotorSpeedTask();
			Speed1 = -1000;
    3aa2:	08 e1       	ldi	r16, 0x18	; 24
    3aa4:	1c ef       	ldi	r17, 0xFC	; 252
			Speed2 = -1000;
		}
		if (Stick & CURSOR_RIGHT) {
    3aa6:	c1 ff       	sbrs	r28, 1
    3aa8:	d9 cf       	rjmp	.-78     	; 0x3a5c <MotorSpeed+0x12>
			EnableMotorPosTask();
    3aaa:	0e 94 87 1b 	call	0x370e	; 0x370e <EnableMotorPosTask>
			EnableMotorSpeedTask();
    3aae:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <EnableMotorSpeedTask>
			Speed1 = -1000;
			Speed2 = 1000;
    3ab2:	98 ee       	ldi	r25, 0xE8	; 232
    3ab4:	e9 2e       	mov	r14, r25
    3ab6:	93 e0       	ldi	r25, 0x03	; 3
    3ab8:	f9 2e       	mov	r15, r25
			Speed2 = -1000;
		}
		if (Stick & CURSOR_RIGHT) {
			EnableMotorPosTask();
			EnableMotorSpeedTask();
			Speed1 = -1000;
    3aba:	08 e1       	ldi	r16, 0x18	; 24
    3abc:	1c ef       	ldi	r17, 0xFC	; 252
			Speed2 = 1000;
		}
		if (Stick & CURSOR_LEFT) {
    3abe:	c3 ff       	sbrs	r28, 3
    3ac0:	cf cf       	rjmp	.-98     	; 0x3a60 <MotorSpeed+0x16>
			EnableMotorPosTask();
    3ac2:	0e 94 87 1b 	call	0x370e	; 0x370e <EnableMotorPosTask>
			EnableMotorSpeedTask();
    3ac6:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <EnableMotorSpeedTask>
			Speed1 = 1000;
			Speed2 = -1000;
    3aca:	88 e1       	ldi	r24, 0x18	; 24
    3acc:	e8 2e       	mov	r14, r24
    3ace:	8c ef       	ldi	r24, 0xFC	; 252
    3ad0:	f8 2e       	mov	r15, r24
			Speed2 = 1000;
		}
		if (Stick & CURSOR_LEFT) {
			EnableMotorPosTask();
			EnableMotorSpeedTask();
			Speed1 = 1000;
    3ad2:	08 ee       	ldi	r16, 0xE8	; 232
    3ad4:	13 e0       	ldi	r17, 0x03	; 3
			Speed2 = -1000;
		}
		if (Stick & CURSOR_PRESS) {
    3ad6:	c0 ff       	sbrs	r28, 0
    3ad8:	c5 cf       	rjmp	.-118    	; 0x3a64 <MotorSpeed+0x1a>
			MotorSpeedSet(0,0);
    3ada:	60 e0       	ldi	r22, 0x00	; 0
    3adc:	70 e0       	ldi	r23, 0x00	; 0
    3ade:	80 e0       	ldi	r24, 0x00	; 0
    3ae0:	90 e0       	ldi	r25, 0x00	; 0
    3ae2:	0e 94 66 1c 	call	0x38cc	; 0x38cc <MotorSpeedSet>
			vTaskDelay(300);
    3ae6:	8c e2       	ldi	r24, 0x2C	; 44
    3ae8:	91 e0       	ldi	r25, 0x01	; 1
    3aea:	0e 94 4d 17 	call	0x2e9a	; 0x2e9a <vTaskDelay>
			DisableMotorSpeedTask();
    3aee:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <DisableMotorSpeedTask>
			DisableMotorPosTask();
    3af2:	0e 94 a0 1b 	call	0x3740	; 0x3740 <DisableMotorPosTask>
    3af6:	b6 cf       	rjmp	.-148    	; 0x3a64 <MotorSpeed+0x1a>

00003af8 <WorkerStartup>:

static void WorkerStartup(void *pvParameters)
{
	int res;
	
	DriverPowerVccAuxSet(1);	//Enable Auxillary power line
    3af8:	81 e0       	ldi	r24, 0x01	; 1
    3afa:	0e 94 5e 07 	call	0xebc	; 0xebc <DriverPowerVccAuxSet>
	DriverCursorstickInit();	//Initialize cursor stick
    3afe:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <DriverCursorstickInit>
	//DriverLedInit();			//Initialize LED's
	//DriverUSARTInit();		//USART init and link to stdio
	DriverPowerInit();		//Initialize aux power driver
    3b02:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <DriverPowerInit>
	
	//DriverTWIMInit();			//Initialize TWI in master mode <-- oled
	DriverPL9823Init();		//Initialize PL9823 LEDs <--- Disable RGB leds
    3b06:	0e 94 bf 06 	call	0xd7e	; 0xd7e <DriverPL9823Init>
	
	//DriverOLEDInit(2);		//Initialize OLED display
	//DriverAdps9960Init();		//Initialize color sensor	
	//DriverVL53L0XInit();		//Initialize rangefinder

	DriverMotorInit();
    3b0a:	0e 94 57 03 	call	0x6ae	; 0x6ae <DriverMotorInit>
	
	vTaskDelay(50);
    3b0e:	82 e3       	ldi	r24, 0x32	; 50
    3b10:	90 e0       	ldi	r25, 0x00	; 0
    3b12:	0e 94 4d 17 	call	0x2e9a	; 0x2e9a <vTaskDelay>
	//PORTA.DIRSET=1<<5;	
	//Initialize application tasks			
	
	//InitOLEDMenuTask(); // <-- oled
	//InitADCTask();
	InitMotorPosTask();
    3b16:	0e 94 ac 1b 	call	0x3758	; 0x3758 <InitMotorPosTask>
	InitMotorSpeedTask();
    3b1a:	0e 94 24 1c 	call	0x3848	; 0x3848 <InitMotorSpeedTask>
	//InitLineFollowerSpeedTask();
	
	//InitLineFollowerDirectTask();
	InitRGBTask(); // <--- Disable RGB leds
    3b1e:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <InitRGBTask>
	//InitGyroTask();
	//InitTerminalTask();
	//InitMotionTask();
	
	MotorSpeed();
    3b22:	0e 94 25 1d 	call	0x3a4a	; 0x3a4a <MotorSpeed>

00003b26 <__subsf3>:
    3b26:	50 58       	subi	r21, 0x80	; 128

00003b28 <__addsf3>:
    3b28:	bb 27       	eor	r27, r27
    3b2a:	aa 27       	eor	r26, r26
    3b2c:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__addsf3x>
    3b30:	0c 94 25 1f 	jmp	0x3e4a	; 0x3e4a <__fp_round>
    3b34:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <__fp_pscA>
    3b38:	38 f0       	brcs	.+14     	; 0x3b48 <__addsf3+0x20>
    3b3a:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <__fp_pscB>
    3b3e:	20 f0       	brcs	.+8      	; 0x3b48 <__addsf3+0x20>
    3b40:	39 f4       	brne	.+14     	; 0x3b50 <__addsf3+0x28>
    3b42:	9f 3f       	cpi	r25, 0xFF	; 255
    3b44:	19 f4       	brne	.+6      	; 0x3b4c <__addsf3+0x24>
    3b46:	26 f4       	brtc	.+8      	; 0x3b50 <__addsf3+0x28>
    3b48:	0c 94 14 1f 	jmp	0x3e28	; 0x3e28 <__fp_nan>
    3b4c:	0e f4       	brtc	.+2      	; 0x3b50 <__addsf3+0x28>
    3b4e:	e0 95       	com	r30
    3b50:	e7 fb       	bst	r30, 7
    3b52:	0c 94 0e 1f 	jmp	0x3e1c	; 0x3e1c <__fp_inf>

00003b56 <__addsf3x>:
    3b56:	e9 2f       	mov	r30, r25
    3b58:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__fp_split3>
    3b5c:	58 f3       	brcs	.-42     	; 0x3b34 <__addsf3+0xc>
    3b5e:	ba 17       	cp	r27, r26
    3b60:	62 07       	cpc	r22, r18
    3b62:	73 07       	cpc	r23, r19
    3b64:	84 07       	cpc	r24, r20
    3b66:	95 07       	cpc	r25, r21
    3b68:	20 f0       	brcs	.+8      	; 0x3b72 <__addsf3x+0x1c>
    3b6a:	79 f4       	brne	.+30     	; 0x3b8a <__addsf3x+0x34>
    3b6c:	a6 f5       	brtc	.+104    	; 0x3bd6 <__addsf3x+0x80>
    3b6e:	0c 94 58 1f 	jmp	0x3eb0	; 0x3eb0 <__fp_zero>
    3b72:	0e f4       	brtc	.+2      	; 0x3b76 <__addsf3x+0x20>
    3b74:	e0 95       	com	r30
    3b76:	0b 2e       	mov	r0, r27
    3b78:	ba 2f       	mov	r27, r26
    3b7a:	a0 2d       	mov	r26, r0
    3b7c:	0b 01       	movw	r0, r22
    3b7e:	b9 01       	movw	r22, r18
    3b80:	90 01       	movw	r18, r0
    3b82:	0c 01       	movw	r0, r24
    3b84:	ca 01       	movw	r24, r20
    3b86:	a0 01       	movw	r20, r0
    3b88:	11 24       	eor	r1, r1
    3b8a:	ff 27       	eor	r31, r31
    3b8c:	59 1b       	sub	r21, r25
    3b8e:	99 f0       	breq	.+38     	; 0x3bb6 <__addsf3x+0x60>
    3b90:	59 3f       	cpi	r21, 0xF9	; 249
    3b92:	50 f4       	brcc	.+20     	; 0x3ba8 <__addsf3x+0x52>
    3b94:	50 3e       	cpi	r21, 0xE0	; 224
    3b96:	68 f1       	brcs	.+90     	; 0x3bf2 <__addsf3x+0x9c>
    3b98:	1a 16       	cp	r1, r26
    3b9a:	f0 40       	sbci	r31, 0x00	; 0
    3b9c:	a2 2f       	mov	r26, r18
    3b9e:	23 2f       	mov	r18, r19
    3ba0:	34 2f       	mov	r19, r20
    3ba2:	44 27       	eor	r20, r20
    3ba4:	58 5f       	subi	r21, 0xF8	; 248
    3ba6:	f3 cf       	rjmp	.-26     	; 0x3b8e <__addsf3x+0x38>
    3ba8:	46 95       	lsr	r20
    3baa:	37 95       	ror	r19
    3bac:	27 95       	ror	r18
    3bae:	a7 95       	ror	r26
    3bb0:	f0 40       	sbci	r31, 0x00	; 0
    3bb2:	53 95       	inc	r21
    3bb4:	c9 f7       	brne	.-14     	; 0x3ba8 <__addsf3x+0x52>
    3bb6:	7e f4       	brtc	.+30     	; 0x3bd6 <__addsf3x+0x80>
    3bb8:	1f 16       	cp	r1, r31
    3bba:	ba 0b       	sbc	r27, r26
    3bbc:	62 0b       	sbc	r22, r18
    3bbe:	73 0b       	sbc	r23, r19
    3bc0:	84 0b       	sbc	r24, r20
    3bc2:	ba f0       	brmi	.+46     	; 0x3bf2 <__addsf3x+0x9c>
    3bc4:	91 50       	subi	r25, 0x01	; 1
    3bc6:	a1 f0       	breq	.+40     	; 0x3bf0 <__addsf3x+0x9a>
    3bc8:	ff 0f       	add	r31, r31
    3bca:	bb 1f       	adc	r27, r27
    3bcc:	66 1f       	adc	r22, r22
    3bce:	77 1f       	adc	r23, r23
    3bd0:	88 1f       	adc	r24, r24
    3bd2:	c2 f7       	brpl	.-16     	; 0x3bc4 <__addsf3x+0x6e>
    3bd4:	0e c0       	rjmp	.+28     	; 0x3bf2 <__addsf3x+0x9c>
    3bd6:	ba 0f       	add	r27, r26
    3bd8:	62 1f       	adc	r22, r18
    3bda:	73 1f       	adc	r23, r19
    3bdc:	84 1f       	adc	r24, r20
    3bde:	48 f4       	brcc	.+18     	; 0x3bf2 <__addsf3x+0x9c>
    3be0:	87 95       	ror	r24
    3be2:	77 95       	ror	r23
    3be4:	67 95       	ror	r22
    3be6:	b7 95       	ror	r27
    3be8:	f7 95       	ror	r31
    3bea:	9e 3f       	cpi	r25, 0xFE	; 254
    3bec:	08 f0       	brcs	.+2      	; 0x3bf0 <__addsf3x+0x9a>
    3bee:	b0 cf       	rjmp	.-160    	; 0x3b50 <__addsf3+0x28>
    3bf0:	93 95       	inc	r25
    3bf2:	88 0f       	add	r24, r24
    3bf4:	08 f0       	brcs	.+2      	; 0x3bf8 <__addsf3x+0xa2>
    3bf6:	99 27       	eor	r25, r25
    3bf8:	ee 0f       	add	r30, r30
    3bfa:	97 95       	ror	r25
    3bfc:	87 95       	ror	r24
    3bfe:	08 95       	ret

00003c00 <__cmpsf2>:
    3c00:	0e 94 ea 1e 	call	0x3dd4	; 0x3dd4 <__fp_cmp>
    3c04:	08 f4       	brcc	.+2      	; 0x3c08 <__cmpsf2+0x8>
    3c06:	81 e0       	ldi	r24, 0x01	; 1
    3c08:	08 95       	ret

00003c0a <__divsf3>:
    3c0a:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <__divsf3x>
    3c0e:	0c 94 25 1f 	jmp	0x3e4a	; 0x3e4a <__fp_round>
    3c12:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <__fp_pscB>
    3c16:	58 f0       	brcs	.+22     	; 0x3c2e <__divsf3+0x24>
    3c18:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <__fp_pscA>
    3c1c:	40 f0       	brcs	.+16     	; 0x3c2e <__divsf3+0x24>
    3c1e:	29 f4       	brne	.+10     	; 0x3c2a <__divsf3+0x20>
    3c20:	5f 3f       	cpi	r21, 0xFF	; 255
    3c22:	29 f0       	breq	.+10     	; 0x3c2e <__divsf3+0x24>
    3c24:	0c 94 0e 1f 	jmp	0x3e1c	; 0x3e1c <__fp_inf>
    3c28:	51 11       	cpse	r21, r1
    3c2a:	0c 94 59 1f 	jmp	0x3eb2	; 0x3eb2 <__fp_szero>
    3c2e:	0c 94 14 1f 	jmp	0x3e28	; 0x3e28 <__fp_nan>

00003c32 <__divsf3x>:
    3c32:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__fp_split3>
    3c36:	68 f3       	brcs	.-38     	; 0x3c12 <__divsf3+0x8>

00003c38 <__divsf3_pse>:
    3c38:	99 23       	and	r25, r25
    3c3a:	b1 f3       	breq	.-20     	; 0x3c28 <__divsf3+0x1e>
    3c3c:	55 23       	and	r21, r21
    3c3e:	91 f3       	breq	.-28     	; 0x3c24 <__divsf3+0x1a>
    3c40:	95 1b       	sub	r25, r21
    3c42:	55 0b       	sbc	r21, r21
    3c44:	bb 27       	eor	r27, r27
    3c46:	aa 27       	eor	r26, r26
    3c48:	62 17       	cp	r22, r18
    3c4a:	73 07       	cpc	r23, r19
    3c4c:	84 07       	cpc	r24, r20
    3c4e:	38 f0       	brcs	.+14     	; 0x3c5e <__divsf3_pse+0x26>
    3c50:	9f 5f       	subi	r25, 0xFF	; 255
    3c52:	5f 4f       	sbci	r21, 0xFF	; 255
    3c54:	22 0f       	add	r18, r18
    3c56:	33 1f       	adc	r19, r19
    3c58:	44 1f       	adc	r20, r20
    3c5a:	aa 1f       	adc	r26, r26
    3c5c:	a9 f3       	breq	.-22     	; 0x3c48 <__divsf3_pse+0x10>
    3c5e:	35 d0       	rcall	.+106    	; 0x3cca <__divsf3_pse+0x92>
    3c60:	0e 2e       	mov	r0, r30
    3c62:	3a f0       	brmi	.+14     	; 0x3c72 <__divsf3_pse+0x3a>
    3c64:	e0 e8       	ldi	r30, 0x80	; 128
    3c66:	32 d0       	rcall	.+100    	; 0x3ccc <__divsf3_pse+0x94>
    3c68:	91 50       	subi	r25, 0x01	; 1
    3c6a:	50 40       	sbci	r21, 0x00	; 0
    3c6c:	e6 95       	lsr	r30
    3c6e:	00 1c       	adc	r0, r0
    3c70:	ca f7       	brpl	.-14     	; 0x3c64 <__divsf3_pse+0x2c>
    3c72:	2b d0       	rcall	.+86     	; 0x3cca <__divsf3_pse+0x92>
    3c74:	fe 2f       	mov	r31, r30
    3c76:	29 d0       	rcall	.+82     	; 0x3cca <__divsf3_pse+0x92>
    3c78:	66 0f       	add	r22, r22
    3c7a:	77 1f       	adc	r23, r23
    3c7c:	88 1f       	adc	r24, r24
    3c7e:	bb 1f       	adc	r27, r27
    3c80:	26 17       	cp	r18, r22
    3c82:	37 07       	cpc	r19, r23
    3c84:	48 07       	cpc	r20, r24
    3c86:	ab 07       	cpc	r26, r27
    3c88:	b0 e8       	ldi	r27, 0x80	; 128
    3c8a:	09 f0       	breq	.+2      	; 0x3c8e <__divsf3_pse+0x56>
    3c8c:	bb 0b       	sbc	r27, r27
    3c8e:	80 2d       	mov	r24, r0
    3c90:	bf 01       	movw	r22, r30
    3c92:	ff 27       	eor	r31, r31
    3c94:	93 58       	subi	r25, 0x83	; 131
    3c96:	5f 4f       	sbci	r21, 0xFF	; 255
    3c98:	3a f0       	brmi	.+14     	; 0x3ca8 <__divsf3_pse+0x70>
    3c9a:	9e 3f       	cpi	r25, 0xFE	; 254
    3c9c:	51 05       	cpc	r21, r1
    3c9e:	78 f0       	brcs	.+30     	; 0x3cbe <__divsf3_pse+0x86>
    3ca0:	0c 94 0e 1f 	jmp	0x3e1c	; 0x3e1c <__fp_inf>
    3ca4:	0c 94 59 1f 	jmp	0x3eb2	; 0x3eb2 <__fp_szero>
    3ca8:	5f 3f       	cpi	r21, 0xFF	; 255
    3caa:	e4 f3       	brlt	.-8      	; 0x3ca4 <__divsf3_pse+0x6c>
    3cac:	98 3e       	cpi	r25, 0xE8	; 232
    3cae:	d4 f3       	brlt	.-12     	; 0x3ca4 <__divsf3_pse+0x6c>
    3cb0:	86 95       	lsr	r24
    3cb2:	77 95       	ror	r23
    3cb4:	67 95       	ror	r22
    3cb6:	b7 95       	ror	r27
    3cb8:	f7 95       	ror	r31
    3cba:	9f 5f       	subi	r25, 0xFF	; 255
    3cbc:	c9 f7       	brne	.-14     	; 0x3cb0 <__divsf3_pse+0x78>
    3cbe:	88 0f       	add	r24, r24
    3cc0:	91 1d       	adc	r25, r1
    3cc2:	96 95       	lsr	r25
    3cc4:	87 95       	ror	r24
    3cc6:	97 f9       	bld	r25, 7
    3cc8:	08 95       	ret
    3cca:	e1 e0       	ldi	r30, 0x01	; 1
    3ccc:	66 0f       	add	r22, r22
    3cce:	77 1f       	adc	r23, r23
    3cd0:	88 1f       	adc	r24, r24
    3cd2:	bb 1f       	adc	r27, r27
    3cd4:	62 17       	cp	r22, r18
    3cd6:	73 07       	cpc	r23, r19
    3cd8:	84 07       	cpc	r24, r20
    3cda:	ba 07       	cpc	r27, r26
    3cdc:	20 f0       	brcs	.+8      	; 0x3ce6 <__divsf3_pse+0xae>
    3cde:	62 1b       	sub	r22, r18
    3ce0:	73 0b       	sbc	r23, r19
    3ce2:	84 0b       	sbc	r24, r20
    3ce4:	ba 0b       	sbc	r27, r26
    3ce6:	ee 1f       	adc	r30, r30
    3ce8:	88 f7       	brcc	.-30     	; 0x3ccc <__divsf3_pse+0x94>
    3cea:	e0 95       	com	r30
    3cec:	08 95       	ret

00003cee <__fixsfsi>:
    3cee:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <__fixunssfsi>
    3cf2:	68 94       	set
    3cf4:	b1 11       	cpse	r27, r1
    3cf6:	0c 94 59 1f 	jmp	0x3eb2	; 0x3eb2 <__fp_szero>
    3cfa:	08 95       	ret

00003cfc <__fixunssfsi>:
    3cfc:	0e 94 3e 1f 	call	0x3e7c	; 0x3e7c <__fp_splitA>
    3d00:	88 f0       	brcs	.+34     	; 0x3d24 <__fixunssfsi+0x28>
    3d02:	9f 57       	subi	r25, 0x7F	; 127
    3d04:	98 f0       	brcs	.+38     	; 0x3d2c <__fixunssfsi+0x30>
    3d06:	b9 2f       	mov	r27, r25
    3d08:	99 27       	eor	r25, r25
    3d0a:	b7 51       	subi	r27, 0x17	; 23
    3d0c:	b0 f0       	brcs	.+44     	; 0x3d3a <__fixunssfsi+0x3e>
    3d0e:	e1 f0       	breq	.+56     	; 0x3d48 <__fixunssfsi+0x4c>
    3d10:	66 0f       	add	r22, r22
    3d12:	77 1f       	adc	r23, r23
    3d14:	88 1f       	adc	r24, r24
    3d16:	99 1f       	adc	r25, r25
    3d18:	1a f0       	brmi	.+6      	; 0x3d20 <__fixunssfsi+0x24>
    3d1a:	ba 95       	dec	r27
    3d1c:	c9 f7       	brne	.-14     	; 0x3d10 <__fixunssfsi+0x14>
    3d1e:	14 c0       	rjmp	.+40     	; 0x3d48 <__fixunssfsi+0x4c>
    3d20:	b1 30       	cpi	r27, 0x01	; 1
    3d22:	91 f0       	breq	.+36     	; 0x3d48 <__fixunssfsi+0x4c>
    3d24:	0e 94 58 1f 	call	0x3eb0	; 0x3eb0 <__fp_zero>
    3d28:	b1 e0       	ldi	r27, 0x01	; 1
    3d2a:	08 95       	ret
    3d2c:	0c 94 58 1f 	jmp	0x3eb0	; 0x3eb0 <__fp_zero>
    3d30:	67 2f       	mov	r22, r23
    3d32:	78 2f       	mov	r23, r24
    3d34:	88 27       	eor	r24, r24
    3d36:	b8 5f       	subi	r27, 0xF8	; 248
    3d38:	39 f0       	breq	.+14     	; 0x3d48 <__fixunssfsi+0x4c>
    3d3a:	b9 3f       	cpi	r27, 0xF9	; 249
    3d3c:	cc f3       	brlt	.-14     	; 0x3d30 <__fixunssfsi+0x34>
    3d3e:	86 95       	lsr	r24
    3d40:	77 95       	ror	r23
    3d42:	67 95       	ror	r22
    3d44:	b3 95       	inc	r27
    3d46:	d9 f7       	brne	.-10     	; 0x3d3e <__fixunssfsi+0x42>
    3d48:	3e f4       	brtc	.+14     	; 0x3d58 <__fixunssfsi+0x5c>
    3d4a:	90 95       	com	r25
    3d4c:	80 95       	com	r24
    3d4e:	70 95       	com	r23
    3d50:	61 95       	neg	r22
    3d52:	7f 4f       	sbci	r23, 0xFF	; 255
    3d54:	8f 4f       	sbci	r24, 0xFF	; 255
    3d56:	9f 4f       	sbci	r25, 0xFF	; 255
    3d58:	08 95       	ret

00003d5a <__floatunsisf>:
    3d5a:	e8 94       	clt
    3d5c:	09 c0       	rjmp	.+18     	; 0x3d70 <__floatsisf+0x12>

00003d5e <__floatsisf>:
    3d5e:	97 fb       	bst	r25, 7
    3d60:	3e f4       	brtc	.+14     	; 0x3d70 <__floatsisf+0x12>
    3d62:	90 95       	com	r25
    3d64:	80 95       	com	r24
    3d66:	70 95       	com	r23
    3d68:	61 95       	neg	r22
    3d6a:	7f 4f       	sbci	r23, 0xFF	; 255
    3d6c:	8f 4f       	sbci	r24, 0xFF	; 255
    3d6e:	9f 4f       	sbci	r25, 0xFF	; 255
    3d70:	99 23       	and	r25, r25
    3d72:	a9 f0       	breq	.+42     	; 0x3d9e <__floatsisf+0x40>
    3d74:	f9 2f       	mov	r31, r25
    3d76:	96 e9       	ldi	r25, 0x96	; 150
    3d78:	bb 27       	eor	r27, r27
    3d7a:	93 95       	inc	r25
    3d7c:	f6 95       	lsr	r31
    3d7e:	87 95       	ror	r24
    3d80:	77 95       	ror	r23
    3d82:	67 95       	ror	r22
    3d84:	b7 95       	ror	r27
    3d86:	f1 11       	cpse	r31, r1
    3d88:	f8 cf       	rjmp	.-16     	; 0x3d7a <__floatsisf+0x1c>
    3d8a:	fa f4       	brpl	.+62     	; 0x3dca <__floatsisf+0x6c>
    3d8c:	bb 0f       	add	r27, r27
    3d8e:	11 f4       	brne	.+4      	; 0x3d94 <__floatsisf+0x36>
    3d90:	60 ff       	sbrs	r22, 0
    3d92:	1b c0       	rjmp	.+54     	; 0x3dca <__floatsisf+0x6c>
    3d94:	6f 5f       	subi	r22, 0xFF	; 255
    3d96:	7f 4f       	sbci	r23, 0xFF	; 255
    3d98:	8f 4f       	sbci	r24, 0xFF	; 255
    3d9a:	9f 4f       	sbci	r25, 0xFF	; 255
    3d9c:	16 c0       	rjmp	.+44     	; 0x3dca <__floatsisf+0x6c>
    3d9e:	88 23       	and	r24, r24
    3da0:	11 f0       	breq	.+4      	; 0x3da6 <__floatsisf+0x48>
    3da2:	96 e9       	ldi	r25, 0x96	; 150
    3da4:	11 c0       	rjmp	.+34     	; 0x3dc8 <__floatsisf+0x6a>
    3da6:	77 23       	and	r23, r23
    3da8:	21 f0       	breq	.+8      	; 0x3db2 <__floatsisf+0x54>
    3daa:	9e e8       	ldi	r25, 0x8E	; 142
    3dac:	87 2f       	mov	r24, r23
    3dae:	76 2f       	mov	r23, r22
    3db0:	05 c0       	rjmp	.+10     	; 0x3dbc <__floatsisf+0x5e>
    3db2:	66 23       	and	r22, r22
    3db4:	71 f0       	breq	.+28     	; 0x3dd2 <__floatsisf+0x74>
    3db6:	96 e8       	ldi	r25, 0x86	; 134
    3db8:	86 2f       	mov	r24, r22
    3dba:	70 e0       	ldi	r23, 0x00	; 0
    3dbc:	60 e0       	ldi	r22, 0x00	; 0
    3dbe:	2a f0       	brmi	.+10     	; 0x3dca <__floatsisf+0x6c>
    3dc0:	9a 95       	dec	r25
    3dc2:	66 0f       	add	r22, r22
    3dc4:	77 1f       	adc	r23, r23
    3dc6:	88 1f       	adc	r24, r24
    3dc8:	da f7       	brpl	.-10     	; 0x3dc0 <__floatsisf+0x62>
    3dca:	88 0f       	add	r24, r24
    3dcc:	96 95       	lsr	r25
    3dce:	87 95       	ror	r24
    3dd0:	97 f9       	bld	r25, 7
    3dd2:	08 95       	ret

00003dd4 <__fp_cmp>:
    3dd4:	99 0f       	add	r25, r25
    3dd6:	00 08       	sbc	r0, r0
    3dd8:	55 0f       	add	r21, r21
    3dda:	aa 0b       	sbc	r26, r26
    3ddc:	e0 e8       	ldi	r30, 0x80	; 128
    3dde:	fe ef       	ldi	r31, 0xFE	; 254
    3de0:	16 16       	cp	r1, r22
    3de2:	17 06       	cpc	r1, r23
    3de4:	e8 07       	cpc	r30, r24
    3de6:	f9 07       	cpc	r31, r25
    3de8:	c0 f0       	brcs	.+48     	; 0x3e1a <__fp_cmp+0x46>
    3dea:	12 16       	cp	r1, r18
    3dec:	13 06       	cpc	r1, r19
    3dee:	e4 07       	cpc	r30, r20
    3df0:	f5 07       	cpc	r31, r21
    3df2:	98 f0       	brcs	.+38     	; 0x3e1a <__fp_cmp+0x46>
    3df4:	62 1b       	sub	r22, r18
    3df6:	73 0b       	sbc	r23, r19
    3df8:	84 0b       	sbc	r24, r20
    3dfa:	95 0b       	sbc	r25, r21
    3dfc:	39 f4       	brne	.+14     	; 0x3e0c <__fp_cmp+0x38>
    3dfe:	0a 26       	eor	r0, r26
    3e00:	61 f0       	breq	.+24     	; 0x3e1a <__fp_cmp+0x46>
    3e02:	23 2b       	or	r18, r19
    3e04:	24 2b       	or	r18, r20
    3e06:	25 2b       	or	r18, r21
    3e08:	21 f4       	brne	.+8      	; 0x3e12 <__fp_cmp+0x3e>
    3e0a:	08 95       	ret
    3e0c:	0a 26       	eor	r0, r26
    3e0e:	09 f4       	brne	.+2      	; 0x3e12 <__fp_cmp+0x3e>
    3e10:	a1 40       	sbci	r26, 0x01	; 1
    3e12:	a6 95       	lsr	r26
    3e14:	8f ef       	ldi	r24, 0xFF	; 255
    3e16:	81 1d       	adc	r24, r1
    3e18:	81 1d       	adc	r24, r1
    3e1a:	08 95       	ret

00003e1c <__fp_inf>:
    3e1c:	97 f9       	bld	r25, 7
    3e1e:	9f 67       	ori	r25, 0x7F	; 127
    3e20:	80 e8       	ldi	r24, 0x80	; 128
    3e22:	70 e0       	ldi	r23, 0x00	; 0
    3e24:	60 e0       	ldi	r22, 0x00	; 0
    3e26:	08 95       	ret

00003e28 <__fp_nan>:
    3e28:	9f ef       	ldi	r25, 0xFF	; 255
    3e2a:	80 ec       	ldi	r24, 0xC0	; 192
    3e2c:	08 95       	ret

00003e2e <__fp_pscA>:
    3e2e:	00 24       	eor	r0, r0
    3e30:	0a 94       	dec	r0
    3e32:	16 16       	cp	r1, r22
    3e34:	17 06       	cpc	r1, r23
    3e36:	18 06       	cpc	r1, r24
    3e38:	09 06       	cpc	r0, r25
    3e3a:	08 95       	ret

00003e3c <__fp_pscB>:
    3e3c:	00 24       	eor	r0, r0
    3e3e:	0a 94       	dec	r0
    3e40:	12 16       	cp	r1, r18
    3e42:	13 06       	cpc	r1, r19
    3e44:	14 06       	cpc	r1, r20
    3e46:	05 06       	cpc	r0, r21
    3e48:	08 95       	ret

00003e4a <__fp_round>:
    3e4a:	09 2e       	mov	r0, r25
    3e4c:	03 94       	inc	r0
    3e4e:	00 0c       	add	r0, r0
    3e50:	11 f4       	brne	.+4      	; 0x3e56 <__fp_round+0xc>
    3e52:	88 23       	and	r24, r24
    3e54:	52 f0       	brmi	.+20     	; 0x3e6a <__fp_round+0x20>
    3e56:	bb 0f       	add	r27, r27
    3e58:	40 f4       	brcc	.+16     	; 0x3e6a <__fp_round+0x20>
    3e5a:	bf 2b       	or	r27, r31
    3e5c:	11 f4       	brne	.+4      	; 0x3e62 <__fp_round+0x18>
    3e5e:	60 ff       	sbrs	r22, 0
    3e60:	04 c0       	rjmp	.+8      	; 0x3e6a <__fp_round+0x20>
    3e62:	6f 5f       	subi	r22, 0xFF	; 255
    3e64:	7f 4f       	sbci	r23, 0xFF	; 255
    3e66:	8f 4f       	sbci	r24, 0xFF	; 255
    3e68:	9f 4f       	sbci	r25, 0xFF	; 255
    3e6a:	08 95       	ret

00003e6c <__fp_split3>:
    3e6c:	57 fd       	sbrc	r21, 7
    3e6e:	90 58       	subi	r25, 0x80	; 128
    3e70:	44 0f       	add	r20, r20
    3e72:	55 1f       	adc	r21, r21
    3e74:	59 f0       	breq	.+22     	; 0x3e8c <__fp_splitA+0x10>
    3e76:	5f 3f       	cpi	r21, 0xFF	; 255
    3e78:	71 f0       	breq	.+28     	; 0x3e96 <__fp_splitA+0x1a>
    3e7a:	47 95       	ror	r20

00003e7c <__fp_splitA>:
    3e7c:	88 0f       	add	r24, r24
    3e7e:	97 fb       	bst	r25, 7
    3e80:	99 1f       	adc	r25, r25
    3e82:	61 f0       	breq	.+24     	; 0x3e9c <__fp_splitA+0x20>
    3e84:	9f 3f       	cpi	r25, 0xFF	; 255
    3e86:	79 f0       	breq	.+30     	; 0x3ea6 <__fp_splitA+0x2a>
    3e88:	87 95       	ror	r24
    3e8a:	08 95       	ret
    3e8c:	12 16       	cp	r1, r18
    3e8e:	13 06       	cpc	r1, r19
    3e90:	14 06       	cpc	r1, r20
    3e92:	55 1f       	adc	r21, r21
    3e94:	f2 cf       	rjmp	.-28     	; 0x3e7a <__fp_split3+0xe>
    3e96:	46 95       	lsr	r20
    3e98:	f1 df       	rcall	.-30     	; 0x3e7c <__fp_splitA>
    3e9a:	08 c0       	rjmp	.+16     	; 0x3eac <__fp_splitA+0x30>
    3e9c:	16 16       	cp	r1, r22
    3e9e:	17 06       	cpc	r1, r23
    3ea0:	18 06       	cpc	r1, r24
    3ea2:	99 1f       	adc	r25, r25
    3ea4:	f1 cf       	rjmp	.-30     	; 0x3e88 <__fp_splitA+0xc>
    3ea6:	86 95       	lsr	r24
    3ea8:	71 05       	cpc	r23, r1
    3eaa:	61 05       	cpc	r22, r1
    3eac:	08 94       	sec
    3eae:	08 95       	ret

00003eb0 <__fp_zero>:
    3eb0:	e8 94       	clt

00003eb2 <__fp_szero>:
    3eb2:	bb 27       	eor	r27, r27
    3eb4:	66 27       	eor	r22, r22
    3eb6:	77 27       	eor	r23, r23
    3eb8:	cb 01       	movw	r24, r22
    3eba:	97 f9       	bld	r25, 7
    3ebc:	08 95       	ret

00003ebe <__gesf2>:
    3ebe:	0e 94 ea 1e 	call	0x3dd4	; 0x3dd4 <__fp_cmp>
    3ec2:	08 f4       	brcc	.+2      	; 0x3ec6 <__gesf2+0x8>
    3ec4:	8f ef       	ldi	r24, 0xFF	; 255
    3ec6:	08 95       	ret

00003ec8 <__mulsf3>:
    3ec8:	0e 94 77 1f 	call	0x3eee	; 0x3eee <__mulsf3x>
    3ecc:	0c 94 25 1f 	jmp	0x3e4a	; 0x3e4a <__fp_round>
    3ed0:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <__fp_pscA>
    3ed4:	38 f0       	brcs	.+14     	; 0x3ee4 <__mulsf3+0x1c>
    3ed6:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <__fp_pscB>
    3eda:	20 f0       	brcs	.+8      	; 0x3ee4 <__mulsf3+0x1c>
    3edc:	95 23       	and	r25, r21
    3ede:	11 f0       	breq	.+4      	; 0x3ee4 <__mulsf3+0x1c>
    3ee0:	0c 94 0e 1f 	jmp	0x3e1c	; 0x3e1c <__fp_inf>
    3ee4:	0c 94 14 1f 	jmp	0x3e28	; 0x3e28 <__fp_nan>
    3ee8:	11 24       	eor	r1, r1
    3eea:	0c 94 59 1f 	jmp	0x3eb2	; 0x3eb2 <__fp_szero>

00003eee <__mulsf3x>:
    3eee:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__fp_split3>
    3ef2:	70 f3       	brcs	.-36     	; 0x3ed0 <__mulsf3+0x8>

00003ef4 <__mulsf3_pse>:
    3ef4:	95 9f       	mul	r25, r21
    3ef6:	c1 f3       	breq	.-16     	; 0x3ee8 <__mulsf3+0x20>
    3ef8:	95 0f       	add	r25, r21
    3efa:	50 e0       	ldi	r21, 0x00	; 0
    3efc:	55 1f       	adc	r21, r21
    3efe:	62 9f       	mul	r22, r18
    3f00:	f0 01       	movw	r30, r0
    3f02:	72 9f       	mul	r23, r18
    3f04:	bb 27       	eor	r27, r27
    3f06:	f0 0d       	add	r31, r0
    3f08:	b1 1d       	adc	r27, r1
    3f0a:	63 9f       	mul	r22, r19
    3f0c:	aa 27       	eor	r26, r26
    3f0e:	f0 0d       	add	r31, r0
    3f10:	b1 1d       	adc	r27, r1
    3f12:	aa 1f       	adc	r26, r26
    3f14:	64 9f       	mul	r22, r20
    3f16:	66 27       	eor	r22, r22
    3f18:	b0 0d       	add	r27, r0
    3f1a:	a1 1d       	adc	r26, r1
    3f1c:	66 1f       	adc	r22, r22
    3f1e:	82 9f       	mul	r24, r18
    3f20:	22 27       	eor	r18, r18
    3f22:	b0 0d       	add	r27, r0
    3f24:	a1 1d       	adc	r26, r1
    3f26:	62 1f       	adc	r22, r18
    3f28:	73 9f       	mul	r23, r19
    3f2a:	b0 0d       	add	r27, r0
    3f2c:	a1 1d       	adc	r26, r1
    3f2e:	62 1f       	adc	r22, r18
    3f30:	83 9f       	mul	r24, r19
    3f32:	a0 0d       	add	r26, r0
    3f34:	61 1d       	adc	r22, r1
    3f36:	22 1f       	adc	r18, r18
    3f38:	74 9f       	mul	r23, r20
    3f3a:	33 27       	eor	r19, r19
    3f3c:	a0 0d       	add	r26, r0
    3f3e:	61 1d       	adc	r22, r1
    3f40:	23 1f       	adc	r18, r19
    3f42:	84 9f       	mul	r24, r20
    3f44:	60 0d       	add	r22, r0
    3f46:	21 1d       	adc	r18, r1
    3f48:	82 2f       	mov	r24, r18
    3f4a:	76 2f       	mov	r23, r22
    3f4c:	6a 2f       	mov	r22, r26
    3f4e:	11 24       	eor	r1, r1
    3f50:	9f 57       	subi	r25, 0x7F	; 127
    3f52:	50 40       	sbci	r21, 0x00	; 0
    3f54:	9a f0       	brmi	.+38     	; 0x3f7c <__mulsf3_pse+0x88>
    3f56:	f1 f0       	breq	.+60     	; 0x3f94 <__mulsf3_pse+0xa0>
    3f58:	88 23       	and	r24, r24
    3f5a:	4a f0       	brmi	.+18     	; 0x3f6e <__mulsf3_pse+0x7a>
    3f5c:	ee 0f       	add	r30, r30
    3f5e:	ff 1f       	adc	r31, r31
    3f60:	bb 1f       	adc	r27, r27
    3f62:	66 1f       	adc	r22, r22
    3f64:	77 1f       	adc	r23, r23
    3f66:	88 1f       	adc	r24, r24
    3f68:	91 50       	subi	r25, 0x01	; 1
    3f6a:	50 40       	sbci	r21, 0x00	; 0
    3f6c:	a9 f7       	brne	.-22     	; 0x3f58 <__mulsf3_pse+0x64>
    3f6e:	9e 3f       	cpi	r25, 0xFE	; 254
    3f70:	51 05       	cpc	r21, r1
    3f72:	80 f0       	brcs	.+32     	; 0x3f94 <__mulsf3_pse+0xa0>
    3f74:	0c 94 0e 1f 	jmp	0x3e1c	; 0x3e1c <__fp_inf>
    3f78:	0c 94 59 1f 	jmp	0x3eb2	; 0x3eb2 <__fp_szero>
    3f7c:	5f 3f       	cpi	r21, 0xFF	; 255
    3f7e:	e4 f3       	brlt	.-8      	; 0x3f78 <__mulsf3_pse+0x84>
    3f80:	98 3e       	cpi	r25, 0xE8	; 232
    3f82:	d4 f3       	brlt	.-12     	; 0x3f78 <__mulsf3_pse+0x84>
    3f84:	86 95       	lsr	r24
    3f86:	77 95       	ror	r23
    3f88:	67 95       	ror	r22
    3f8a:	b7 95       	ror	r27
    3f8c:	f7 95       	ror	r31
    3f8e:	e7 95       	ror	r30
    3f90:	9f 5f       	subi	r25, 0xFF	; 255
    3f92:	c1 f7       	brne	.-16     	; 0x3f84 <__mulsf3_pse+0x90>
    3f94:	fe 2b       	or	r31, r30
    3f96:	88 0f       	add	r24, r24
    3f98:	91 1d       	adc	r25, r1
    3f9a:	96 95       	lsr	r25
    3f9c:	87 95       	ror	r24
    3f9e:	97 f9       	bld	r25, 7
    3fa0:	08 95       	ret

00003fa2 <vfprintf>:
    3fa2:	2f 92       	push	r2
    3fa4:	3f 92       	push	r3
    3fa6:	4f 92       	push	r4
    3fa8:	5f 92       	push	r5
    3faa:	6f 92       	push	r6
    3fac:	7f 92       	push	r7
    3fae:	8f 92       	push	r8
    3fb0:	9f 92       	push	r9
    3fb2:	af 92       	push	r10
    3fb4:	bf 92       	push	r11
    3fb6:	cf 92       	push	r12
    3fb8:	df 92       	push	r13
    3fba:	ef 92       	push	r14
    3fbc:	ff 92       	push	r15
    3fbe:	0f 93       	push	r16
    3fc0:	1f 93       	push	r17
    3fc2:	cf 93       	push	r28
    3fc4:	df 93       	push	r29
    3fc6:	cd b7       	in	r28, 0x3d	; 61
    3fc8:	de b7       	in	r29, 0x3e	; 62
    3fca:	60 97       	sbiw	r28, 0x10	; 16
    3fcc:	cd bf       	out	0x3d, r28	; 61
    3fce:	de bf       	out	0x3e, r29	; 62
    3fd0:	7c 01       	movw	r14, r24
    3fd2:	1b 01       	movw	r2, r22
    3fd4:	6a 01       	movw	r12, r20
    3fd6:	fc 01       	movw	r30, r24
    3fd8:	16 82       	std	Z+6, r1	; 0x06
    3fda:	17 82       	std	Z+7, r1	; 0x07
    3fdc:	83 81       	ldd	r24, Z+3	; 0x03
    3fde:	81 ff       	sbrs	r24, 1
    3fe0:	44 c3       	rjmp	.+1672   	; 0x466a <vfprintf+0x6c8>
    3fe2:	9e 01       	movw	r18, r28
    3fe4:	2f 5f       	subi	r18, 0xFF	; 255
    3fe6:	3f 4f       	sbci	r19, 0xFF	; 255
    3fe8:	39 01       	movw	r6, r18
    3fea:	f7 01       	movw	r30, r14
    3fec:	93 81       	ldd	r25, Z+3	; 0x03
    3fee:	f1 01       	movw	r30, r2
    3ff0:	93 fd       	sbrc	r25, 3
    3ff2:	85 91       	lpm	r24, Z+
    3ff4:	93 ff       	sbrs	r25, 3
    3ff6:	81 91       	ld	r24, Z+
    3ff8:	1f 01       	movw	r2, r30
    3ffa:	88 23       	and	r24, r24
    3ffc:	09 f4       	brne	.+2      	; 0x4000 <vfprintf+0x5e>
    3ffe:	31 c3       	rjmp	.+1634   	; 0x4662 <vfprintf+0x6c0>
    4000:	85 32       	cpi	r24, 0x25	; 37
    4002:	39 f4       	brne	.+14     	; 0x4012 <vfprintf+0x70>
    4004:	93 fd       	sbrc	r25, 3
    4006:	85 91       	lpm	r24, Z+
    4008:	93 ff       	sbrs	r25, 3
    400a:	81 91       	ld	r24, Z+
    400c:	1f 01       	movw	r2, r30
    400e:	85 32       	cpi	r24, 0x25	; 37
    4010:	39 f4       	brne	.+14     	; 0x4020 <vfprintf+0x7e>
    4012:	b7 01       	movw	r22, r14
    4014:	90 e0       	ldi	r25, 0x00	; 0
    4016:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    401a:	56 01       	movw	r10, r12
    401c:	65 01       	movw	r12, r10
    401e:	e5 cf       	rjmp	.-54     	; 0x3fea <vfprintf+0x48>
    4020:	10 e0       	ldi	r17, 0x00	; 0
    4022:	51 2c       	mov	r5, r1
    4024:	91 2c       	mov	r9, r1
    4026:	ff e1       	ldi	r31, 0x1F	; 31
    4028:	f9 15       	cp	r31, r9
    402a:	d8 f0       	brcs	.+54     	; 0x4062 <vfprintf+0xc0>
    402c:	8b 32       	cpi	r24, 0x2B	; 43
    402e:	79 f0       	breq	.+30     	; 0x404e <vfprintf+0xac>
    4030:	38 f4       	brcc	.+14     	; 0x4040 <vfprintf+0x9e>
    4032:	80 32       	cpi	r24, 0x20	; 32
    4034:	79 f0       	breq	.+30     	; 0x4054 <vfprintf+0xb2>
    4036:	83 32       	cpi	r24, 0x23	; 35
    4038:	a1 f4       	brne	.+40     	; 0x4062 <vfprintf+0xc0>
    403a:	f9 2d       	mov	r31, r9
    403c:	f0 61       	ori	r31, 0x10	; 16
    403e:	2e c0       	rjmp	.+92     	; 0x409c <vfprintf+0xfa>
    4040:	8d 32       	cpi	r24, 0x2D	; 45
    4042:	61 f0       	breq	.+24     	; 0x405c <vfprintf+0xba>
    4044:	80 33       	cpi	r24, 0x30	; 48
    4046:	69 f4       	brne	.+26     	; 0x4062 <vfprintf+0xc0>
    4048:	29 2d       	mov	r18, r9
    404a:	21 60       	ori	r18, 0x01	; 1
    404c:	2d c0       	rjmp	.+90     	; 0x40a8 <vfprintf+0x106>
    404e:	39 2d       	mov	r19, r9
    4050:	32 60       	ori	r19, 0x02	; 2
    4052:	93 2e       	mov	r9, r19
    4054:	89 2d       	mov	r24, r9
    4056:	84 60       	ori	r24, 0x04	; 4
    4058:	98 2e       	mov	r9, r24
    405a:	2a c0       	rjmp	.+84     	; 0x40b0 <vfprintf+0x10e>
    405c:	e9 2d       	mov	r30, r9
    405e:	e8 60       	ori	r30, 0x08	; 8
    4060:	15 c0       	rjmp	.+42     	; 0x408c <vfprintf+0xea>
    4062:	97 fc       	sbrc	r9, 7
    4064:	2d c0       	rjmp	.+90     	; 0x40c0 <vfprintf+0x11e>
    4066:	20 ed       	ldi	r18, 0xD0	; 208
    4068:	28 0f       	add	r18, r24
    406a:	2a 30       	cpi	r18, 0x0A	; 10
    406c:	88 f4       	brcc	.+34     	; 0x4090 <vfprintf+0xee>
    406e:	96 fe       	sbrs	r9, 6
    4070:	06 c0       	rjmp	.+12     	; 0x407e <vfprintf+0xdc>
    4072:	3a e0       	ldi	r19, 0x0A	; 10
    4074:	13 9f       	mul	r17, r19
    4076:	20 0d       	add	r18, r0
    4078:	11 24       	eor	r1, r1
    407a:	12 2f       	mov	r17, r18
    407c:	19 c0       	rjmp	.+50     	; 0x40b0 <vfprintf+0x10e>
    407e:	8a e0       	ldi	r24, 0x0A	; 10
    4080:	58 9e       	mul	r5, r24
    4082:	20 0d       	add	r18, r0
    4084:	11 24       	eor	r1, r1
    4086:	52 2e       	mov	r5, r18
    4088:	e9 2d       	mov	r30, r9
    408a:	e0 62       	ori	r30, 0x20	; 32
    408c:	9e 2e       	mov	r9, r30
    408e:	10 c0       	rjmp	.+32     	; 0x40b0 <vfprintf+0x10e>
    4090:	8e 32       	cpi	r24, 0x2E	; 46
    4092:	31 f4       	brne	.+12     	; 0x40a0 <vfprintf+0xfe>
    4094:	96 fc       	sbrc	r9, 6
    4096:	e5 c2       	rjmp	.+1482   	; 0x4662 <vfprintf+0x6c0>
    4098:	f9 2d       	mov	r31, r9
    409a:	f0 64       	ori	r31, 0x40	; 64
    409c:	9f 2e       	mov	r9, r31
    409e:	08 c0       	rjmp	.+16     	; 0x40b0 <vfprintf+0x10e>
    40a0:	8c 36       	cpi	r24, 0x6C	; 108
    40a2:	21 f4       	brne	.+8      	; 0x40ac <vfprintf+0x10a>
    40a4:	29 2d       	mov	r18, r9
    40a6:	20 68       	ori	r18, 0x80	; 128
    40a8:	92 2e       	mov	r9, r18
    40aa:	02 c0       	rjmp	.+4      	; 0x40b0 <vfprintf+0x10e>
    40ac:	88 36       	cpi	r24, 0x68	; 104
    40ae:	41 f4       	brne	.+16     	; 0x40c0 <vfprintf+0x11e>
    40b0:	f1 01       	movw	r30, r2
    40b2:	93 fd       	sbrc	r25, 3
    40b4:	85 91       	lpm	r24, Z+
    40b6:	93 ff       	sbrs	r25, 3
    40b8:	81 91       	ld	r24, Z+
    40ba:	1f 01       	movw	r2, r30
    40bc:	81 11       	cpse	r24, r1
    40be:	b3 cf       	rjmp	.-154    	; 0x4026 <vfprintf+0x84>
    40c0:	9b eb       	ldi	r25, 0xBB	; 187
    40c2:	98 0f       	add	r25, r24
    40c4:	93 30       	cpi	r25, 0x03	; 3
    40c6:	20 f4       	brcc	.+8      	; 0x40d0 <vfprintf+0x12e>
    40c8:	99 2d       	mov	r25, r9
    40ca:	90 61       	ori	r25, 0x10	; 16
    40cc:	80 5e       	subi	r24, 0xE0	; 224
    40ce:	07 c0       	rjmp	.+14     	; 0x40de <vfprintf+0x13c>
    40d0:	9b e9       	ldi	r25, 0x9B	; 155
    40d2:	98 0f       	add	r25, r24
    40d4:	93 30       	cpi	r25, 0x03	; 3
    40d6:	08 f0       	brcs	.+2      	; 0x40da <vfprintf+0x138>
    40d8:	66 c1       	rjmp	.+716    	; 0x43a6 <vfprintf+0x404>
    40da:	99 2d       	mov	r25, r9
    40dc:	9f 7e       	andi	r25, 0xEF	; 239
    40de:	96 ff       	sbrs	r25, 6
    40e0:	16 e0       	ldi	r17, 0x06	; 6
    40e2:	9f 73       	andi	r25, 0x3F	; 63
    40e4:	99 2e       	mov	r9, r25
    40e6:	85 36       	cpi	r24, 0x65	; 101
    40e8:	19 f4       	brne	.+6      	; 0x40f0 <vfprintf+0x14e>
    40ea:	90 64       	ori	r25, 0x40	; 64
    40ec:	99 2e       	mov	r9, r25
    40ee:	08 c0       	rjmp	.+16     	; 0x4100 <vfprintf+0x15e>
    40f0:	86 36       	cpi	r24, 0x66	; 102
    40f2:	21 f4       	brne	.+8      	; 0x40fc <vfprintf+0x15a>
    40f4:	39 2f       	mov	r19, r25
    40f6:	30 68       	ori	r19, 0x80	; 128
    40f8:	93 2e       	mov	r9, r19
    40fa:	02 c0       	rjmp	.+4      	; 0x4100 <vfprintf+0x15e>
    40fc:	11 11       	cpse	r17, r1
    40fe:	11 50       	subi	r17, 0x01	; 1
    4100:	97 fe       	sbrs	r9, 7
    4102:	07 c0       	rjmp	.+14     	; 0x4112 <vfprintf+0x170>
    4104:	1c 33       	cpi	r17, 0x3C	; 60
    4106:	50 f4       	brcc	.+20     	; 0x411c <vfprintf+0x17a>
    4108:	44 24       	eor	r4, r4
    410a:	43 94       	inc	r4
    410c:	41 0e       	add	r4, r17
    410e:	27 e0       	ldi	r18, 0x07	; 7
    4110:	0b c0       	rjmp	.+22     	; 0x4128 <vfprintf+0x186>
    4112:	18 30       	cpi	r17, 0x08	; 8
    4114:	38 f0       	brcs	.+14     	; 0x4124 <vfprintf+0x182>
    4116:	27 e0       	ldi	r18, 0x07	; 7
    4118:	17 e0       	ldi	r17, 0x07	; 7
    411a:	05 c0       	rjmp	.+10     	; 0x4126 <vfprintf+0x184>
    411c:	27 e0       	ldi	r18, 0x07	; 7
    411e:	9c e3       	ldi	r25, 0x3C	; 60
    4120:	49 2e       	mov	r4, r25
    4122:	02 c0       	rjmp	.+4      	; 0x4128 <vfprintf+0x186>
    4124:	21 2f       	mov	r18, r17
    4126:	41 2c       	mov	r4, r1
    4128:	56 01       	movw	r10, r12
    412a:	84 e0       	ldi	r24, 0x04	; 4
    412c:	a8 0e       	add	r10, r24
    412e:	b1 1c       	adc	r11, r1
    4130:	f6 01       	movw	r30, r12
    4132:	60 81       	ld	r22, Z
    4134:	71 81       	ldd	r23, Z+1	; 0x01
    4136:	82 81       	ldd	r24, Z+2	; 0x02
    4138:	93 81       	ldd	r25, Z+3	; 0x03
    413a:	04 2d       	mov	r16, r4
    413c:	a3 01       	movw	r20, r6
    413e:	0e 94 c9 24 	call	0x4992	; 0x4992 <__ftoa_engine>
    4142:	6c 01       	movw	r12, r24
    4144:	f9 81       	ldd	r31, Y+1	; 0x01
    4146:	fc 87       	std	Y+12, r31	; 0x0c
    4148:	f0 ff       	sbrs	r31, 0
    414a:	02 c0       	rjmp	.+4      	; 0x4150 <vfprintf+0x1ae>
    414c:	f3 ff       	sbrs	r31, 3
    414e:	06 c0       	rjmp	.+12     	; 0x415c <vfprintf+0x1ba>
    4150:	91 fc       	sbrc	r9, 1
    4152:	06 c0       	rjmp	.+12     	; 0x4160 <vfprintf+0x1be>
    4154:	92 fe       	sbrs	r9, 2
    4156:	06 c0       	rjmp	.+12     	; 0x4164 <vfprintf+0x1c2>
    4158:	00 e2       	ldi	r16, 0x20	; 32
    415a:	05 c0       	rjmp	.+10     	; 0x4166 <vfprintf+0x1c4>
    415c:	0d e2       	ldi	r16, 0x2D	; 45
    415e:	03 c0       	rjmp	.+6      	; 0x4166 <vfprintf+0x1c4>
    4160:	0b e2       	ldi	r16, 0x2B	; 43
    4162:	01 c0       	rjmp	.+2      	; 0x4166 <vfprintf+0x1c4>
    4164:	00 e0       	ldi	r16, 0x00	; 0
    4166:	8c 85       	ldd	r24, Y+12	; 0x0c
    4168:	8c 70       	andi	r24, 0x0C	; 12
    416a:	19 f0       	breq	.+6      	; 0x4172 <vfprintf+0x1d0>
    416c:	01 11       	cpse	r16, r1
    416e:	5a c2       	rjmp	.+1204   	; 0x4624 <vfprintf+0x682>
    4170:	9b c2       	rjmp	.+1334   	; 0x46a8 <vfprintf+0x706>
    4172:	97 fe       	sbrs	r9, 7
    4174:	10 c0       	rjmp	.+32     	; 0x4196 <vfprintf+0x1f4>
    4176:	4c 0c       	add	r4, r12
    4178:	fc 85       	ldd	r31, Y+12	; 0x0c
    417a:	f4 ff       	sbrs	r31, 4
    417c:	04 c0       	rjmp	.+8      	; 0x4186 <vfprintf+0x1e4>
    417e:	8a 81       	ldd	r24, Y+2	; 0x02
    4180:	81 33       	cpi	r24, 0x31	; 49
    4182:	09 f4       	brne	.+2      	; 0x4186 <vfprintf+0x1e4>
    4184:	4a 94       	dec	r4
    4186:	14 14       	cp	r1, r4
    4188:	74 f5       	brge	.+92     	; 0x41e6 <vfprintf+0x244>
    418a:	28 e0       	ldi	r18, 0x08	; 8
    418c:	24 15       	cp	r18, r4
    418e:	78 f5       	brcc	.+94     	; 0x41ee <vfprintf+0x24c>
    4190:	88 e0       	ldi	r24, 0x08	; 8
    4192:	48 2e       	mov	r4, r24
    4194:	2c c0       	rjmp	.+88     	; 0x41ee <vfprintf+0x24c>
    4196:	96 fc       	sbrc	r9, 6
    4198:	2a c0       	rjmp	.+84     	; 0x41ee <vfprintf+0x24c>
    419a:	81 2f       	mov	r24, r17
    419c:	90 e0       	ldi	r25, 0x00	; 0
    419e:	8c 15       	cp	r24, r12
    41a0:	9d 05       	cpc	r25, r13
    41a2:	9c f0       	brlt	.+38     	; 0x41ca <vfprintf+0x228>
    41a4:	3c ef       	ldi	r19, 0xFC	; 252
    41a6:	c3 16       	cp	r12, r19
    41a8:	3f ef       	ldi	r19, 0xFF	; 255
    41aa:	d3 06       	cpc	r13, r19
    41ac:	74 f0       	brlt	.+28     	; 0x41ca <vfprintf+0x228>
    41ae:	89 2d       	mov	r24, r9
    41b0:	80 68       	ori	r24, 0x80	; 128
    41b2:	98 2e       	mov	r9, r24
    41b4:	0a c0       	rjmp	.+20     	; 0x41ca <vfprintf+0x228>
    41b6:	e2 e0       	ldi	r30, 0x02	; 2
    41b8:	f0 e0       	ldi	r31, 0x00	; 0
    41ba:	ec 0f       	add	r30, r28
    41bc:	fd 1f       	adc	r31, r29
    41be:	e1 0f       	add	r30, r17
    41c0:	f1 1d       	adc	r31, r1
    41c2:	80 81       	ld	r24, Z
    41c4:	80 33       	cpi	r24, 0x30	; 48
    41c6:	19 f4       	brne	.+6      	; 0x41ce <vfprintf+0x22c>
    41c8:	11 50       	subi	r17, 0x01	; 1
    41ca:	11 11       	cpse	r17, r1
    41cc:	f4 cf       	rjmp	.-24     	; 0x41b6 <vfprintf+0x214>
    41ce:	97 fe       	sbrs	r9, 7
    41d0:	0e c0       	rjmp	.+28     	; 0x41ee <vfprintf+0x24c>
    41d2:	44 24       	eor	r4, r4
    41d4:	43 94       	inc	r4
    41d6:	41 0e       	add	r4, r17
    41d8:	81 2f       	mov	r24, r17
    41da:	90 e0       	ldi	r25, 0x00	; 0
    41dc:	c8 16       	cp	r12, r24
    41de:	d9 06       	cpc	r13, r25
    41e0:	2c f4       	brge	.+10     	; 0x41ec <vfprintf+0x24a>
    41e2:	1c 19       	sub	r17, r12
    41e4:	04 c0       	rjmp	.+8      	; 0x41ee <vfprintf+0x24c>
    41e6:	44 24       	eor	r4, r4
    41e8:	43 94       	inc	r4
    41ea:	01 c0       	rjmp	.+2      	; 0x41ee <vfprintf+0x24c>
    41ec:	10 e0       	ldi	r17, 0x00	; 0
    41ee:	97 fe       	sbrs	r9, 7
    41f0:	06 c0       	rjmp	.+12     	; 0x41fe <vfprintf+0x25c>
    41f2:	1c 14       	cp	r1, r12
    41f4:	1d 04       	cpc	r1, r13
    41f6:	34 f4       	brge	.+12     	; 0x4204 <vfprintf+0x262>
    41f8:	c6 01       	movw	r24, r12
    41fa:	01 96       	adiw	r24, 0x01	; 1
    41fc:	05 c0       	rjmp	.+10     	; 0x4208 <vfprintf+0x266>
    41fe:	85 e0       	ldi	r24, 0x05	; 5
    4200:	90 e0       	ldi	r25, 0x00	; 0
    4202:	02 c0       	rjmp	.+4      	; 0x4208 <vfprintf+0x266>
    4204:	81 e0       	ldi	r24, 0x01	; 1
    4206:	90 e0       	ldi	r25, 0x00	; 0
    4208:	01 11       	cpse	r16, r1
    420a:	01 96       	adiw	r24, 0x01	; 1
    420c:	11 23       	and	r17, r17
    420e:	31 f0       	breq	.+12     	; 0x421c <vfprintf+0x27a>
    4210:	21 2f       	mov	r18, r17
    4212:	30 e0       	ldi	r19, 0x00	; 0
    4214:	2f 5f       	subi	r18, 0xFF	; 255
    4216:	3f 4f       	sbci	r19, 0xFF	; 255
    4218:	82 0f       	add	r24, r18
    421a:	93 1f       	adc	r25, r19
    421c:	25 2d       	mov	r18, r5
    421e:	30 e0       	ldi	r19, 0x00	; 0
    4220:	82 17       	cp	r24, r18
    4222:	93 07       	cpc	r25, r19
    4224:	14 f4       	brge	.+4      	; 0x422a <vfprintf+0x288>
    4226:	58 1a       	sub	r5, r24
    4228:	01 c0       	rjmp	.+2      	; 0x422c <vfprintf+0x28a>
    422a:	51 2c       	mov	r5, r1
    422c:	89 2d       	mov	r24, r9
    422e:	89 70       	andi	r24, 0x09	; 9
    4230:	49 f4       	brne	.+18     	; 0x4244 <vfprintf+0x2a2>
    4232:	55 20       	and	r5, r5
    4234:	39 f0       	breq	.+14     	; 0x4244 <vfprintf+0x2a2>
    4236:	b7 01       	movw	r22, r14
    4238:	80 e2       	ldi	r24, 0x20	; 32
    423a:	90 e0       	ldi	r25, 0x00	; 0
    423c:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    4240:	5a 94       	dec	r5
    4242:	f7 cf       	rjmp	.-18     	; 0x4232 <vfprintf+0x290>
    4244:	00 23       	and	r16, r16
    4246:	29 f0       	breq	.+10     	; 0x4252 <vfprintf+0x2b0>
    4248:	b7 01       	movw	r22, r14
    424a:	80 2f       	mov	r24, r16
    424c:	90 e0       	ldi	r25, 0x00	; 0
    424e:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    4252:	93 fc       	sbrc	r9, 3
    4254:	09 c0       	rjmp	.+18     	; 0x4268 <vfprintf+0x2c6>
    4256:	55 20       	and	r5, r5
    4258:	39 f0       	breq	.+14     	; 0x4268 <vfprintf+0x2c6>
    425a:	b7 01       	movw	r22, r14
    425c:	80 e3       	ldi	r24, 0x30	; 48
    425e:	90 e0       	ldi	r25, 0x00	; 0
    4260:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    4264:	5a 94       	dec	r5
    4266:	f7 cf       	rjmp	.-18     	; 0x4256 <vfprintf+0x2b4>
    4268:	97 fe       	sbrs	r9, 7
    426a:	4c c0       	rjmp	.+152    	; 0x4304 <vfprintf+0x362>
    426c:	46 01       	movw	r8, r12
    426e:	d7 fe       	sbrs	r13, 7
    4270:	02 c0       	rjmp	.+4      	; 0x4276 <vfprintf+0x2d4>
    4272:	81 2c       	mov	r8, r1
    4274:	91 2c       	mov	r9, r1
    4276:	c6 01       	movw	r24, r12
    4278:	88 19       	sub	r24, r8
    427a:	99 09       	sbc	r25, r9
    427c:	f3 01       	movw	r30, r6
    427e:	e8 0f       	add	r30, r24
    4280:	f9 1f       	adc	r31, r25
    4282:	ed 87       	std	Y+13, r30	; 0x0d
    4284:	fe 87       	std	Y+14, r31	; 0x0e
    4286:	96 01       	movw	r18, r12
    4288:	24 19       	sub	r18, r4
    428a:	31 09       	sbc	r19, r1
    428c:	2f 87       	std	Y+15, r18	; 0x0f
    428e:	38 8b       	std	Y+16, r19	; 0x10
    4290:	01 2f       	mov	r16, r17
    4292:	10 e0       	ldi	r17, 0x00	; 0
    4294:	11 95       	neg	r17
    4296:	01 95       	neg	r16
    4298:	11 09       	sbc	r17, r1
    429a:	3f ef       	ldi	r19, 0xFF	; 255
    429c:	83 16       	cp	r8, r19
    429e:	93 06       	cpc	r9, r19
    42a0:	29 f4       	brne	.+10     	; 0x42ac <vfprintf+0x30a>
    42a2:	b7 01       	movw	r22, r14
    42a4:	8e e2       	ldi	r24, 0x2E	; 46
    42a6:	90 e0       	ldi	r25, 0x00	; 0
    42a8:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    42ac:	c8 14       	cp	r12, r8
    42ae:	d9 04       	cpc	r13, r9
    42b0:	4c f0       	brlt	.+18     	; 0x42c4 <vfprintf+0x322>
    42b2:	8f 85       	ldd	r24, Y+15	; 0x0f
    42b4:	98 89       	ldd	r25, Y+16	; 0x10
    42b6:	88 15       	cp	r24, r8
    42b8:	99 05       	cpc	r25, r9
    42ba:	24 f4       	brge	.+8      	; 0x42c4 <vfprintf+0x322>
    42bc:	ed 85       	ldd	r30, Y+13	; 0x0d
    42be:	fe 85       	ldd	r31, Y+14	; 0x0e
    42c0:	81 81       	ldd	r24, Z+1	; 0x01
    42c2:	01 c0       	rjmp	.+2      	; 0x42c6 <vfprintf+0x324>
    42c4:	80 e3       	ldi	r24, 0x30	; 48
    42c6:	f1 e0       	ldi	r31, 0x01	; 1
    42c8:	8f 1a       	sub	r8, r31
    42ca:	91 08       	sbc	r9, r1
    42cc:	2d 85       	ldd	r18, Y+13	; 0x0d
    42ce:	3e 85       	ldd	r19, Y+14	; 0x0e
    42d0:	2f 5f       	subi	r18, 0xFF	; 255
    42d2:	3f 4f       	sbci	r19, 0xFF	; 255
    42d4:	2d 87       	std	Y+13, r18	; 0x0d
    42d6:	3e 87       	std	Y+14, r19	; 0x0e
    42d8:	80 16       	cp	r8, r16
    42da:	91 06       	cpc	r9, r17
    42dc:	2c f0       	brlt	.+10     	; 0x42e8 <vfprintf+0x346>
    42de:	b7 01       	movw	r22, r14
    42e0:	90 e0       	ldi	r25, 0x00	; 0
    42e2:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    42e6:	d9 cf       	rjmp	.-78     	; 0x429a <vfprintf+0x2f8>
    42e8:	c8 14       	cp	r12, r8
    42ea:	d9 04       	cpc	r13, r9
    42ec:	41 f4       	brne	.+16     	; 0x42fe <vfprintf+0x35c>
    42ee:	9a 81       	ldd	r25, Y+2	; 0x02
    42f0:	96 33       	cpi	r25, 0x36	; 54
    42f2:	20 f4       	brcc	.+8      	; 0x42fc <vfprintf+0x35a>
    42f4:	95 33       	cpi	r25, 0x35	; 53
    42f6:	19 f4       	brne	.+6      	; 0x42fe <vfprintf+0x35c>
    42f8:	3c 85       	ldd	r19, Y+12	; 0x0c
    42fa:	34 ff       	sbrs	r19, 4
    42fc:	81 e3       	ldi	r24, 0x31	; 49
    42fe:	b7 01       	movw	r22, r14
    4300:	90 e0       	ldi	r25, 0x00	; 0
    4302:	4e c0       	rjmp	.+156    	; 0x43a0 <vfprintf+0x3fe>
    4304:	8a 81       	ldd	r24, Y+2	; 0x02
    4306:	81 33       	cpi	r24, 0x31	; 49
    4308:	19 f0       	breq	.+6      	; 0x4310 <vfprintf+0x36e>
    430a:	9c 85       	ldd	r25, Y+12	; 0x0c
    430c:	9f 7e       	andi	r25, 0xEF	; 239
    430e:	9c 87       	std	Y+12, r25	; 0x0c
    4310:	b7 01       	movw	r22, r14
    4312:	90 e0       	ldi	r25, 0x00	; 0
    4314:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    4318:	11 11       	cpse	r17, r1
    431a:	05 c0       	rjmp	.+10     	; 0x4326 <vfprintf+0x384>
    431c:	94 fc       	sbrc	r9, 4
    431e:	18 c0       	rjmp	.+48     	; 0x4350 <vfprintf+0x3ae>
    4320:	85 e6       	ldi	r24, 0x65	; 101
    4322:	90 e0       	ldi	r25, 0x00	; 0
    4324:	17 c0       	rjmp	.+46     	; 0x4354 <vfprintf+0x3b2>
    4326:	b7 01       	movw	r22, r14
    4328:	8e e2       	ldi	r24, 0x2E	; 46
    432a:	90 e0       	ldi	r25, 0x00	; 0
    432c:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    4330:	1e 5f       	subi	r17, 0xFE	; 254
    4332:	82 e0       	ldi	r24, 0x02	; 2
    4334:	01 e0       	ldi	r16, 0x01	; 1
    4336:	08 0f       	add	r16, r24
    4338:	f3 01       	movw	r30, r6
    433a:	e8 0f       	add	r30, r24
    433c:	f1 1d       	adc	r31, r1
    433e:	80 81       	ld	r24, Z
    4340:	b7 01       	movw	r22, r14
    4342:	90 e0       	ldi	r25, 0x00	; 0
    4344:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    4348:	80 2f       	mov	r24, r16
    434a:	01 13       	cpse	r16, r17
    434c:	f3 cf       	rjmp	.-26     	; 0x4334 <vfprintf+0x392>
    434e:	e6 cf       	rjmp	.-52     	; 0x431c <vfprintf+0x37a>
    4350:	85 e4       	ldi	r24, 0x45	; 69
    4352:	90 e0       	ldi	r25, 0x00	; 0
    4354:	b7 01       	movw	r22, r14
    4356:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    435a:	d7 fc       	sbrc	r13, 7
    435c:	06 c0       	rjmp	.+12     	; 0x436a <vfprintf+0x3c8>
    435e:	c1 14       	cp	r12, r1
    4360:	d1 04       	cpc	r13, r1
    4362:	41 f4       	brne	.+16     	; 0x4374 <vfprintf+0x3d2>
    4364:	ec 85       	ldd	r30, Y+12	; 0x0c
    4366:	e4 ff       	sbrs	r30, 4
    4368:	05 c0       	rjmp	.+10     	; 0x4374 <vfprintf+0x3d2>
    436a:	d1 94       	neg	r13
    436c:	c1 94       	neg	r12
    436e:	d1 08       	sbc	r13, r1
    4370:	8d e2       	ldi	r24, 0x2D	; 45
    4372:	01 c0       	rjmp	.+2      	; 0x4376 <vfprintf+0x3d4>
    4374:	8b e2       	ldi	r24, 0x2B	; 43
    4376:	b7 01       	movw	r22, r14
    4378:	90 e0       	ldi	r25, 0x00	; 0
    437a:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    437e:	80 e3       	ldi	r24, 0x30	; 48
    4380:	2a e0       	ldi	r18, 0x0A	; 10
    4382:	c2 16       	cp	r12, r18
    4384:	d1 04       	cpc	r13, r1
    4386:	2c f0       	brlt	.+10     	; 0x4392 <vfprintf+0x3f0>
    4388:	8f 5f       	subi	r24, 0xFF	; 255
    438a:	fa e0       	ldi	r31, 0x0A	; 10
    438c:	cf 1a       	sub	r12, r31
    438e:	d1 08       	sbc	r13, r1
    4390:	f7 cf       	rjmp	.-18     	; 0x4380 <vfprintf+0x3de>
    4392:	b7 01       	movw	r22, r14
    4394:	90 e0       	ldi	r25, 0x00	; 0
    4396:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    439a:	b7 01       	movw	r22, r14
    439c:	c6 01       	movw	r24, r12
    439e:	c0 96       	adiw	r24, 0x30	; 48
    43a0:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    43a4:	54 c1       	rjmp	.+680    	; 0x464e <vfprintf+0x6ac>
    43a6:	83 36       	cpi	r24, 0x63	; 99
    43a8:	31 f0       	breq	.+12     	; 0x43b6 <vfprintf+0x414>
    43aa:	83 37       	cpi	r24, 0x73	; 115
    43ac:	79 f0       	breq	.+30     	; 0x43cc <vfprintf+0x42a>
    43ae:	83 35       	cpi	r24, 0x53	; 83
    43b0:	09 f0       	breq	.+2      	; 0x43b4 <vfprintf+0x412>
    43b2:	56 c0       	rjmp	.+172    	; 0x4460 <vfprintf+0x4be>
    43b4:	20 c0       	rjmp	.+64     	; 0x43f6 <vfprintf+0x454>
    43b6:	56 01       	movw	r10, r12
    43b8:	32 e0       	ldi	r19, 0x02	; 2
    43ba:	a3 0e       	add	r10, r19
    43bc:	b1 1c       	adc	r11, r1
    43be:	f6 01       	movw	r30, r12
    43c0:	80 81       	ld	r24, Z
    43c2:	89 83       	std	Y+1, r24	; 0x01
    43c4:	01 e0       	ldi	r16, 0x01	; 1
    43c6:	10 e0       	ldi	r17, 0x00	; 0
    43c8:	63 01       	movw	r12, r6
    43ca:	12 c0       	rjmp	.+36     	; 0x43f0 <vfprintf+0x44e>
    43cc:	56 01       	movw	r10, r12
    43ce:	f2 e0       	ldi	r31, 0x02	; 2
    43d0:	af 0e       	add	r10, r31
    43d2:	b1 1c       	adc	r11, r1
    43d4:	f6 01       	movw	r30, r12
    43d6:	c0 80       	ld	r12, Z
    43d8:	d1 80       	ldd	r13, Z+1	; 0x01
    43da:	96 fe       	sbrs	r9, 6
    43dc:	03 c0       	rjmp	.+6      	; 0x43e4 <vfprintf+0x442>
    43de:	61 2f       	mov	r22, r17
    43e0:	70 e0       	ldi	r23, 0x00	; 0
    43e2:	02 c0       	rjmp	.+4      	; 0x43e8 <vfprintf+0x446>
    43e4:	6f ef       	ldi	r22, 0xFF	; 255
    43e6:	7f ef       	ldi	r23, 0xFF	; 255
    43e8:	c6 01       	movw	r24, r12
    43ea:	0e 94 bc 25 	call	0x4b78	; 0x4b78 <strnlen>
    43ee:	8c 01       	movw	r16, r24
    43f0:	f9 2d       	mov	r31, r9
    43f2:	ff 77       	andi	r31, 0x7F	; 127
    43f4:	14 c0       	rjmp	.+40     	; 0x441e <vfprintf+0x47c>
    43f6:	56 01       	movw	r10, r12
    43f8:	22 e0       	ldi	r18, 0x02	; 2
    43fa:	a2 0e       	add	r10, r18
    43fc:	b1 1c       	adc	r11, r1
    43fe:	f6 01       	movw	r30, r12
    4400:	c0 80       	ld	r12, Z
    4402:	d1 80       	ldd	r13, Z+1	; 0x01
    4404:	96 fe       	sbrs	r9, 6
    4406:	03 c0       	rjmp	.+6      	; 0x440e <vfprintf+0x46c>
    4408:	61 2f       	mov	r22, r17
    440a:	70 e0       	ldi	r23, 0x00	; 0
    440c:	02 c0       	rjmp	.+4      	; 0x4412 <vfprintf+0x470>
    440e:	6f ef       	ldi	r22, 0xFF	; 255
    4410:	7f ef       	ldi	r23, 0xFF	; 255
    4412:	c6 01       	movw	r24, r12
    4414:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <strnlen_P>
    4418:	8c 01       	movw	r16, r24
    441a:	f9 2d       	mov	r31, r9
    441c:	f0 68       	ori	r31, 0x80	; 128
    441e:	9f 2e       	mov	r9, r31
    4420:	f3 fd       	sbrc	r31, 3
    4422:	1a c0       	rjmp	.+52     	; 0x4458 <vfprintf+0x4b6>
    4424:	85 2d       	mov	r24, r5
    4426:	90 e0       	ldi	r25, 0x00	; 0
    4428:	08 17       	cp	r16, r24
    442a:	19 07       	cpc	r17, r25
    442c:	a8 f4       	brcc	.+42     	; 0x4458 <vfprintf+0x4b6>
    442e:	b7 01       	movw	r22, r14
    4430:	80 e2       	ldi	r24, 0x20	; 32
    4432:	90 e0       	ldi	r25, 0x00	; 0
    4434:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    4438:	5a 94       	dec	r5
    443a:	f4 cf       	rjmp	.-24     	; 0x4424 <vfprintf+0x482>
    443c:	f6 01       	movw	r30, r12
    443e:	97 fc       	sbrc	r9, 7
    4440:	85 91       	lpm	r24, Z+
    4442:	97 fe       	sbrs	r9, 7
    4444:	81 91       	ld	r24, Z+
    4446:	6f 01       	movw	r12, r30
    4448:	b7 01       	movw	r22, r14
    444a:	90 e0       	ldi	r25, 0x00	; 0
    444c:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    4450:	51 10       	cpse	r5, r1
    4452:	5a 94       	dec	r5
    4454:	01 50       	subi	r16, 0x01	; 1
    4456:	11 09       	sbc	r17, r1
    4458:	01 15       	cp	r16, r1
    445a:	11 05       	cpc	r17, r1
    445c:	79 f7       	brne	.-34     	; 0x443c <vfprintf+0x49a>
    445e:	f7 c0       	rjmp	.+494    	; 0x464e <vfprintf+0x6ac>
    4460:	84 36       	cpi	r24, 0x64	; 100
    4462:	11 f0       	breq	.+4      	; 0x4468 <vfprintf+0x4c6>
    4464:	89 36       	cpi	r24, 0x69	; 105
    4466:	61 f5       	brne	.+88     	; 0x44c0 <vfprintf+0x51e>
    4468:	56 01       	movw	r10, r12
    446a:	97 fe       	sbrs	r9, 7
    446c:	09 c0       	rjmp	.+18     	; 0x4480 <vfprintf+0x4de>
    446e:	24 e0       	ldi	r18, 0x04	; 4
    4470:	a2 0e       	add	r10, r18
    4472:	b1 1c       	adc	r11, r1
    4474:	f6 01       	movw	r30, r12
    4476:	60 81       	ld	r22, Z
    4478:	71 81       	ldd	r23, Z+1	; 0x01
    447a:	82 81       	ldd	r24, Z+2	; 0x02
    447c:	93 81       	ldd	r25, Z+3	; 0x03
    447e:	0a c0       	rjmp	.+20     	; 0x4494 <vfprintf+0x4f2>
    4480:	f2 e0       	ldi	r31, 0x02	; 2
    4482:	af 0e       	add	r10, r31
    4484:	b1 1c       	adc	r11, r1
    4486:	f6 01       	movw	r30, r12
    4488:	60 81       	ld	r22, Z
    448a:	71 81       	ldd	r23, Z+1	; 0x01
    448c:	07 2e       	mov	r0, r23
    448e:	00 0c       	add	r0, r0
    4490:	88 0b       	sbc	r24, r24
    4492:	99 0b       	sbc	r25, r25
    4494:	f9 2d       	mov	r31, r9
    4496:	ff 76       	andi	r31, 0x6F	; 111
    4498:	9f 2e       	mov	r9, r31
    449a:	97 ff       	sbrs	r25, 7
    449c:	09 c0       	rjmp	.+18     	; 0x44b0 <vfprintf+0x50e>
    449e:	90 95       	com	r25
    44a0:	80 95       	com	r24
    44a2:	70 95       	com	r23
    44a4:	61 95       	neg	r22
    44a6:	7f 4f       	sbci	r23, 0xFF	; 255
    44a8:	8f 4f       	sbci	r24, 0xFF	; 255
    44aa:	9f 4f       	sbci	r25, 0xFF	; 255
    44ac:	f0 68       	ori	r31, 0x80	; 128
    44ae:	9f 2e       	mov	r9, r31
    44b0:	2a e0       	ldi	r18, 0x0A	; 10
    44b2:	30 e0       	ldi	r19, 0x00	; 0
    44b4:	a3 01       	movw	r20, r6
    44b6:	0e 94 03 26 	call	0x4c06	; 0x4c06 <__ultoa_invert>
    44ba:	c8 2e       	mov	r12, r24
    44bc:	c6 18       	sub	r12, r6
    44be:	3f c0       	rjmp	.+126    	; 0x453e <vfprintf+0x59c>
    44c0:	09 2d       	mov	r16, r9
    44c2:	85 37       	cpi	r24, 0x75	; 117
    44c4:	21 f4       	brne	.+8      	; 0x44ce <vfprintf+0x52c>
    44c6:	0f 7e       	andi	r16, 0xEF	; 239
    44c8:	2a e0       	ldi	r18, 0x0A	; 10
    44ca:	30 e0       	ldi	r19, 0x00	; 0
    44cc:	1d c0       	rjmp	.+58     	; 0x4508 <vfprintf+0x566>
    44ce:	09 7f       	andi	r16, 0xF9	; 249
    44d0:	8f 36       	cpi	r24, 0x6F	; 111
    44d2:	91 f0       	breq	.+36     	; 0x44f8 <vfprintf+0x556>
    44d4:	18 f4       	brcc	.+6      	; 0x44dc <vfprintf+0x53a>
    44d6:	88 35       	cpi	r24, 0x58	; 88
    44d8:	59 f0       	breq	.+22     	; 0x44f0 <vfprintf+0x54e>
    44da:	c3 c0       	rjmp	.+390    	; 0x4662 <vfprintf+0x6c0>
    44dc:	80 37       	cpi	r24, 0x70	; 112
    44de:	19 f0       	breq	.+6      	; 0x44e6 <vfprintf+0x544>
    44e0:	88 37       	cpi	r24, 0x78	; 120
    44e2:	11 f0       	breq	.+4      	; 0x44e8 <vfprintf+0x546>
    44e4:	be c0       	rjmp	.+380    	; 0x4662 <vfprintf+0x6c0>
    44e6:	00 61       	ori	r16, 0x10	; 16
    44e8:	04 ff       	sbrs	r16, 4
    44ea:	09 c0       	rjmp	.+18     	; 0x44fe <vfprintf+0x55c>
    44ec:	04 60       	ori	r16, 0x04	; 4
    44ee:	07 c0       	rjmp	.+14     	; 0x44fe <vfprintf+0x55c>
    44f0:	94 fe       	sbrs	r9, 4
    44f2:	08 c0       	rjmp	.+16     	; 0x4504 <vfprintf+0x562>
    44f4:	06 60       	ori	r16, 0x06	; 6
    44f6:	06 c0       	rjmp	.+12     	; 0x4504 <vfprintf+0x562>
    44f8:	28 e0       	ldi	r18, 0x08	; 8
    44fa:	30 e0       	ldi	r19, 0x00	; 0
    44fc:	05 c0       	rjmp	.+10     	; 0x4508 <vfprintf+0x566>
    44fe:	20 e1       	ldi	r18, 0x10	; 16
    4500:	30 e0       	ldi	r19, 0x00	; 0
    4502:	02 c0       	rjmp	.+4      	; 0x4508 <vfprintf+0x566>
    4504:	20 e1       	ldi	r18, 0x10	; 16
    4506:	32 e0       	ldi	r19, 0x02	; 2
    4508:	56 01       	movw	r10, r12
    450a:	07 ff       	sbrs	r16, 7
    450c:	09 c0       	rjmp	.+18     	; 0x4520 <vfprintf+0x57e>
    450e:	84 e0       	ldi	r24, 0x04	; 4
    4510:	a8 0e       	add	r10, r24
    4512:	b1 1c       	adc	r11, r1
    4514:	f6 01       	movw	r30, r12
    4516:	60 81       	ld	r22, Z
    4518:	71 81       	ldd	r23, Z+1	; 0x01
    451a:	82 81       	ldd	r24, Z+2	; 0x02
    451c:	93 81       	ldd	r25, Z+3	; 0x03
    451e:	08 c0       	rjmp	.+16     	; 0x4530 <vfprintf+0x58e>
    4520:	f2 e0       	ldi	r31, 0x02	; 2
    4522:	af 0e       	add	r10, r31
    4524:	b1 1c       	adc	r11, r1
    4526:	f6 01       	movw	r30, r12
    4528:	60 81       	ld	r22, Z
    452a:	71 81       	ldd	r23, Z+1	; 0x01
    452c:	80 e0       	ldi	r24, 0x00	; 0
    452e:	90 e0       	ldi	r25, 0x00	; 0
    4530:	a3 01       	movw	r20, r6
    4532:	0e 94 03 26 	call	0x4c06	; 0x4c06 <__ultoa_invert>
    4536:	c8 2e       	mov	r12, r24
    4538:	c6 18       	sub	r12, r6
    453a:	0f 77       	andi	r16, 0x7F	; 127
    453c:	90 2e       	mov	r9, r16
    453e:	96 fe       	sbrs	r9, 6
    4540:	0b c0       	rjmp	.+22     	; 0x4558 <vfprintf+0x5b6>
    4542:	09 2d       	mov	r16, r9
    4544:	0e 7f       	andi	r16, 0xFE	; 254
    4546:	c1 16       	cp	r12, r17
    4548:	50 f4       	brcc	.+20     	; 0x455e <vfprintf+0x5bc>
    454a:	94 fe       	sbrs	r9, 4
    454c:	0a c0       	rjmp	.+20     	; 0x4562 <vfprintf+0x5c0>
    454e:	92 fc       	sbrc	r9, 2
    4550:	08 c0       	rjmp	.+16     	; 0x4562 <vfprintf+0x5c0>
    4552:	09 2d       	mov	r16, r9
    4554:	0e 7e       	andi	r16, 0xEE	; 238
    4556:	05 c0       	rjmp	.+10     	; 0x4562 <vfprintf+0x5c0>
    4558:	dc 2c       	mov	r13, r12
    455a:	09 2d       	mov	r16, r9
    455c:	03 c0       	rjmp	.+6      	; 0x4564 <vfprintf+0x5c2>
    455e:	dc 2c       	mov	r13, r12
    4560:	01 c0       	rjmp	.+2      	; 0x4564 <vfprintf+0x5c2>
    4562:	d1 2e       	mov	r13, r17
    4564:	04 ff       	sbrs	r16, 4
    4566:	0d c0       	rjmp	.+26     	; 0x4582 <vfprintf+0x5e0>
    4568:	fe 01       	movw	r30, r28
    456a:	ec 0d       	add	r30, r12
    456c:	f1 1d       	adc	r31, r1
    456e:	80 81       	ld	r24, Z
    4570:	80 33       	cpi	r24, 0x30	; 48
    4572:	11 f4       	brne	.+4      	; 0x4578 <vfprintf+0x5d6>
    4574:	09 7e       	andi	r16, 0xE9	; 233
    4576:	09 c0       	rjmp	.+18     	; 0x458a <vfprintf+0x5e8>
    4578:	02 ff       	sbrs	r16, 2
    457a:	06 c0       	rjmp	.+12     	; 0x4588 <vfprintf+0x5e6>
    457c:	d3 94       	inc	r13
    457e:	d3 94       	inc	r13
    4580:	04 c0       	rjmp	.+8      	; 0x458a <vfprintf+0x5e8>
    4582:	80 2f       	mov	r24, r16
    4584:	86 78       	andi	r24, 0x86	; 134
    4586:	09 f0       	breq	.+2      	; 0x458a <vfprintf+0x5e8>
    4588:	d3 94       	inc	r13
    458a:	03 fd       	sbrc	r16, 3
    458c:	11 c0       	rjmp	.+34     	; 0x45b0 <vfprintf+0x60e>
    458e:	00 ff       	sbrs	r16, 0
    4590:	06 c0       	rjmp	.+12     	; 0x459e <vfprintf+0x5fc>
    4592:	1c 2d       	mov	r17, r12
    4594:	d5 14       	cp	r13, r5
    4596:	80 f4       	brcc	.+32     	; 0x45b8 <vfprintf+0x616>
    4598:	15 0d       	add	r17, r5
    459a:	1d 19       	sub	r17, r13
    459c:	0d c0       	rjmp	.+26     	; 0x45b8 <vfprintf+0x616>
    459e:	d5 14       	cp	r13, r5
    45a0:	58 f4       	brcc	.+22     	; 0x45b8 <vfprintf+0x616>
    45a2:	b7 01       	movw	r22, r14
    45a4:	80 e2       	ldi	r24, 0x20	; 32
    45a6:	90 e0       	ldi	r25, 0x00	; 0
    45a8:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    45ac:	d3 94       	inc	r13
    45ae:	f7 cf       	rjmp	.-18     	; 0x459e <vfprintf+0x5fc>
    45b0:	d5 14       	cp	r13, r5
    45b2:	10 f4       	brcc	.+4      	; 0x45b8 <vfprintf+0x616>
    45b4:	5d 18       	sub	r5, r13
    45b6:	01 c0       	rjmp	.+2      	; 0x45ba <vfprintf+0x618>
    45b8:	51 2c       	mov	r5, r1
    45ba:	04 ff       	sbrs	r16, 4
    45bc:	10 c0       	rjmp	.+32     	; 0x45de <vfprintf+0x63c>
    45be:	b7 01       	movw	r22, r14
    45c0:	80 e3       	ldi	r24, 0x30	; 48
    45c2:	90 e0       	ldi	r25, 0x00	; 0
    45c4:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    45c8:	02 ff       	sbrs	r16, 2
    45ca:	17 c0       	rjmp	.+46     	; 0x45fa <vfprintf+0x658>
    45cc:	01 fd       	sbrc	r16, 1
    45ce:	03 c0       	rjmp	.+6      	; 0x45d6 <vfprintf+0x634>
    45d0:	88 e7       	ldi	r24, 0x78	; 120
    45d2:	90 e0       	ldi	r25, 0x00	; 0
    45d4:	02 c0       	rjmp	.+4      	; 0x45da <vfprintf+0x638>
    45d6:	88 e5       	ldi	r24, 0x58	; 88
    45d8:	90 e0       	ldi	r25, 0x00	; 0
    45da:	b7 01       	movw	r22, r14
    45dc:	0c c0       	rjmp	.+24     	; 0x45f6 <vfprintf+0x654>
    45de:	80 2f       	mov	r24, r16
    45e0:	86 78       	andi	r24, 0x86	; 134
    45e2:	59 f0       	breq	.+22     	; 0x45fa <vfprintf+0x658>
    45e4:	01 ff       	sbrs	r16, 1
    45e6:	02 c0       	rjmp	.+4      	; 0x45ec <vfprintf+0x64a>
    45e8:	8b e2       	ldi	r24, 0x2B	; 43
    45ea:	01 c0       	rjmp	.+2      	; 0x45ee <vfprintf+0x64c>
    45ec:	80 e2       	ldi	r24, 0x20	; 32
    45ee:	07 fd       	sbrc	r16, 7
    45f0:	8d e2       	ldi	r24, 0x2D	; 45
    45f2:	b7 01       	movw	r22, r14
    45f4:	90 e0       	ldi	r25, 0x00	; 0
    45f6:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    45fa:	c1 16       	cp	r12, r17
    45fc:	38 f4       	brcc	.+14     	; 0x460c <vfprintf+0x66a>
    45fe:	b7 01       	movw	r22, r14
    4600:	80 e3       	ldi	r24, 0x30	; 48
    4602:	90 e0       	ldi	r25, 0x00	; 0
    4604:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    4608:	11 50       	subi	r17, 0x01	; 1
    460a:	f7 cf       	rjmp	.-18     	; 0x45fa <vfprintf+0x658>
    460c:	ca 94       	dec	r12
    460e:	f3 01       	movw	r30, r6
    4610:	ec 0d       	add	r30, r12
    4612:	f1 1d       	adc	r31, r1
    4614:	80 81       	ld	r24, Z
    4616:	b7 01       	movw	r22, r14
    4618:	90 e0       	ldi	r25, 0x00	; 0
    461a:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    461e:	c1 10       	cpse	r12, r1
    4620:	f5 cf       	rjmp	.-22     	; 0x460c <vfprintf+0x66a>
    4622:	15 c0       	rjmp	.+42     	; 0x464e <vfprintf+0x6ac>
    4624:	f4 e0       	ldi	r31, 0x04	; 4
    4626:	f5 15       	cp	r31, r5
    4628:	60 f5       	brcc	.+88     	; 0x4682 <vfprintf+0x6e0>
    462a:	84 e0       	ldi	r24, 0x04	; 4
    462c:	58 1a       	sub	r5, r24
    462e:	93 fe       	sbrs	r9, 3
    4630:	1f c0       	rjmp	.+62     	; 0x4670 <vfprintf+0x6ce>
    4632:	01 11       	cpse	r16, r1
    4634:	27 c0       	rjmp	.+78     	; 0x4684 <vfprintf+0x6e2>
    4636:	2c 85       	ldd	r18, Y+12	; 0x0c
    4638:	23 ff       	sbrs	r18, 3
    463a:	2a c0       	rjmp	.+84     	; 0x4690 <vfprintf+0x6ee>
    463c:	00 e1       	ldi	r16, 0x10	; 16
    463e:	12 e0       	ldi	r17, 0x02	; 2
    4640:	39 2d       	mov	r19, r9
    4642:	30 71       	andi	r19, 0x10	; 16
    4644:	93 2e       	mov	r9, r19
    4646:	f8 01       	movw	r30, r16
    4648:	84 91       	lpm	r24, Z
    464a:	81 11       	cpse	r24, r1
    464c:	24 c0       	rjmp	.+72     	; 0x4696 <vfprintf+0x6f4>
    464e:	55 20       	and	r5, r5
    4650:	09 f4       	brne	.+2      	; 0x4654 <vfprintf+0x6b2>
    4652:	e4 cc       	rjmp	.-1592   	; 0x401c <vfprintf+0x7a>
    4654:	b7 01       	movw	r22, r14
    4656:	80 e2       	ldi	r24, 0x20	; 32
    4658:	90 e0       	ldi	r25, 0x00	; 0
    465a:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    465e:	5a 94       	dec	r5
    4660:	f6 cf       	rjmp	.-20     	; 0x464e <vfprintf+0x6ac>
    4662:	f7 01       	movw	r30, r14
    4664:	86 81       	ldd	r24, Z+6	; 0x06
    4666:	97 81       	ldd	r25, Z+7	; 0x07
    4668:	26 c0       	rjmp	.+76     	; 0x46b6 <vfprintf+0x714>
    466a:	8f ef       	ldi	r24, 0xFF	; 255
    466c:	9f ef       	ldi	r25, 0xFF	; 255
    466e:	23 c0       	rjmp	.+70     	; 0x46b6 <vfprintf+0x714>
    4670:	b7 01       	movw	r22, r14
    4672:	80 e2       	ldi	r24, 0x20	; 32
    4674:	90 e0       	ldi	r25, 0x00	; 0
    4676:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    467a:	5a 94       	dec	r5
    467c:	51 10       	cpse	r5, r1
    467e:	f8 cf       	rjmp	.-16     	; 0x4670 <vfprintf+0x6ce>
    4680:	d8 cf       	rjmp	.-80     	; 0x4632 <vfprintf+0x690>
    4682:	51 2c       	mov	r5, r1
    4684:	b7 01       	movw	r22, r14
    4686:	80 2f       	mov	r24, r16
    4688:	90 e0       	ldi	r25, 0x00	; 0
    468a:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    468e:	d3 cf       	rjmp	.-90     	; 0x4636 <vfprintf+0x694>
    4690:	04 e1       	ldi	r16, 0x14	; 20
    4692:	12 e0       	ldi	r17, 0x02	; 2
    4694:	d5 cf       	rjmp	.-86     	; 0x4640 <vfprintf+0x69e>
    4696:	91 10       	cpse	r9, r1
    4698:	80 52       	subi	r24, 0x20	; 32
    469a:	b7 01       	movw	r22, r14
    469c:	90 e0       	ldi	r25, 0x00	; 0
    469e:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <fputc>
    46a2:	0f 5f       	subi	r16, 0xFF	; 255
    46a4:	1f 4f       	sbci	r17, 0xFF	; 255
    46a6:	cf cf       	rjmp	.-98     	; 0x4646 <vfprintf+0x6a4>
    46a8:	23 e0       	ldi	r18, 0x03	; 3
    46aa:	25 15       	cp	r18, r5
    46ac:	10 f4       	brcc	.+4      	; 0x46b2 <vfprintf+0x710>
    46ae:	83 e0       	ldi	r24, 0x03	; 3
    46b0:	bd cf       	rjmp	.-134    	; 0x462c <vfprintf+0x68a>
    46b2:	51 2c       	mov	r5, r1
    46b4:	c0 cf       	rjmp	.-128    	; 0x4636 <vfprintf+0x694>
    46b6:	60 96       	adiw	r28, 0x10	; 16
    46b8:	cd bf       	out	0x3d, r28	; 61
    46ba:	de bf       	out	0x3e, r29	; 62
    46bc:	df 91       	pop	r29
    46be:	cf 91       	pop	r28
    46c0:	1f 91       	pop	r17
    46c2:	0f 91       	pop	r16
    46c4:	ff 90       	pop	r15
    46c6:	ef 90       	pop	r14
    46c8:	df 90       	pop	r13
    46ca:	cf 90       	pop	r12
    46cc:	bf 90       	pop	r11
    46ce:	af 90       	pop	r10
    46d0:	9f 90       	pop	r9
    46d2:	8f 90       	pop	r8
    46d4:	7f 90       	pop	r7
    46d6:	6f 90       	pop	r6
    46d8:	5f 90       	pop	r5
    46da:	4f 90       	pop	r4
    46dc:	3f 90       	pop	r3
    46de:	2f 90       	pop	r2
    46e0:	08 95       	ret

000046e2 <__udivmodhi4>:
    46e2:	aa 1b       	sub	r26, r26
    46e4:	bb 1b       	sub	r27, r27
    46e6:	51 e1       	ldi	r21, 0x11	; 17
    46e8:	07 c0       	rjmp	.+14     	; 0x46f8 <__udivmodhi4_ep>

000046ea <__udivmodhi4_loop>:
    46ea:	aa 1f       	adc	r26, r26
    46ec:	bb 1f       	adc	r27, r27
    46ee:	a6 17       	cp	r26, r22
    46f0:	b7 07       	cpc	r27, r23
    46f2:	10 f0       	brcs	.+4      	; 0x46f8 <__udivmodhi4_ep>
    46f4:	a6 1b       	sub	r26, r22
    46f6:	b7 0b       	sbc	r27, r23

000046f8 <__udivmodhi4_ep>:
    46f8:	88 1f       	adc	r24, r24
    46fa:	99 1f       	adc	r25, r25
    46fc:	5a 95       	dec	r21
    46fe:	a9 f7       	brne	.-22     	; 0x46ea <__udivmodhi4_loop>
    4700:	80 95       	com	r24
    4702:	90 95       	com	r25
    4704:	bc 01       	movw	r22, r24
    4706:	cd 01       	movw	r24, r26
    4708:	08 95       	ret

0000470a <__divmodhi4>:
    470a:	97 fb       	bst	r25, 7
    470c:	07 2e       	mov	r0, r23
    470e:	16 f4       	brtc	.+4      	; 0x4714 <__divmodhi4+0xa>
    4710:	00 94       	com	r0
    4712:	07 d0       	rcall	.+14     	; 0x4722 <__divmodhi4_neg1>
    4714:	77 fd       	sbrc	r23, 7
    4716:	09 d0       	rcall	.+18     	; 0x472a <__divmodhi4_neg2>
    4718:	0e 94 71 23 	call	0x46e2	; 0x46e2 <__udivmodhi4>
    471c:	07 fc       	sbrc	r0, 7
    471e:	05 d0       	rcall	.+10     	; 0x472a <__divmodhi4_neg2>
    4720:	3e f4       	brtc	.+14     	; 0x4730 <__divmodhi4_exit>

00004722 <__divmodhi4_neg1>:
    4722:	90 95       	com	r25
    4724:	81 95       	neg	r24
    4726:	9f 4f       	sbci	r25, 0xFF	; 255
    4728:	08 95       	ret

0000472a <__divmodhi4_neg2>:
    472a:	70 95       	com	r23
    472c:	61 95       	neg	r22
    472e:	7f 4f       	sbci	r23, 0xFF	; 255

00004730 <__divmodhi4_exit>:
    4730:	08 95       	ret

00004732 <__umulhisi3>:
    4732:	a2 9f       	mul	r26, r18
    4734:	b0 01       	movw	r22, r0
    4736:	b3 9f       	mul	r27, r19
    4738:	c0 01       	movw	r24, r0
    473a:	a3 9f       	mul	r26, r19
    473c:	70 0d       	add	r23, r0
    473e:	81 1d       	adc	r24, r1
    4740:	11 24       	eor	r1, r1
    4742:	91 1d       	adc	r25, r1
    4744:	b2 9f       	mul	r27, r18
    4746:	70 0d       	add	r23, r0
    4748:	81 1d       	adc	r24, r1
    474a:	11 24       	eor	r1, r1
    474c:	91 1d       	adc	r25, r1
    474e:	08 95       	ret

00004750 <malloc>:
    4750:	0f 93       	push	r16
    4752:	1f 93       	push	r17
    4754:	cf 93       	push	r28
    4756:	df 93       	push	r29
    4758:	82 30       	cpi	r24, 0x02	; 2
    475a:	91 05       	cpc	r25, r1
    475c:	10 f4       	brcc	.+4      	; 0x4762 <malloc+0x12>
    475e:	82 e0       	ldi	r24, 0x02	; 2
    4760:	90 e0       	ldi	r25, 0x00	; 0
    4762:	e0 91 2a 22 	lds	r30, 0x222A	; 0x80222a <__flp>
    4766:	f0 91 2b 22 	lds	r31, 0x222B	; 0x80222b <__flp+0x1>
    476a:	20 e0       	ldi	r18, 0x00	; 0
    476c:	30 e0       	ldi	r19, 0x00	; 0
    476e:	a0 e0       	ldi	r26, 0x00	; 0
    4770:	b0 e0       	ldi	r27, 0x00	; 0
    4772:	30 97       	sbiw	r30, 0x00	; 0
    4774:	19 f1       	breq	.+70     	; 0x47bc <malloc+0x6c>
    4776:	40 81       	ld	r20, Z
    4778:	51 81       	ldd	r21, Z+1	; 0x01
    477a:	02 81       	ldd	r16, Z+2	; 0x02
    477c:	13 81       	ldd	r17, Z+3	; 0x03
    477e:	48 17       	cp	r20, r24
    4780:	59 07       	cpc	r21, r25
    4782:	c8 f0       	brcs	.+50     	; 0x47b6 <malloc+0x66>
    4784:	84 17       	cp	r24, r20
    4786:	95 07       	cpc	r25, r21
    4788:	69 f4       	brne	.+26     	; 0x47a4 <malloc+0x54>
    478a:	10 97       	sbiw	r26, 0x00	; 0
    478c:	31 f0       	breq	.+12     	; 0x479a <malloc+0x4a>
    478e:	12 96       	adiw	r26, 0x02	; 2
    4790:	0c 93       	st	X, r16
    4792:	12 97       	sbiw	r26, 0x02	; 2
    4794:	13 96       	adiw	r26, 0x03	; 3
    4796:	1c 93       	st	X, r17
    4798:	27 c0       	rjmp	.+78     	; 0x47e8 <malloc+0x98>
    479a:	00 93 2a 22 	sts	0x222A, r16	; 0x80222a <__flp>
    479e:	10 93 2b 22 	sts	0x222B, r17	; 0x80222b <__flp+0x1>
    47a2:	22 c0       	rjmp	.+68     	; 0x47e8 <malloc+0x98>
    47a4:	21 15       	cp	r18, r1
    47a6:	31 05       	cpc	r19, r1
    47a8:	19 f0       	breq	.+6      	; 0x47b0 <malloc+0x60>
    47aa:	42 17       	cp	r20, r18
    47ac:	53 07       	cpc	r21, r19
    47ae:	18 f4       	brcc	.+6      	; 0x47b6 <malloc+0x66>
    47b0:	9a 01       	movw	r18, r20
    47b2:	bd 01       	movw	r22, r26
    47b4:	ef 01       	movw	r28, r30
    47b6:	df 01       	movw	r26, r30
    47b8:	f8 01       	movw	r30, r16
    47ba:	db cf       	rjmp	.-74     	; 0x4772 <malloc+0x22>
    47bc:	21 15       	cp	r18, r1
    47be:	31 05       	cpc	r19, r1
    47c0:	f9 f0       	breq	.+62     	; 0x4800 <malloc+0xb0>
    47c2:	28 1b       	sub	r18, r24
    47c4:	39 0b       	sbc	r19, r25
    47c6:	24 30       	cpi	r18, 0x04	; 4
    47c8:	31 05       	cpc	r19, r1
    47ca:	80 f4       	brcc	.+32     	; 0x47ec <malloc+0x9c>
    47cc:	8a 81       	ldd	r24, Y+2	; 0x02
    47ce:	9b 81       	ldd	r25, Y+3	; 0x03
    47d0:	61 15       	cp	r22, r1
    47d2:	71 05       	cpc	r23, r1
    47d4:	21 f0       	breq	.+8      	; 0x47de <malloc+0x8e>
    47d6:	fb 01       	movw	r30, r22
    47d8:	82 83       	std	Z+2, r24	; 0x02
    47da:	93 83       	std	Z+3, r25	; 0x03
    47dc:	04 c0       	rjmp	.+8      	; 0x47e6 <malloc+0x96>
    47de:	80 93 2a 22 	sts	0x222A, r24	; 0x80222a <__flp>
    47e2:	90 93 2b 22 	sts	0x222B, r25	; 0x80222b <__flp+0x1>
    47e6:	fe 01       	movw	r30, r28
    47e8:	32 96       	adiw	r30, 0x02	; 2
    47ea:	44 c0       	rjmp	.+136    	; 0x4874 <malloc+0x124>
    47ec:	fe 01       	movw	r30, r28
    47ee:	e2 0f       	add	r30, r18
    47f0:	f3 1f       	adc	r31, r19
    47f2:	81 93       	st	Z+, r24
    47f4:	91 93       	st	Z+, r25
    47f6:	22 50       	subi	r18, 0x02	; 2
    47f8:	31 09       	sbc	r19, r1
    47fa:	28 83       	st	Y, r18
    47fc:	39 83       	std	Y+1, r19	; 0x01
    47fe:	3a c0       	rjmp	.+116    	; 0x4874 <malloc+0x124>
    4800:	20 91 28 22 	lds	r18, 0x2228	; 0x802228 <__brkval>
    4804:	30 91 29 22 	lds	r19, 0x2229	; 0x802229 <__brkval+0x1>
    4808:	23 2b       	or	r18, r19
    480a:	41 f4       	brne	.+16     	; 0x481c <malloc+0xcc>
    480c:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    4810:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    4814:	20 93 28 22 	sts	0x2228, r18	; 0x802228 <__brkval>
    4818:	30 93 29 22 	sts	0x2229, r19	; 0x802229 <__brkval+0x1>
    481c:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    4820:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    4824:	21 15       	cp	r18, r1
    4826:	31 05       	cpc	r19, r1
    4828:	41 f4       	brne	.+16     	; 0x483a <malloc+0xea>
    482a:	2d b7       	in	r18, 0x3d	; 61
    482c:	3e b7       	in	r19, 0x3e	; 62
    482e:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    4832:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    4836:	24 1b       	sub	r18, r20
    4838:	35 0b       	sbc	r19, r21
    483a:	e0 91 28 22 	lds	r30, 0x2228	; 0x802228 <__brkval>
    483e:	f0 91 29 22 	lds	r31, 0x2229	; 0x802229 <__brkval+0x1>
    4842:	e2 17       	cp	r30, r18
    4844:	f3 07       	cpc	r31, r19
    4846:	a0 f4       	brcc	.+40     	; 0x4870 <malloc+0x120>
    4848:	2e 1b       	sub	r18, r30
    484a:	3f 0b       	sbc	r19, r31
    484c:	28 17       	cp	r18, r24
    484e:	39 07       	cpc	r19, r25
    4850:	78 f0       	brcs	.+30     	; 0x4870 <malloc+0x120>
    4852:	ac 01       	movw	r20, r24
    4854:	4e 5f       	subi	r20, 0xFE	; 254
    4856:	5f 4f       	sbci	r21, 0xFF	; 255
    4858:	24 17       	cp	r18, r20
    485a:	35 07       	cpc	r19, r21
    485c:	48 f0       	brcs	.+18     	; 0x4870 <malloc+0x120>
    485e:	4e 0f       	add	r20, r30
    4860:	5f 1f       	adc	r21, r31
    4862:	40 93 28 22 	sts	0x2228, r20	; 0x802228 <__brkval>
    4866:	50 93 29 22 	sts	0x2229, r21	; 0x802229 <__brkval+0x1>
    486a:	81 93       	st	Z+, r24
    486c:	91 93       	st	Z+, r25
    486e:	02 c0       	rjmp	.+4      	; 0x4874 <malloc+0x124>
    4870:	e0 e0       	ldi	r30, 0x00	; 0
    4872:	f0 e0       	ldi	r31, 0x00	; 0
    4874:	cf 01       	movw	r24, r30
    4876:	df 91       	pop	r29
    4878:	cf 91       	pop	r28
    487a:	1f 91       	pop	r17
    487c:	0f 91       	pop	r16
    487e:	08 95       	ret

00004880 <free>:
    4880:	cf 93       	push	r28
    4882:	df 93       	push	r29
    4884:	00 97       	sbiw	r24, 0x00	; 0
    4886:	09 f4       	brne	.+2      	; 0x488a <free+0xa>
    4888:	81 c0       	rjmp	.+258    	; 0x498c <free+0x10c>
    488a:	fc 01       	movw	r30, r24
    488c:	32 97       	sbiw	r30, 0x02	; 2
    488e:	12 82       	std	Z+2, r1	; 0x02
    4890:	13 82       	std	Z+3, r1	; 0x03
    4892:	a0 91 2a 22 	lds	r26, 0x222A	; 0x80222a <__flp>
    4896:	b0 91 2b 22 	lds	r27, 0x222B	; 0x80222b <__flp+0x1>
    489a:	10 97       	sbiw	r26, 0x00	; 0
    489c:	81 f4       	brne	.+32     	; 0x48be <free+0x3e>
    489e:	20 81       	ld	r18, Z
    48a0:	31 81       	ldd	r19, Z+1	; 0x01
    48a2:	82 0f       	add	r24, r18
    48a4:	93 1f       	adc	r25, r19
    48a6:	20 91 28 22 	lds	r18, 0x2228	; 0x802228 <__brkval>
    48aa:	30 91 29 22 	lds	r19, 0x2229	; 0x802229 <__brkval+0x1>
    48ae:	28 17       	cp	r18, r24
    48b0:	39 07       	cpc	r19, r25
    48b2:	51 f5       	brne	.+84     	; 0x4908 <free+0x88>
    48b4:	e0 93 28 22 	sts	0x2228, r30	; 0x802228 <__brkval>
    48b8:	f0 93 29 22 	sts	0x2229, r31	; 0x802229 <__brkval+0x1>
    48bc:	67 c0       	rjmp	.+206    	; 0x498c <free+0x10c>
    48be:	ed 01       	movw	r28, r26
    48c0:	20 e0       	ldi	r18, 0x00	; 0
    48c2:	30 e0       	ldi	r19, 0x00	; 0
    48c4:	ce 17       	cp	r28, r30
    48c6:	df 07       	cpc	r29, r31
    48c8:	40 f4       	brcc	.+16     	; 0x48da <free+0x5a>
    48ca:	4a 81       	ldd	r20, Y+2	; 0x02
    48cc:	5b 81       	ldd	r21, Y+3	; 0x03
    48ce:	9e 01       	movw	r18, r28
    48d0:	41 15       	cp	r20, r1
    48d2:	51 05       	cpc	r21, r1
    48d4:	f1 f0       	breq	.+60     	; 0x4912 <free+0x92>
    48d6:	ea 01       	movw	r28, r20
    48d8:	f5 cf       	rjmp	.-22     	; 0x48c4 <free+0x44>
    48da:	c2 83       	std	Z+2, r28	; 0x02
    48dc:	d3 83       	std	Z+3, r29	; 0x03
    48de:	40 81       	ld	r20, Z
    48e0:	51 81       	ldd	r21, Z+1	; 0x01
    48e2:	84 0f       	add	r24, r20
    48e4:	95 1f       	adc	r25, r21
    48e6:	c8 17       	cp	r28, r24
    48e8:	d9 07       	cpc	r29, r25
    48ea:	59 f4       	brne	.+22     	; 0x4902 <free+0x82>
    48ec:	88 81       	ld	r24, Y
    48ee:	99 81       	ldd	r25, Y+1	; 0x01
    48f0:	84 0f       	add	r24, r20
    48f2:	95 1f       	adc	r25, r21
    48f4:	02 96       	adiw	r24, 0x02	; 2
    48f6:	80 83       	st	Z, r24
    48f8:	91 83       	std	Z+1, r25	; 0x01
    48fa:	8a 81       	ldd	r24, Y+2	; 0x02
    48fc:	9b 81       	ldd	r25, Y+3	; 0x03
    48fe:	82 83       	std	Z+2, r24	; 0x02
    4900:	93 83       	std	Z+3, r25	; 0x03
    4902:	21 15       	cp	r18, r1
    4904:	31 05       	cpc	r19, r1
    4906:	29 f4       	brne	.+10     	; 0x4912 <free+0x92>
    4908:	e0 93 2a 22 	sts	0x222A, r30	; 0x80222a <__flp>
    490c:	f0 93 2b 22 	sts	0x222B, r31	; 0x80222b <__flp+0x1>
    4910:	3d c0       	rjmp	.+122    	; 0x498c <free+0x10c>
    4912:	e9 01       	movw	r28, r18
    4914:	ea 83       	std	Y+2, r30	; 0x02
    4916:	fb 83       	std	Y+3, r31	; 0x03
    4918:	49 91       	ld	r20, Y+
    491a:	59 91       	ld	r21, Y+
    491c:	c4 0f       	add	r28, r20
    491e:	d5 1f       	adc	r29, r21
    4920:	ec 17       	cp	r30, r28
    4922:	fd 07       	cpc	r31, r29
    4924:	61 f4       	brne	.+24     	; 0x493e <free+0xbe>
    4926:	80 81       	ld	r24, Z
    4928:	91 81       	ldd	r25, Z+1	; 0x01
    492a:	84 0f       	add	r24, r20
    492c:	95 1f       	adc	r25, r21
    492e:	02 96       	adiw	r24, 0x02	; 2
    4930:	e9 01       	movw	r28, r18
    4932:	88 83       	st	Y, r24
    4934:	99 83       	std	Y+1, r25	; 0x01
    4936:	82 81       	ldd	r24, Z+2	; 0x02
    4938:	93 81       	ldd	r25, Z+3	; 0x03
    493a:	8a 83       	std	Y+2, r24	; 0x02
    493c:	9b 83       	std	Y+3, r25	; 0x03
    493e:	e0 e0       	ldi	r30, 0x00	; 0
    4940:	f0 e0       	ldi	r31, 0x00	; 0
    4942:	12 96       	adiw	r26, 0x02	; 2
    4944:	8d 91       	ld	r24, X+
    4946:	9c 91       	ld	r25, X
    4948:	13 97       	sbiw	r26, 0x03	; 3
    494a:	00 97       	sbiw	r24, 0x00	; 0
    494c:	19 f0       	breq	.+6      	; 0x4954 <free+0xd4>
    494e:	fd 01       	movw	r30, r26
    4950:	dc 01       	movw	r26, r24
    4952:	f7 cf       	rjmp	.-18     	; 0x4942 <free+0xc2>
    4954:	8d 91       	ld	r24, X+
    4956:	9c 91       	ld	r25, X
    4958:	11 97       	sbiw	r26, 0x01	; 1
    495a:	9d 01       	movw	r18, r26
    495c:	2e 5f       	subi	r18, 0xFE	; 254
    495e:	3f 4f       	sbci	r19, 0xFF	; 255
    4960:	82 0f       	add	r24, r18
    4962:	93 1f       	adc	r25, r19
    4964:	20 91 28 22 	lds	r18, 0x2228	; 0x802228 <__brkval>
    4968:	30 91 29 22 	lds	r19, 0x2229	; 0x802229 <__brkval+0x1>
    496c:	28 17       	cp	r18, r24
    496e:	39 07       	cpc	r19, r25
    4970:	69 f4       	brne	.+26     	; 0x498c <free+0x10c>
    4972:	30 97       	sbiw	r30, 0x00	; 0
    4974:	29 f4       	brne	.+10     	; 0x4980 <free+0x100>
    4976:	10 92 2a 22 	sts	0x222A, r1	; 0x80222a <__flp>
    497a:	10 92 2b 22 	sts	0x222B, r1	; 0x80222b <__flp+0x1>
    497e:	02 c0       	rjmp	.+4      	; 0x4984 <free+0x104>
    4980:	12 82       	std	Z+2, r1	; 0x02
    4982:	13 82       	std	Z+3, r1	; 0x03
    4984:	a0 93 28 22 	sts	0x2228, r26	; 0x802228 <__brkval>
    4988:	b0 93 29 22 	sts	0x2229, r27	; 0x802229 <__brkval+0x1>
    498c:	df 91       	pop	r29
    498e:	cf 91       	pop	r28
    4990:	08 95       	ret

00004992 <__ftoa_engine>:
    4992:	28 30       	cpi	r18, 0x08	; 8
    4994:	08 f0       	brcs	.+2      	; 0x4998 <__ftoa_engine+0x6>
    4996:	27 e0       	ldi	r18, 0x07	; 7
    4998:	33 27       	eor	r19, r19
    499a:	da 01       	movw	r26, r20
    499c:	99 0f       	add	r25, r25
    499e:	31 1d       	adc	r19, r1
    49a0:	87 fd       	sbrc	r24, 7
    49a2:	91 60       	ori	r25, 0x01	; 1
    49a4:	00 96       	adiw	r24, 0x00	; 0
    49a6:	61 05       	cpc	r22, r1
    49a8:	71 05       	cpc	r23, r1
    49aa:	39 f4       	brne	.+14     	; 0x49ba <__ftoa_engine+0x28>
    49ac:	32 60       	ori	r19, 0x02	; 2
    49ae:	2e 5f       	subi	r18, 0xFE	; 254
    49b0:	3d 93       	st	X+, r19
    49b2:	30 e3       	ldi	r19, 0x30	; 48
    49b4:	2a 95       	dec	r18
    49b6:	e1 f7       	brne	.-8      	; 0x49b0 <__ftoa_engine+0x1e>
    49b8:	08 95       	ret
    49ba:	9f 3f       	cpi	r25, 0xFF	; 255
    49bc:	30 f0       	brcs	.+12     	; 0x49ca <__ftoa_engine+0x38>
    49be:	80 38       	cpi	r24, 0x80	; 128
    49c0:	71 05       	cpc	r23, r1
    49c2:	61 05       	cpc	r22, r1
    49c4:	09 f0       	breq	.+2      	; 0x49c8 <__ftoa_engine+0x36>
    49c6:	3c 5f       	subi	r19, 0xFC	; 252
    49c8:	3c 5f       	subi	r19, 0xFC	; 252
    49ca:	3d 93       	st	X+, r19
    49cc:	91 30       	cpi	r25, 0x01	; 1
    49ce:	08 f0       	brcs	.+2      	; 0x49d2 <__ftoa_engine+0x40>
    49d0:	80 68       	ori	r24, 0x80	; 128
    49d2:	91 1d       	adc	r25, r1
    49d4:	df 93       	push	r29
    49d6:	cf 93       	push	r28
    49d8:	1f 93       	push	r17
    49da:	0f 93       	push	r16
    49dc:	ff 92       	push	r15
    49de:	ef 92       	push	r14
    49e0:	19 2f       	mov	r17, r25
    49e2:	98 7f       	andi	r25, 0xF8	; 248
    49e4:	96 95       	lsr	r25
    49e6:	e9 2f       	mov	r30, r25
    49e8:	96 95       	lsr	r25
    49ea:	96 95       	lsr	r25
    49ec:	e9 0f       	add	r30, r25
    49ee:	ff 27       	eor	r31, r31
    49f0:	ee 58       	subi	r30, 0x8E	; 142
    49f2:	fd 4f       	sbci	r31, 0xFD	; 253
    49f4:	99 27       	eor	r25, r25
    49f6:	33 27       	eor	r19, r19
    49f8:	ee 24       	eor	r14, r14
    49fa:	ff 24       	eor	r15, r15
    49fc:	a7 01       	movw	r20, r14
    49fe:	e7 01       	movw	r28, r14
    4a00:	05 90       	lpm	r0, Z+
    4a02:	08 94       	sec
    4a04:	07 94       	ror	r0
    4a06:	28 f4       	brcc	.+10     	; 0x4a12 <__ftoa_engine+0x80>
    4a08:	36 0f       	add	r19, r22
    4a0a:	e7 1e       	adc	r14, r23
    4a0c:	f8 1e       	adc	r15, r24
    4a0e:	49 1f       	adc	r20, r25
    4a10:	51 1d       	adc	r21, r1
    4a12:	66 0f       	add	r22, r22
    4a14:	77 1f       	adc	r23, r23
    4a16:	88 1f       	adc	r24, r24
    4a18:	99 1f       	adc	r25, r25
    4a1a:	06 94       	lsr	r0
    4a1c:	a1 f7       	brne	.-24     	; 0x4a06 <__ftoa_engine+0x74>
    4a1e:	05 90       	lpm	r0, Z+
    4a20:	07 94       	ror	r0
    4a22:	28 f4       	brcc	.+10     	; 0x4a2e <__ftoa_engine+0x9c>
    4a24:	e7 0e       	add	r14, r23
    4a26:	f8 1e       	adc	r15, r24
    4a28:	49 1f       	adc	r20, r25
    4a2a:	56 1f       	adc	r21, r22
    4a2c:	c1 1d       	adc	r28, r1
    4a2e:	77 0f       	add	r23, r23
    4a30:	88 1f       	adc	r24, r24
    4a32:	99 1f       	adc	r25, r25
    4a34:	66 1f       	adc	r22, r22
    4a36:	06 94       	lsr	r0
    4a38:	a1 f7       	brne	.-24     	; 0x4a22 <__ftoa_engine+0x90>
    4a3a:	05 90       	lpm	r0, Z+
    4a3c:	07 94       	ror	r0
    4a3e:	28 f4       	brcc	.+10     	; 0x4a4a <__ftoa_engine+0xb8>
    4a40:	f8 0e       	add	r15, r24
    4a42:	49 1f       	adc	r20, r25
    4a44:	56 1f       	adc	r21, r22
    4a46:	c7 1f       	adc	r28, r23
    4a48:	d1 1d       	adc	r29, r1
    4a4a:	88 0f       	add	r24, r24
    4a4c:	99 1f       	adc	r25, r25
    4a4e:	66 1f       	adc	r22, r22
    4a50:	77 1f       	adc	r23, r23
    4a52:	06 94       	lsr	r0
    4a54:	a1 f7       	brne	.-24     	; 0x4a3e <__ftoa_engine+0xac>
    4a56:	05 90       	lpm	r0, Z+
    4a58:	07 94       	ror	r0
    4a5a:	20 f4       	brcc	.+8      	; 0x4a64 <__ftoa_engine+0xd2>
    4a5c:	49 0f       	add	r20, r25
    4a5e:	56 1f       	adc	r21, r22
    4a60:	c7 1f       	adc	r28, r23
    4a62:	d8 1f       	adc	r29, r24
    4a64:	99 0f       	add	r25, r25
    4a66:	66 1f       	adc	r22, r22
    4a68:	77 1f       	adc	r23, r23
    4a6a:	88 1f       	adc	r24, r24
    4a6c:	06 94       	lsr	r0
    4a6e:	a9 f7       	brne	.-22     	; 0x4a5a <__ftoa_engine+0xc8>
    4a70:	84 91       	lpm	r24, Z
    4a72:	10 95       	com	r17
    4a74:	17 70       	andi	r17, 0x07	; 7
    4a76:	41 f0       	breq	.+16     	; 0x4a88 <__ftoa_engine+0xf6>
    4a78:	d6 95       	lsr	r29
    4a7a:	c7 95       	ror	r28
    4a7c:	57 95       	ror	r21
    4a7e:	47 95       	ror	r20
    4a80:	f7 94       	ror	r15
    4a82:	e7 94       	ror	r14
    4a84:	1a 95       	dec	r17
    4a86:	c1 f7       	brne	.-16     	; 0x4a78 <__ftoa_engine+0xe6>
    4a88:	e8 e1       	ldi	r30, 0x18	; 24
    4a8a:	f2 e0       	ldi	r31, 0x02	; 2
    4a8c:	68 94       	set
    4a8e:	15 90       	lpm	r1, Z+
    4a90:	15 91       	lpm	r17, Z+
    4a92:	35 91       	lpm	r19, Z+
    4a94:	65 91       	lpm	r22, Z+
    4a96:	95 91       	lpm	r25, Z+
    4a98:	05 90       	lpm	r0, Z+
    4a9a:	7f e2       	ldi	r23, 0x2F	; 47
    4a9c:	73 95       	inc	r23
    4a9e:	e1 18       	sub	r14, r1
    4aa0:	f1 0a       	sbc	r15, r17
    4aa2:	43 0b       	sbc	r20, r19
    4aa4:	56 0b       	sbc	r21, r22
    4aa6:	c9 0b       	sbc	r28, r25
    4aa8:	d0 09       	sbc	r29, r0
    4aaa:	c0 f7       	brcc	.-16     	; 0x4a9c <__ftoa_engine+0x10a>
    4aac:	e1 0c       	add	r14, r1
    4aae:	f1 1e       	adc	r15, r17
    4ab0:	43 1f       	adc	r20, r19
    4ab2:	56 1f       	adc	r21, r22
    4ab4:	c9 1f       	adc	r28, r25
    4ab6:	d0 1d       	adc	r29, r0
    4ab8:	7e f4       	brtc	.+30     	; 0x4ad8 <__ftoa_engine+0x146>
    4aba:	70 33       	cpi	r23, 0x30	; 48
    4abc:	11 f4       	brne	.+4      	; 0x4ac2 <__ftoa_engine+0x130>
    4abe:	8a 95       	dec	r24
    4ac0:	e6 cf       	rjmp	.-52     	; 0x4a8e <__ftoa_engine+0xfc>
    4ac2:	e8 94       	clt
    4ac4:	01 50       	subi	r16, 0x01	; 1
    4ac6:	30 f0       	brcs	.+12     	; 0x4ad4 <__ftoa_engine+0x142>
    4ac8:	08 0f       	add	r16, r24
    4aca:	0a f4       	brpl	.+2      	; 0x4ace <__ftoa_engine+0x13c>
    4acc:	00 27       	eor	r16, r16
    4ace:	02 17       	cp	r16, r18
    4ad0:	08 f4       	brcc	.+2      	; 0x4ad4 <__ftoa_engine+0x142>
    4ad2:	20 2f       	mov	r18, r16
    4ad4:	23 95       	inc	r18
    4ad6:	02 2f       	mov	r16, r18
    4ad8:	7a 33       	cpi	r23, 0x3A	; 58
    4ada:	28 f0       	brcs	.+10     	; 0x4ae6 <__ftoa_engine+0x154>
    4adc:	79 e3       	ldi	r23, 0x39	; 57
    4ade:	7d 93       	st	X+, r23
    4ae0:	2a 95       	dec	r18
    4ae2:	e9 f7       	brne	.-6      	; 0x4ade <__ftoa_engine+0x14c>
    4ae4:	10 c0       	rjmp	.+32     	; 0x4b06 <__ftoa_engine+0x174>
    4ae6:	7d 93       	st	X+, r23
    4ae8:	2a 95       	dec	r18
    4aea:	89 f6       	brne	.-94     	; 0x4a8e <__ftoa_engine+0xfc>
    4aec:	06 94       	lsr	r0
    4aee:	97 95       	ror	r25
    4af0:	67 95       	ror	r22
    4af2:	37 95       	ror	r19
    4af4:	17 95       	ror	r17
    4af6:	17 94       	ror	r1
    4af8:	e1 18       	sub	r14, r1
    4afa:	f1 0a       	sbc	r15, r17
    4afc:	43 0b       	sbc	r20, r19
    4afe:	56 0b       	sbc	r21, r22
    4b00:	c9 0b       	sbc	r28, r25
    4b02:	d0 09       	sbc	r29, r0
    4b04:	98 f0       	brcs	.+38     	; 0x4b2c <__ftoa_engine+0x19a>
    4b06:	23 95       	inc	r18
    4b08:	7e 91       	ld	r23, -X
    4b0a:	73 95       	inc	r23
    4b0c:	7a 33       	cpi	r23, 0x3A	; 58
    4b0e:	08 f0       	brcs	.+2      	; 0x4b12 <__ftoa_engine+0x180>
    4b10:	70 e3       	ldi	r23, 0x30	; 48
    4b12:	7c 93       	st	X, r23
    4b14:	20 13       	cpse	r18, r16
    4b16:	b8 f7       	brcc	.-18     	; 0x4b06 <__ftoa_engine+0x174>
    4b18:	7e 91       	ld	r23, -X
    4b1a:	70 61       	ori	r23, 0x10	; 16
    4b1c:	7d 93       	st	X+, r23
    4b1e:	30 f0       	brcs	.+12     	; 0x4b2c <__ftoa_engine+0x19a>
    4b20:	83 95       	inc	r24
    4b22:	71 e3       	ldi	r23, 0x31	; 49
    4b24:	7d 93       	st	X+, r23
    4b26:	70 e3       	ldi	r23, 0x30	; 48
    4b28:	2a 95       	dec	r18
    4b2a:	e1 f7       	brne	.-8      	; 0x4b24 <__ftoa_engine+0x192>
    4b2c:	11 24       	eor	r1, r1
    4b2e:	ef 90       	pop	r14
    4b30:	ff 90       	pop	r15
    4b32:	0f 91       	pop	r16
    4b34:	1f 91       	pop	r17
    4b36:	cf 91       	pop	r28
    4b38:	df 91       	pop	r29
    4b3a:	99 27       	eor	r25, r25
    4b3c:	87 fd       	sbrc	r24, 7
    4b3e:	90 95       	com	r25
    4b40:	08 95       	ret

00004b42 <strnlen_P>:
    4b42:	fc 01       	movw	r30, r24
    4b44:	05 90       	lpm	r0, Z+
    4b46:	61 50       	subi	r22, 0x01	; 1
    4b48:	70 40       	sbci	r23, 0x00	; 0
    4b4a:	01 10       	cpse	r0, r1
    4b4c:	d8 f7       	brcc	.-10     	; 0x4b44 <strnlen_P+0x2>
    4b4e:	80 95       	com	r24
    4b50:	90 95       	com	r25
    4b52:	8e 0f       	add	r24, r30
    4b54:	9f 1f       	adc	r25, r31
    4b56:	08 95       	ret

00004b58 <memcpy>:
    4b58:	fb 01       	movw	r30, r22
    4b5a:	dc 01       	movw	r26, r24
    4b5c:	02 c0       	rjmp	.+4      	; 0x4b62 <memcpy+0xa>
    4b5e:	01 90       	ld	r0, Z+
    4b60:	0d 92       	st	X+, r0
    4b62:	41 50       	subi	r20, 0x01	; 1
    4b64:	50 40       	sbci	r21, 0x00	; 0
    4b66:	d8 f7       	brcc	.-10     	; 0x4b5e <memcpy+0x6>
    4b68:	08 95       	ret

00004b6a <memset>:
    4b6a:	dc 01       	movw	r26, r24
    4b6c:	01 c0       	rjmp	.+2      	; 0x4b70 <memset+0x6>
    4b6e:	6d 93       	st	X+, r22
    4b70:	41 50       	subi	r20, 0x01	; 1
    4b72:	50 40       	sbci	r21, 0x00	; 0
    4b74:	e0 f7       	brcc	.-8      	; 0x4b6e <memset+0x4>
    4b76:	08 95       	ret

00004b78 <strnlen>:
    4b78:	fc 01       	movw	r30, r24
    4b7a:	61 50       	subi	r22, 0x01	; 1
    4b7c:	70 40       	sbci	r23, 0x00	; 0
    4b7e:	01 90       	ld	r0, Z+
    4b80:	01 10       	cpse	r0, r1
    4b82:	d8 f7       	brcc	.-10     	; 0x4b7a <strnlen+0x2>
    4b84:	80 95       	com	r24
    4b86:	90 95       	com	r25
    4b88:	8e 0f       	add	r24, r30
    4b8a:	9f 1f       	adc	r25, r31
    4b8c:	08 95       	ret

00004b8e <fputc>:
    4b8e:	0f 93       	push	r16
    4b90:	1f 93       	push	r17
    4b92:	cf 93       	push	r28
    4b94:	df 93       	push	r29
    4b96:	fb 01       	movw	r30, r22
    4b98:	23 81       	ldd	r18, Z+3	; 0x03
    4b9a:	21 fd       	sbrc	r18, 1
    4b9c:	03 c0       	rjmp	.+6      	; 0x4ba4 <fputc+0x16>
    4b9e:	8f ef       	ldi	r24, 0xFF	; 255
    4ba0:	9f ef       	ldi	r25, 0xFF	; 255
    4ba2:	2c c0       	rjmp	.+88     	; 0x4bfc <fputc+0x6e>
    4ba4:	22 ff       	sbrs	r18, 2
    4ba6:	16 c0       	rjmp	.+44     	; 0x4bd4 <fputc+0x46>
    4ba8:	46 81       	ldd	r20, Z+6	; 0x06
    4baa:	57 81       	ldd	r21, Z+7	; 0x07
    4bac:	24 81       	ldd	r18, Z+4	; 0x04
    4bae:	35 81       	ldd	r19, Z+5	; 0x05
    4bb0:	42 17       	cp	r20, r18
    4bb2:	53 07       	cpc	r21, r19
    4bb4:	44 f4       	brge	.+16     	; 0x4bc6 <fputc+0x38>
    4bb6:	a0 81       	ld	r26, Z
    4bb8:	b1 81       	ldd	r27, Z+1	; 0x01
    4bba:	9d 01       	movw	r18, r26
    4bbc:	2f 5f       	subi	r18, 0xFF	; 255
    4bbe:	3f 4f       	sbci	r19, 0xFF	; 255
    4bc0:	20 83       	st	Z, r18
    4bc2:	31 83       	std	Z+1, r19	; 0x01
    4bc4:	8c 93       	st	X, r24
    4bc6:	26 81       	ldd	r18, Z+6	; 0x06
    4bc8:	37 81       	ldd	r19, Z+7	; 0x07
    4bca:	2f 5f       	subi	r18, 0xFF	; 255
    4bcc:	3f 4f       	sbci	r19, 0xFF	; 255
    4bce:	26 83       	std	Z+6, r18	; 0x06
    4bd0:	37 83       	std	Z+7, r19	; 0x07
    4bd2:	14 c0       	rjmp	.+40     	; 0x4bfc <fputc+0x6e>
    4bd4:	8b 01       	movw	r16, r22
    4bd6:	ec 01       	movw	r28, r24
    4bd8:	fb 01       	movw	r30, r22
    4bda:	00 84       	ldd	r0, Z+8	; 0x08
    4bdc:	f1 85       	ldd	r31, Z+9	; 0x09
    4bde:	e0 2d       	mov	r30, r0
    4be0:	19 95       	eicall
    4be2:	89 2b       	or	r24, r25
    4be4:	e1 f6       	brne	.-72     	; 0x4b9e <fputc+0x10>
    4be6:	d8 01       	movw	r26, r16
    4be8:	16 96       	adiw	r26, 0x06	; 6
    4bea:	8d 91       	ld	r24, X+
    4bec:	9c 91       	ld	r25, X
    4bee:	17 97       	sbiw	r26, 0x07	; 7
    4bf0:	01 96       	adiw	r24, 0x01	; 1
    4bf2:	16 96       	adiw	r26, 0x06	; 6
    4bf4:	8d 93       	st	X+, r24
    4bf6:	9c 93       	st	X, r25
    4bf8:	17 97       	sbiw	r26, 0x07	; 7
    4bfa:	ce 01       	movw	r24, r28
    4bfc:	df 91       	pop	r29
    4bfe:	cf 91       	pop	r28
    4c00:	1f 91       	pop	r17
    4c02:	0f 91       	pop	r16
    4c04:	08 95       	ret

00004c06 <__ultoa_invert>:
    4c06:	fa 01       	movw	r30, r20
    4c08:	aa 27       	eor	r26, r26
    4c0a:	28 30       	cpi	r18, 0x08	; 8
    4c0c:	51 f1       	breq	.+84     	; 0x4c62 <__ultoa_invert+0x5c>
    4c0e:	20 31       	cpi	r18, 0x10	; 16
    4c10:	81 f1       	breq	.+96     	; 0x4c72 <__ultoa_invert+0x6c>
    4c12:	e8 94       	clt
    4c14:	6f 93       	push	r22
    4c16:	6e 7f       	andi	r22, 0xFE	; 254
    4c18:	6e 5f       	subi	r22, 0xFE	; 254
    4c1a:	7f 4f       	sbci	r23, 0xFF	; 255
    4c1c:	8f 4f       	sbci	r24, 0xFF	; 255
    4c1e:	9f 4f       	sbci	r25, 0xFF	; 255
    4c20:	af 4f       	sbci	r26, 0xFF	; 255
    4c22:	b1 e0       	ldi	r27, 0x01	; 1
    4c24:	3e d0       	rcall	.+124    	; 0x4ca2 <__ultoa_invert+0x9c>
    4c26:	b4 e0       	ldi	r27, 0x04	; 4
    4c28:	3c d0       	rcall	.+120    	; 0x4ca2 <__ultoa_invert+0x9c>
    4c2a:	67 0f       	add	r22, r23
    4c2c:	78 1f       	adc	r23, r24
    4c2e:	89 1f       	adc	r24, r25
    4c30:	9a 1f       	adc	r25, r26
    4c32:	a1 1d       	adc	r26, r1
    4c34:	68 0f       	add	r22, r24
    4c36:	79 1f       	adc	r23, r25
    4c38:	8a 1f       	adc	r24, r26
    4c3a:	91 1d       	adc	r25, r1
    4c3c:	a1 1d       	adc	r26, r1
    4c3e:	6a 0f       	add	r22, r26
    4c40:	71 1d       	adc	r23, r1
    4c42:	81 1d       	adc	r24, r1
    4c44:	91 1d       	adc	r25, r1
    4c46:	a1 1d       	adc	r26, r1
    4c48:	20 d0       	rcall	.+64     	; 0x4c8a <__ultoa_invert+0x84>
    4c4a:	09 f4       	brne	.+2      	; 0x4c4e <__ultoa_invert+0x48>
    4c4c:	68 94       	set
    4c4e:	3f 91       	pop	r19
    4c50:	2a e0       	ldi	r18, 0x0A	; 10
    4c52:	26 9f       	mul	r18, r22
    4c54:	11 24       	eor	r1, r1
    4c56:	30 19       	sub	r19, r0
    4c58:	30 5d       	subi	r19, 0xD0	; 208
    4c5a:	31 93       	st	Z+, r19
    4c5c:	de f6       	brtc	.-74     	; 0x4c14 <__ultoa_invert+0xe>
    4c5e:	cf 01       	movw	r24, r30
    4c60:	08 95       	ret
    4c62:	46 2f       	mov	r20, r22
    4c64:	47 70       	andi	r20, 0x07	; 7
    4c66:	40 5d       	subi	r20, 0xD0	; 208
    4c68:	41 93       	st	Z+, r20
    4c6a:	b3 e0       	ldi	r27, 0x03	; 3
    4c6c:	0f d0       	rcall	.+30     	; 0x4c8c <__ultoa_invert+0x86>
    4c6e:	c9 f7       	brne	.-14     	; 0x4c62 <__ultoa_invert+0x5c>
    4c70:	f6 cf       	rjmp	.-20     	; 0x4c5e <__ultoa_invert+0x58>
    4c72:	46 2f       	mov	r20, r22
    4c74:	4f 70       	andi	r20, 0x0F	; 15
    4c76:	40 5d       	subi	r20, 0xD0	; 208
    4c78:	4a 33       	cpi	r20, 0x3A	; 58
    4c7a:	18 f0       	brcs	.+6      	; 0x4c82 <__ultoa_invert+0x7c>
    4c7c:	49 5d       	subi	r20, 0xD9	; 217
    4c7e:	31 fd       	sbrc	r19, 1
    4c80:	40 52       	subi	r20, 0x20	; 32
    4c82:	41 93       	st	Z+, r20
    4c84:	02 d0       	rcall	.+4      	; 0x4c8a <__ultoa_invert+0x84>
    4c86:	a9 f7       	brne	.-22     	; 0x4c72 <__ultoa_invert+0x6c>
    4c88:	ea cf       	rjmp	.-44     	; 0x4c5e <__ultoa_invert+0x58>
    4c8a:	b4 e0       	ldi	r27, 0x04	; 4
    4c8c:	a6 95       	lsr	r26
    4c8e:	97 95       	ror	r25
    4c90:	87 95       	ror	r24
    4c92:	77 95       	ror	r23
    4c94:	67 95       	ror	r22
    4c96:	ba 95       	dec	r27
    4c98:	c9 f7       	brne	.-14     	; 0x4c8c <__ultoa_invert+0x86>
    4c9a:	00 97       	sbiw	r24, 0x00	; 0
    4c9c:	61 05       	cpc	r22, r1
    4c9e:	71 05       	cpc	r23, r1
    4ca0:	08 95       	ret
    4ca2:	9b 01       	movw	r18, r22
    4ca4:	ac 01       	movw	r20, r24
    4ca6:	0a 2e       	mov	r0, r26
    4ca8:	06 94       	lsr	r0
    4caa:	57 95       	ror	r21
    4cac:	47 95       	ror	r20
    4cae:	37 95       	ror	r19
    4cb0:	27 95       	ror	r18
    4cb2:	ba 95       	dec	r27
    4cb4:	c9 f7       	brne	.-14     	; 0x4ca8 <__ultoa_invert+0xa2>
    4cb6:	62 0f       	add	r22, r18
    4cb8:	73 1f       	adc	r23, r19
    4cba:	84 1f       	adc	r24, r20
    4cbc:	95 1f       	adc	r25, r21
    4cbe:	a0 1d       	adc	r26, r0
    4cc0:	08 95       	ret

00004cc2 <_exit>:
    4cc2:	f8 94       	cli

00004cc4 <__stop_program>:
    4cc4:	ff cf       	rjmp	.-2      	; 0x4cc4 <__stop_program>
